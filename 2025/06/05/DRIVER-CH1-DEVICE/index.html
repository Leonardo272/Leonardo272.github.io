<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>驱动开发-设备驱动模块 | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LINUX设备驱动模块设备驱动程序，就是驱使设备按照用户的预期进行工作的软件，它是应用程序与设备沟通的桥梁。设备驱动程序主要负责硬件设备的参数配置、数据读写与中断处理。 Linux中的大部分驱动程序是以内核模块的形式编写的。内核模块是Linux 内核向外部提供的一个接口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM）。 驱动程序的加载方式内核模式将新驱动程序编译">
<meta property="og:type" content="article">
<meta property="og:title" content="驱动开发-设备驱动模块">
<meta property="og:url" content="https://leonardo272.github.io/2025/06/05/DRIVER-CH1-DEVICE/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="LINUX设备驱动模块设备驱动程序，就是驱使设备按照用户的预期进行工作的软件，它是应用程序与设备沟通的桥梁。设备驱动程序主要负责硬件设备的参数配置、数据读写与中断处理。 Linux中的大部分驱动程序是以内核模块的形式编写的。内核模块是Linux 内核向外部提供的一个接口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM）。 驱动程序的加载方式内核模式将新驱动程序编译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/2.jpg">
<meta property="article:published_time" content="2025-06-05T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-08T10:50:42.726Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/2.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "驱动开发-设备驱动模块",
  "url": "https://leonardo272.github.io/2025/06/05/DRIVER-CH1-DEVICE/",
  "image": "https://leonardo272.github.io/page_images/2.jpg",
  "datePublished": "2025-06-05T13:12:00.000Z",
  "dateModified": "2025-09-08T10:50:42.726Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/06/05/DRIVER-CH1-DEVICE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '驱动开发-设备驱动模块',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">驱动开发-设备驱动模块</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">驱动开发-设备驱动模块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-05T13:12:00.000Z" title="发表于 2025-06-05 21:12:00">2025-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-08T10:50:42.726Z" title="更新于 2025-09-08 18:50:42">2025-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/">驱动学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="LINUX设备驱动模块"><a href="#LINUX设备驱动模块" class="headerlink" title="LINUX设备驱动模块"></a>LINUX设备驱动模块</h1><p>设备驱动程序，就是驱使设备按照用户的预期进行工作的软件，它是应用程序与设备沟通的桥梁。设备驱动程序主要负责硬件设备的参数配置、数据读写与中断处理。</p>
<p>Linux中的大部分驱动程序是以内核模块的形式编写的。内核模块是Linux 内核向外部提供的一个接口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM）。</p>
<h2 id="驱动程序的加载方式"><a href="#驱动程序的加载方式" class="headerlink" title="驱动程序的加载方式"></a>驱动程序的加载方式</h2><h3 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h3><p>将新驱动程序<strong>编译进内核</strong>，需要修改<strong>内核代码</strong>和<strong>编译选项</strong>，这种方式将驱动程序代码直接编译到内核镜像（<code>zImage</code>或<code>uImage</code>等）中，成为内核的一部分。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>集成度高</strong>：驱动随内核启动自动加载，无法卸载。</li>
<li><strong>性能稍好</strong>：省去了模块加载和解析的开销。</li>
<li><strong>安全性&#x2F;稳定性高</strong>：常用于系统最核心、必须的驱动（如根文件系统驱动）。</li>
<li><strong>内核体积大</strong>：所有驱动都会被编译进去，导致内核镜像文件变大。</li>
</ul>
<p><strong>配置方法</strong>：通过内核的配置菜单（<code>make menuconfig</code>等）将对应的驱动选项配置为 <code>y</code>。</p>
<h4 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h4><p>本次实验是通过静态添加自己编写的驱动如：beep.c&#x2F;ap3216c.c&#x2F;icm20608.c等驱动。</p>
<p><strong>步骤一：</strong></p>
<p><strong>找到驱动放置的路径，将自己编写好的驱动放在这个路径下</strong>，<strong>一般是<code>linux-kernel/drivers/xxx</code>路径下</strong>：</p>
<ul>
<li>蜂鸣器（beep）这种简单的字符设备，通常可以放在 <code>linux-kernel/drivers/char/</code>（老习惯）或 <code>linux-kernel/drivers/misc/</code>（现在更常见）目录下。<code>misc</code> 是“混杂设备”的意思，专门放置无法简单归类的简单字符设备驱动。</li>
<li>I2C 客户端设备（如传感器）的驱动都放在这个目录或其子目录下。你可以直接放在 <code>drivers/i2c/</code> 下，或者为其新建一个子目录，比如 <code>drivers/i2c/sensors/</code>（如果有很多传感器驱动，这样管理更清晰）。</li>
<li>SPI 设备驱动应放在 <code>linux-kernel/drivers/spi/</code> 目录下。</li>
</ul>
<img src="image-20250908134947864.png" alt="image-20250908134947864" style="zoom:67%;">

<hr>
<p><strong>步骤二：</strong></p>
<p>修改<strong>对应目录</strong>的<strong>Kconfig</strong>和<strong>Makefile</strong></p>
<ul>
<li><p><strong>Makefile文件</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_CHAR_BEEP)</span> += beep.o</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>如果在使用<code>make menuconfig</code>的时候配置选项 <code>CONFIG_MISC_BEEP</code> 被设置为 <code>y</code>，则将 <code>beep.o</code> 编译进内核。</li>
<li>如果被设置为 <code>m</code>，则将 <code>beep.o</code> 编译成模块 (<code>beep.ko</code>)。</li>
<li>如果未设置，则不编译。</li>
</ul>
</li>
<li><p><strong>kconfig文件</strong></p>
<p>找到我们放置路径对应的文件夹下面的kconfig文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config CHAR_BEEP</span><br><span class="line">    tristate &quot;CHAR BEEP Device Support&quot;</span><br><span class="line">    default n</span><br><span class="line">    help</span><br><span class="line">      This is a simple beep driver for testing.</span><br><span class="line">      Say Y here if you want to support the beep.</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li><code>config MISC_BEEP</code>：定义了一个配置符号，它必须与 Makefile 中的 <code>CONFIG_</code> 前缀后的名字完全一致。</li>
<li><code>tristate</code>：表示该配置有三种状态：<code>y</code>(内置), <code>m</code>(模块), <code>n</code>(不编译)。</li>
<li><code>&quot;MISC BEEP Device Support&quot;</code>：这是在 <code>make menuconfig</code> 中显示的菜单文本。</li>
<li><code>default n</code>：默认状态为不编译。</li>
<li><code>help</code>：后面的文字是帮助信息。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>步骤三：</strong></p>
<p><strong>配置内核并编译</strong></p>
<ul>
<li><p><strong>进入内核源码根目录</strong></p>
</li>
<li><p><strong>启动配置菜单</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在菜单中找到你的驱动</strong>：</p>
<ul>
<li><p>根据你在 <code>Kconfig</code> 中设置的路径，你的驱动会出现在相应的子菜单中。例如，<code>beep</code> 驱动会在：<br><code>Device Drivers -&gt; [*] Character devices -&gt; &lt;*&gt; CHAR BEEP Device Support</code></p>
</li>
<li><p>使用空格键将选项设置为 <code>&lt;*&gt;</code> (编译进内核) 或 <code>&lt;M&gt;</code> (编译为模块)。(Pressing <Y>includes, <N> excludes, <M> modularizes features)</M></N></Y></p>
<img src="image-20250908135942511.png" alt="image-20250908135942511" style="zoom: 67%;">

<img src="image-20250908140059903.png" alt="image-20250908140059903" style="zoom:67%;">

<img src="image-20250908140128935.png" alt="image-20250908140128935" style="zoom:67%;"></li>
</ul>
</li>
<li><p><strong>保存配置并退出</strong></p>
<img src="image-20250908140457162.png" alt="image-20250908140457162" style="zoom:67%;">
</li>
<li><p><strong>编译内核</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc) # 使用所有CPU核心进行编译，加快速度</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>步骤四：</strong></p>
<p><strong>更新你的开发板系统</strong>：将新编译的内核镜像烧写或拷贝到你的开发板上，并重启。<code>cp zImage /tftpboot/</code></p>
<hr>
<p><strong>对其他驱动的操作</strong>：对 <code>ap3216c.c</code> 和 <code>icm20608.c</code> 进行完全相同的操作，只不过是在它们对应的 <code>drivers/i2c/</code> 和 <code>drivers/spi/</code> 目录下的 <code>Kconfig</code> 和 <code>Makefile</code> 中进行修改。配置符号的名字可以自己定，但要清晰易懂，例如 <code>CONFIG_I2C_AP3216C</code> 和 <code>CONFIG_SPI_ICM20608</code>。</p>
<h3 id="动态加载与卸载"><a href="#动态加载与卸载" class="headerlink" title="动态加载与卸载"></a>动态加载与卸载</h3><p>这是驱动开发调试阶段最常用、最灵活的方式。驱动程序被编译成 <strong>.ko</strong> (Kernel Object) 文件，而不是直接链接进内核镜像。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>灵活性高</strong>：可以在系统运行时动态地加载和卸载，无需重启系统。</li>
<li><strong>节省内存</strong>：不需要的驱动可以不加载，减少内核占用内存。</li>
<li><strong>易于调试</strong>：开发调试周期短，修改代码后重新编译并加载即可。</li>
</ul>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>insmod</code>：最基础的加载命令，<code>sudo insmod beep.ko</code>。但它不解决模块依赖。</li>
<li><code>modprobe</code>：更智能的加载命令，它会自动从<code>lib/modules/$(uname -r)</code>目录查找并加载模块所依赖的其他模块。<strong>需要先运行<code>depmod</code>生成模块依赖关系。</strong></li>
<li><code>rmmod</code>：卸载模块，<code>sudo rmmod beep</code>。</li>
<li><code>lsmod</code>：查看当前已加载的所有模块。</li>
</ul>
<h2 id="模块的编写"><a href="#模块的编写" class="headerlink" title="模块的编写"></a>模块的编写</h2><h3 id="模块的加载与卸载"><a href="#模块的加载与卸载" class="headerlink" title="模块的加载与卸载"></a>模块的加载与卸载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(XXX_init);//注册模块加载函数</span><br><span class="line">module_exit(xxx_exit);//注册模块卸载函数</span><br></pre></td></tr></table></figure>

<p>**module_exit()**函数用来向Linux内核注册一个模块加载函数，参数xxx_init就是需要注册的具体函数，<strong>当使用“insmod”、”modprobe”命令加载驱动的时候，xxx_init 这个函数就会被调用</strong>；</p>
<p>**module_exit()**函数用来向Linux内核注册一个模块卸载函数，参数xxx_exit 就是需要注册的具体函数，<strong>当使用“rmmod”命令卸载具体驱动的时候xxx_exit 函数就会被调用</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 入口函数具体内容 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 出口函数具体内容 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个典型的字符串驱动模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span> <span class="comment">// 必须包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">beep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">beep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">module_init(beep_init);</span><br><span class="line">module_exit(beep_exit);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;KEVIN&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编写它对应的Makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/arm-linux/MX6U/linux-core</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">obj-m := bepp.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	sudo cp *.ko /home/arm-linux/MX6U/nfs/rootfs/lib/modules/4.1.15</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="带参数的可加载模块"><a href="#带参数的可加载模块" class="headerlink" title="带参数的可加载模块"></a>带参数的可加载模块</h2><p>向动态加载的Linux内核模块传递参数是一个非常常用且强大的功能，特别是在调试和配置驱动时。它允许你在不重新编译模块的情况下改变其行为。</p>
<p>内核提供了一组宏（定义在 <code>linux/moduleparam.h</code> 头文件中），让你在模块代码中声明参数。加载模块时，<code>insmod</code> 或 <code>modprobe</code> 命令就可以接收这些参数的值。</p>
<h3 id="在模块代码中声明参数"><a href="#在模块代码中声明参数" class="headerlink" title="在模块代码中声明参数"></a>在模块代码中声明参数</h3><p>最基本的宏是 <code>module_param</code>，其语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_param(name, type, perm);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code>：参数的<strong>名称</strong>（也是模块内部的变量名）。</li>
<li><code>type</code>：参数的<strong>数据类型</strong>。常见的有：<ul>
<li><code>bool</code>：布尔值（<code>true</code>&#x2F;<code>false</code>）</li>
<li><code>int</code>：整型</li>
<li><code>uint</code>：无符号整型</li>
<li><code>long</code>：长整型</li>
<li><code>ulong</code>：无符号长整型</li>
<li><code>charp</code>：字符指针（即字符串），内核会为它动态分配内存。</li>
<li><code>array</code>：数组（需要配合 <code>module_param_array</code> 使用）</li>
</ul>
</li>
<li><code>perm</code>：指定在 <strong><code>/sys/module/&lt;module_name&gt;/parameters/</code> 目录下对应参数文件的权限</strong>。这用于在模块加载后，通过 <code>sysfs</code> 文件系统查看或修改参数。<ul>
<li><code>S_IRUGO</code>：只读（用户、组、其他都可读）</li>
<li><code>S_IWUSR</code>： root用户可写（通常与 <code>S_IRUGO</code> 用 <code>|</code> 组合，如 <code>S_IRUGO | S_IWUSR</code>）</li>
<li><code>0</code>：完全不在 <code>sysfs</code> 中创建该参数的入口，参数只能在加载时设置。</li>
</ul>
</li>
</ul>
<h3 id="加载模块时传递参数"><a href="#加载模块时传递参数" class="headerlink" title="加载模块时传递参数"></a>加载模块时传递参数</h3><p>使用 <code>insmod</code> 或 <code>modprobe</code> 命令时，使用 <code>参数名=值</code> 的格式来传递。</p>
<ul>
<li><p><strong><code>insmod</code></strong> (需指定完整路径):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> insmod /path/to/my_module.ko param1=value1 param2=value2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>modprobe</code></strong> (在模块搜索路径中查找，更常用):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe my_module param1=value1 param2=value2</span><br></pre></td></tr></table></figure>

<p>使用 <code>modprobe</code> 前，通常需要先运行 <code>sudo depmod -a</code> 来更新模块依赖信息。</p>
</li>
</ul>
<h3 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h3><p><strong>步骤 1:</strong></p>
<p><strong>在驱动代码中 (<code>beep.c</code>) 声明参数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span> <span class="comment">// 必须包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模块参数对应的全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> debug_level = <span class="number">1</span>; <span class="comment">// 默认值</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *device_name = <span class="string">&quot;default_beep&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明参数</span></span><br><span class="line"><span class="comment">// 参数名debug_level，类型int，权限为可读可写（root）</span></span><br><span class="line">module_param(debug_level, <span class="type">int</span>, S_IRUGO | S_IWUSR);</span><br><span class="line"><span class="comment">// 参数名device_name，类型charp(字符串指针)，权限为可读可写（root）</span></span><br><span class="line">module_param(device_name, charp, S_IRUGO | S_IWUSR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用MODULE_PARM_DESC为每个参数添加描述</span></span><br><span class="line">MODULE_PARM_DESC(debug_level, <span class="string">&quot;Debug message level (0-2). Default: 1&quot;</span>);</span><br><span class="line">MODULE_PARM_DESC(device_name, <span class="string">&quot;The name of the beep device.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">beep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Beep module loaded!\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Debug level is: %d\n&quot;</span>, debug_level);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Device name is: %s\n&quot;</span>, device_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 你的初始化代码，可以使用debug_level和device_name变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">beep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Beep module unloaded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(beep_init);</span><br><span class="line">module_exit(beep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>步骤 2</strong></p>
<p><strong>编译模块并查看参数信息</strong></p>
<p>编译后，你可以使用 <code>modinfo</code> 命令查看模块的信息，其中就包括我们定义的参数及其描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo beep.ko</span><br></pre></td></tr></table></figure>

<p>输出会类似这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filename:       /.../beep.ko</span><br><span class="line">license:        GPL</span><br><span class="line">description:    </span><br><span class="line">author:         </span><br><span class="line">srcversion:     ...</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           beep</span><br><span class="line">vermagic:       ...</span><br><span class="line">parm:           debug_level:int</span><br><span class="line">parm:           device_name:charp</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>步骤 3：</strong></p>
<p><strong>加载模块并传递参数</strong></p>
<p><strong>示例 1：使用默认参数加载</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insmod beep.ko</span><br><span class="line"><span class="comment"># dmesg 输出：</span></span><br><span class="line"><span class="comment"># Beep module loaded!</span></span><br><span class="line"><span class="comment"># Debug level is: 1</span></span><br><span class="line"><span class="comment"># Device name is: default_beep</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：在加载时指定自定义参数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insmod beep.ko debug_level=2 device_name=<span class="string">&quot;my_cool_buzzer&quot;</span></span><br><span class="line"><span class="comment"># dmesg 输出：</span></span><br><span class="line"><span class="comment"># Beep module loaded!</span></span><br><span class="line"><span class="comment"># Debug level is: 2</span></span><br><span class="line"><span class="comment"># Device name is: my_cool_buzzer</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>步骤 4：</strong></p>
<p><strong>在 Sysfs 中查看和修改参数</strong></p>
<p>模块加载后，参数会出现在 <code>/sys/module/</code> 目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /sys/module/beep/parameters/</span><br><span class="line"><span class="comment"># debug_level  device_name</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /sys/module/beep/parameters/debug_level</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /sys/module/beep/parameters/device_name</span><br><span class="line"><span class="comment"># my_cool_buzzer</span></span><br></pre></td></tr></table></figure>

<p>由于我们在声明 <code>debug_level</code> 时设置了 <code>S_IWUSR</code> 权限，<strong>root 用户甚至可以在模块运行时动态修改它</strong>（如果驱动代码设计为能响应这种实时变化）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/module/beep/parameters/debug_level</span><br></pre></td></tr></table></figure>

<h3 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h3><p><code>module_param_array</code> 允许你传递一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> my_array[<span class="number">5</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> array_size;</span><br><span class="line">module_param_array(my_array, <span class="type">int</span>, &amp;array_size, S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(my_array, <span class="string">&quot;An array of integers&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载时这样传递：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> insmod my_module.ko my_array=10,20,30,40,50</span><br></pre></td></tr></table></figure>

<p>内核会自动解析逗号分隔的值，并将实际元素数量填入 <code>array_size</code> 变量中。</p>
<h2 id="模块的依赖"><a href="#模块的依赖" class="headerlink" title="模块的依赖"></a>模块的依赖</h2><p>Linux内核<strong>模块之间</strong>可以<strong>相互引用</strong>一些符号，这些符号包括函数与变量。</p>
<p><strong>特点：</strong></p>
<ul>
<li>一个模块引用其他模块的符号，称为模块依赖关系。</li>
<li><strong>被引用</strong>的模块必须<strong>先安装</strong>，引用模块才能安装。</li>
</ul>
<p>内核使用宏定义<code>EXPORT_SYMBOL</code> 导出变量与函数</p>
<ul>
<li><pre><code class="language-c">EXPORT_SYMBOL(symbol_name)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  将符号 `symbol_name` 导出到全局符号表。**所有其他模块**（无论其许可证是什么）都**可以看到并使用**这个符号。</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  EXPORT_SYMBOL_GPL(symbol_name)</span><br></pre></td></tr></table></figure>

仅将符号导出给那些**使用 GPL 兼容许可证**（如 `GPL`, `Dual MIT/GPL` 等）的模块。这是一种强制性的“开源策略”，如果你希望你的模块只被开源社区使用，而不希望闭源模块使用你的代码，就应该用这个宏。
</code></pre>
</li>
<li><pre><code class="language-c">EXPORT_SYMBOL_NS(symbol_name, namespace_name)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  将符号导出到一个特定的命名空间（namespace）。这提供了更好的符号封装和避免命名冲突的能力。只有导入了相应命名空间的模块才能看到和使用这个符号。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/****************** 符号提供者 *************************/</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/printk.h&gt;</span><br><span class="line"></span><br><span class="line">// 1. 定义一个将要被导出的函数</span><br><span class="line">void exported_function(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Hello from exported_function in Module A!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(exported_function); // 导出函数</span><br><span class="line">// 2. 定义一个将要被导出的变量</span><br><span class="line">int exported_variable = 1024;</span><br><span class="line">EXPORT_SYMBOL(exported_variable); // 导出变量</span><br><span class="line">static int __init module_a_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Module A initialized\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit module_a_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Module A exited\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(module_a_init);</span><br><span class="line">module_exit(module_a_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;KEVIN&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A module that exports symbols&quot;);</span><br><span class="line"></span><br><span class="line">/**************** 符号消费者 **********************/</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/printk.h&gt;</span><br><span class="line"></span><br><span class="line">// 声明外部符号（编译器，这个符号在其他地方定义）</span><br><span class="line">extern void exported_function(void);</span><br><span class="line">extern int exported_variable;</span><br><span class="line">static int __init module_b_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Module B initialized\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 使用从 Module A 导入的符号</span><br><span class="line">    pr_info(&quot;I&#x27;m going to call exported_function and use exported_variable\n&quot;);</span><br><span class="line">    exported_function(); // 调用外部函数</span><br><span class="line">    pr_info(&quot;The value of exported_variable is: %d\n&quot;, exported_variable); // 使用外部变量</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit module_b_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    pr_info(&quot;Module B exited\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(module_b_init);</span><br><span class="line">module_exit(module_b_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;KEVIN&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A module that uses symbols from Module A&quot;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><strong>实验步骤：</strong></p>
<ul>
<li><p><strong>错误的加载顺序（先加载依赖者）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod module_b.ko</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<p><img src="image-20250908165012796.png" alt="image-20250908165012796"></p>
<p><strong>使用 <code>dmesg</code> 查看内核日志，你会看到明确的错误信息：</strong></p>
<p><img src="image-20250908165146468.png" alt="image-20250908165146468"></p>
<p><strong>分析</strong>：加载 <code>module_b</code> 时，内核找不到 <code>exported_function</code> 和 <code>exported_variable</code> 这两个符号的定义，因为它们的提供者 <code>module_a</code> 还没有被加载。加载失败。</p>
</li>
<li><p><strong>正确的加载顺序（先加载提供者，再加载依赖者）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先加载提供符号的模块</span></span><br><span class="line"><span class="built_in">sudo</span> insmod module_a.ko</span><br><span class="line"><span class="comment"># 检查 dmesg： Module A initialized</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 再加载依赖它的模块</span></span><br><span class="line"><span class="built_in">sudo</span> insmod module_b.ko</span><br><span class="line"><span class="comment"># 检查 dmesg： </span></span><br><span class="line"><span class="comment"># Module B initialized</span></span><br><span class="line"><span class="comment"># I&#x27;m going to call exported_function and use exported_variable</span></span><br><span class="line"><span class="comment"># Hello from exported_function in Module A!</span></span><br><span class="line"><span class="comment"># The value of exported_variable is: 1024</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20250908183933683.png" alt="image-20250908183933683"></p>
<p>成功！<code>module_b</code> 找到了它所需的符号，并成功执行。</p>
</li>
<li><p><strong>查看模块依赖关系（<code>lsmod</code>）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/lib/modules/4.1.15 <span class="comment"># lsmod</span></span><br><span class="line">Module                  Size  Used by    Tainted: G</span><br><span class="line">module_b                 786  0</span><br><span class="line">module_a                1309  1 module_b</span><br></pre></td></tr></table></figure>

<p><code>Used by</code> 列清晰地显示了依赖关系：<code>module_a</code> 被 <code>module_b</code> 使用。</p>
</li>
<li><p><strong>卸载的时候要先卸载使用引用功能的模块</strong></p>
<p><img src="image-20250908184224994.png" alt="image-20250908184224994"></p>
</li>
<li><p><strong>使用 <code>modprobe</code> 自动处理依赖</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">depmod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，使用 modprobe 加载 module_b</span></span><br><span class="line"><span class="built_in">sudo</span> modprobe module_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 dmesg，你会看到：</span></span><br><span class="line"><span class="comment"># Module A initialized</span></span><br><span class="line"><span class="comment"># Module B initialized ... (所有日志)</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20250908184438338.png" alt="image-20250908184438338"></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/06/05/DRIVER-CH1-DEVICE/">https://leonardo272.github.io/2025/06/05/DRIVER-CH1-DEVICE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a></div><div class="post-share"><div class="social-share" data-image="/page_images/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/15/DRIVER-CH3-IIC/" title="驱动开发-I2C"><img class="cover" src="/page_images/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">驱动开发-I2C</div></div><div class="info-2"><div class="info-item-1">I2C原理I2c基础知识Inter Integrated Circuit 串行总线的缩写，是 PHILIPS 公司推出的芯片间串行传输总线。它以 1 根串行数据线（ SDA ）和 1 根串行时钟线（ SCL ）实现了半双工的同步数据传输。具有接口线少，控制方式简化，器件封装形式小，通信速率较高等优点。在主从通信中，可以有多个 I2C 总线器件同时接到 I2C 总线 上，通过地址来识别通信对象。IIC 接口的协议里面包括设备地址信息，可以同一总线上连接多个从设备，通过应答来互通数据及命令。但是传输速率有限，标准模式下可达到 100Kbps ，快速模式下可达到400Kbps （我们开发板一般在 130Kbps ），高速模式下达到 4Mbps ，不能实现全双工，不适合传输很多的数据。  **串行：**数据位（0和1）是一位接着一位，排成一队，在单一通道（一条线）上依次传输的。  同步：数据传输的节奏（ timing ）由一个统一的、共享的时钟信号来控制和协调。发送方和接收方都步调一致地根据这个时钟信号的跳变来发送和读取数据。  半双工：I2C只有一条数据线（SDA）。这条线要被主机和所...</div></div></div></a><a class="pagination-related" href="/2025/06/05/0001/" title="驱动开发-PWM"><img class="cover" src="/page_images/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">驱动开发-PWM</div></div><div class="info-2"><div class="info-item-1">PWM(Pulse Width Modulation)基础概念与理论1.什么是 PWM？它的主要参数是什么？ PWM (Pulse Width Modulation) 即脉冲宽度调制，是一种通过控制数字信号在一个周期内高电平时间（脉宽）与周期时间之比（占空比）来模拟连续电平的技术。  主要参数： 周期 (Period) &#x2F; 频率 (Frequency)： 一个完整 PWM 波形的持续时间 (T)。频率 f = 1 / T。 占空比 (Duty Cycle)： 高电平时间 (Ton) 占整个周期 (T) 的百分比 (D = (Ton / T) * 100%)。 极性 (Polarity)： PWM 信号有效电平（Active Level）是高电平有效 (Normal) 还是低电平有效 (Inversed)。    2.应用场景 电机控制： 调节速度和方向（如直流电机、步进电机）。 LED 调光： 控制亮度（通过改变平均电流）。 电源管理： DCDC 转换器输出电压调节（通过控制开关管导通时间）。 音频： 简单的 D 类放大器。 伺服控制： 控制舵机角度（特定脉宽范围对应特...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/05/00008/" title="驱动开发-pinctrl与gpio子系统"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">驱动开发-pinctrl与gpio子系统</div></div><div class="info-2"><div class="info-item-1">pinctrl子系统i.MX 芯片（以及很多其他 SoC）面临的一个根本问题：芯片的引脚（PAD）数量有限，但内部功能模块（如 USDHC, UART, I2C, GPIO 等）非常多。为了解决这个矛盾，芯片设计引入了 IOMUX Controller (IOMUXC)。  IOMUXC (I&#x2F;O Multiplexer Controller)： 功能：它是一个硬件控制器，允许一个物理引脚（PAD）被复用到多个内部功能模块上。 工作方式：通过寄存器配置，为每个引脚选择 up to 8 种不同的工作模式（ALT modes，即 Alternate Function 复用功能）。例如，一个引脚可以被配置为 GPIO1_IO00、UART1_TXD 或 I2C1_SDA 等功能。 额外控制：除了选择功能，IOMUXC 还控制每个引脚的电气特性，如上拉&#x2F;下拉电阻、驱动强度、转换速率等。这被称为 Pad Settings。    我们需要在设备树中设置PIN的信息，在imx6ull.dtsi文件中，找到iomuxc的节点，iomuxc 节点就是I.MX6ULL的IOMU...</div></div></div></a><a class="pagination-related" href="/2025/02/07/0003/" title="驱动开发-并发与竞争01原理"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">驱动开发-并发与竞争01原理</div></div><div class="info-2"><div class="info-item-1">竞争的概念什么是竞争Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。 Linux 系统并发产生的原因有下面几个主要原因： ①多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。 ②抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。 ③中断程序并发访问 ④SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。 &#x3D;&#x3D;所谓的临界区就是共享数据段，对于临界区必须保证一次只有一个线程访问&#x3D;&#x3D;，也就是要保证临界区是原子访问的 什么是共享资源共享资源是指在同一时间内可以被多个执行单元（如进程、线程、中断处理程序、内核任务等）访问（读取或修改） 的任何数据、数据结构、硬件设备或状态信息。  关键特性：  并发访问可能性： 多个执行单元（几乎）同时或在时间上重...</div></div></div></a><a class="pagination-related" href="/2024/11/12/0002/" title="驱动开发-基于GPIO的LED"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">驱动开发-基于GPIO的LED</div></div><div class="info-2"><div class="info-item-1">前言本次实验是基于正点原子开发板I.MX6ULL开发板来学习的 硬件原理分析本次实验我们使用的是正点原子开发板上的led灯，我们查看开发板原理图可以看到led灯连接在GPIO_3引脚上的  我们打开芯片核心原理图可以找到GPIO_3对应的是IMX6ULL芯片的GPIO1_IO03引脚  我们本次实验使用的就是I/O功能，因此我们打开arch/arm/boot/dts/imx6ul-pinfunc.h文件找到对应的宏MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  设备树编写dtbs文件：  添加pinctrl节点 在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为pinctrl_led的子节点,将 GPIO1_IO03 这个 PIN 复用为 GPIO1_IO03，电气属性值为 0X10B0。 在imx6ull-alientek-emmc.dts文件中找到&amp;iomuxc 节点，添加对应的电气属性 格式： 123456pinctrl_自定义名字: 自定义名字&#123;	fsl,pins = &lt;	引脚复用宏定义PAD（引脚）属性	引脚...</div></div></div></a><a class="pagination-related" href="/2025/06/05/0001/" title="驱动开发-PWM"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">驱动开发-PWM</div></div><div class="info-2"><div class="info-item-1">PWM(Pulse Width Modulation)基础概念与理论1.什么是 PWM？它的主要参数是什么？ PWM (Pulse Width Modulation) 即脉冲宽度调制，是一种通过控制数字信号在一个周期内高电平时间（脉宽）与周期时间之比（占空比）来模拟连续电平的技术。  主要参数： 周期 (Period) &#x2F; 频率 (Frequency)： 一个完整 PWM 波形的持续时间 (T)。频率 f = 1 / T。 占空比 (Duty Cycle)： 高电平时间 (Ton) 占整个周期 (T) 的百分比 (D = (Ton / T) * 100%)。 极性 (Polarity)： PWM 信号有效电平（Active Level）是高电平有效 (Normal) 还是低电平有效 (Inversed)。    2.应用场景 电机控制： 调节速度和方向（如直流电机、步进电机）。 LED 调光： 控制亮度（通过改变平均电流）。 电源管理： DCDC 转换器输出电压调节（通过控制开关管导通时间）。 音频： 简单的 D 类放大器。 伺服控制： 控制舵机角度（特定脉宽范围对应特...</div></div></div></a><a class="pagination-related" href="/2025/02/07/0004/" title="驱动开发-并发与竞争02原子操作"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">驱动开发-并发与竞争02原子操作</div></div><div class="info-2"><div class="info-item-1">原子操作原子操作就是指不能再进一步分割的操作，一般原子操作用于变量或者位操作。 原子操作 API 函数Linux内核定义了叫做 atomic_t 的结构体来完成用于 32 位整数的原子操作。在使用中用原子变量来代替整形变量，此结构体定义在 include/linux/types.h 文件中，定义如下： 123typedef struct &#123;	int counter;&#125; atomic_t;  用于 64 位整数的原子操作 (在支持 64 位原子操作的体系结构上)。 123typedef struct &#123;    long long counter;&#125; atomic64_t;  初始化1234567//-------编译时初始化：-----ATOMIC_INIT(int i);// 静态初始化 atomic_t 变量为 iatomic_t v ATOMIC_INIT(0);// 示例atomic64_t v64 = ATOMIC64_INIT(0); // 64位初始化宏//------运行时初始化：-------atomic_t vatomic...</div></div></div></a><a class="pagination-related" href="/2025/05/13/0009/" title="驱动开发-图形化编译内核与系统自带驱动的添加"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-13</div><div class="info-item-2">驱动开发-图形化编译内核与系统自带驱动的添加</div></div><div class="info-2"><div class="info-item-1">1.配置linux自带的驱动使能1.1图形化配置要使用 Linux内核自带的 LED灯驱动首先得先配置 Linux，输入如下命令打开 Linux配置菜单： 1make menuconfig  按照如下路径打开 LED驱动配置项：  按照上述路径，选择“ LED Support for GPIO connected LEDs”，将其编译进 Linux内核，也即是在此选项上按下“ Y”键，使此选项前面变为 “&lt;*&gt;”：   在“ LED Support for GPIO connected LEDs”上按下 可以打开此选项的帮助信息，   1make -j16    1.2.config文件查看配置 好 Linux内核以后退出配置界面，打开 .config文件，会找到“ CONFIG_LEDS_GPIO&#x3D;y这一行，如图 56.1.3所示：  1.3Makefile文件LED灯驱动文件为 /drivers/leds/leds-gpio.c，大家可以打开 /drivers/leds/Makefile这个文件，  如果定义了 CONFIG_LEDS_GPIO的话就会编...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">LINUX设备驱动模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">驱动程序的加载方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">内核模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">实验一</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">动态加载与卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-number">1.2.</span> <span class="toc-text">模块的编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">模块的加载与卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%AF%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.</span> <span class="toc-text">带参数的可加载模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">在模块代码中声明参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%97%B6%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">加载模块时传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">具体示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">传递数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.4.</span> <span class="toc-text">模块的依赖</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高危工作环境中人员安全装备佩戴检测系统"/></a><div class="content"><a class="title" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统">高危工作环境中人员安全装备佩戴检测系统</a><time datetime="2025-07-20T14:33:00.000Z" title="发表于 2025-07-20 22:33:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-SPI"/></a><div class="content"><a class="title" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI">驱动开发-SPI</a><time datetime="2025-06-20T13:12:00.000Z" title="发表于 2025-06-20 21:12:00">2025-06-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>