<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>驱动开发-SPI | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SPI原理SPI（Serial Peripheral Interface）是一种高速、全双工、同步的串行通信协议。它广泛用于连接微控制器与外部设备，如传感器、存储器等。 SPI特点   特性维度 SPI (Serial Peripheral Interface)    信号线数量 至少4根线：MOSI（主出从入）、MISO（主入从出）、SCLK（时钟）、CS（片选，每个从机独享一根）   拓扑结构">
<meta property="og:type" content="article">
<meta property="og:title" content="驱动开发-SPI">
<meta property="og:url" content="https://leonardo272.github.io/2025/06/20/DRIVER-CH4-SPI/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="SPI原理SPI（Serial Peripheral Interface）是一种高速、全双工、同步的串行通信协议。它广泛用于连接微控制器与外部设备，如传感器、存储器等。 SPI特点   特性维度 SPI (Serial Peripheral Interface)    信号线数量 至少4根线：MOSI（主出从入）、MISO（主入从出）、SCLK（时钟）、CS（片选，每个从机独享一根）   拓扑结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/2.jpg">
<meta property="article:published_time" content="2025-06-20T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-14T14:09:35.527Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/2.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "驱动开发-SPI",
  "url": "https://leonardo272.github.io/2025/06/20/DRIVER-CH4-SPI/",
  "image": "https://leonardo272.github.io/page_images/2.jpg",
  "datePublished": "2025-06-20T13:12:00.000Z",
  "dateModified": "2025-09-14T14:09:35.527Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/06/20/DRIVER-CH4-SPI/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '驱动开发-SPI',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">驱动开发-SPI</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">驱动开发-SPI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-20T13:12:00.000Z" title="发表于 2025-06-20 21:12:00">2025-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-14T14:09:35.527Z" title="更新于 2025-09-14 22:09:35">2025-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/">驱动学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="SPI原理"><a href="#SPI原理" class="headerlink" title="SPI原理"></a>SPI原理</h1><p>SPI（Serial Peripheral Interface）是一种<strong>高速</strong>、<strong>全双工</strong>、<strong>同步</strong>的串行通信协议。它广泛用于连接微控制器与外部设备，如传感器、存储器等。</p>
<h2 id="SPI特点"><a href="#SPI特点" class="headerlink" title="SPI特点"></a>SPI特点</h2><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th>SPI (Serial Peripheral Interface)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>信号线数量</strong></td>
<td><strong>至少4根线</strong>：MOSI（主出从入）、MISO（主入从出）、SCLK（时钟）、CS（片选，每个从机独享一根）</td>
</tr>
<tr>
<td align="left"><strong>拓扑结构</strong></td>
<td><strong>点对点型</strong>：主设备与每个从设备都有独立的片选线连接。</td>
</tr>
<tr>
<td align="left"><strong>通信模式</strong></td>
<td><strong>全双工</strong>：发送和接收可以同时进行。</td>
</tr>
<tr>
<td align="left"><strong>数据传输</strong></td>
<td><strong>无应答机制</strong>：主设备产生时钟，从设备被动跟随，无法确认数据是否被成功接收。</td>
</tr>
<tr>
<td align="left"><strong>速度</strong></td>
<td><strong>速度非常高</strong>（通常50Mbps以上），几乎只受限于硬件性能。</td>
</tr>
<tr>
<td align="left"><strong>软件复杂度</strong></td>
<td><strong>软件简单</strong>：本质上是简单的移位寄存器，主要靠硬件实现。</td>
</tr>
<tr>
<td align="left"><strong>硬件复杂度</strong></td>
<td><strong>硬件复杂</strong>：线多，尤其是从设备多时，需要大量片选线，占用大量IO口。</td>
</tr>
<tr>
<td align="left"><strong>主要应用场景</strong></td>
<td><strong>高速器件</strong>（如我的项目中的ICM20608陀螺仪）、<strong>Flash存储器</strong>、<strong>显示屏</strong>、<strong>ADC&#x2F;DAC</strong>等。</td>
</tr>
<tr>
<td align="left"><strong>四种工作模式</strong></td>
<td>通过串行<strong>时钟极性</strong>(CPOL)和**相位(**CPHA)的搭配来得到四种工作模式</td>
</tr>
</tbody></table>
<img src="image-20250914162853670.png" alt="image-20250914162853670" style="zoom: 50%;">

<p>SPI通信通常需要4根基础信号线：</p>
<ul>
<li><strong>SCLK</strong>（Serial Clock）：<strong>时钟信号</strong>，由主设备产生，用于同步数据交换。</li>
<li><strong>MOSI</strong>（Master Out Slave In）：<strong>主设备数据输出</strong>，从设备数据输入。</li>
<li><strong>MISO</strong>（Master In Slave Out）：<strong>主设备数据输入</strong>，从设备数据输出。</li>
<li><strong>CS&#x2F;SS</strong>（Chip Select&#x2F;Slave Select）：<strong>片选信号</strong>，由主设备控制，低电平有效，用于选择特定从设备。</li>
</ul>
<h2 id="SPI通信流程"><a href="#SPI通信流程" class="headerlink" title="SPI通信流程"></a>SPI通信流程</h2><p>一次基本的SPI通信流程通常遵循以下步骤：</p>
<ol>
<li>主设备将目标从设备的<strong>CS线拉低</strong>（激活）。</li>
<li>主设备产生<strong>时钟信号SCLK</strong>。</li>
<li>数据在<strong>SCLK的每个时钟周期</strong>内通过MOSI和MISO线同时传输（全双工）。</li>
<li>数据传输完成后，主设备<strong>停止时钟</strong>并将<strong>CS线拉高</strong>（释放）。</li>
</ol>
<p>数据的传输：</p>
<ol>
<li>数据传输是基于移位寄存器的</li>
<li>主设备和从设备各有一个8位移位寄存器</li>
<li>每个时钟周期，两个寄存器同时移位一位</li>
<li>8个时钟周期后，主从设备完成一个字节的交换</li>
<li>通常MSB（最高有效位）先传输，但也有LSB先传输的设备</li>
</ol>
<h2 id="SPI工作模式"><a href="#SPI工作模式" class="headerlink" title="SPI工作模式"></a>SPI工作模式</h2><p>SPI有4种工作模式，由<strong>时钟极性（CPOL）</strong> 和<strong>时钟相位（CPHA）</strong> 两个参数组合决定</p>
<ol>
<li><strong>CPOL (时钟极性) - 决定时钟空闲状态</strong><ul>
<li><code>CPOL = 0</code>：时钟信号 <strong>SCLK</strong> 在空闲状态时为<strong>低电平</strong>。</li>
<li><code>CPOL = 1</code>：时钟信号 <strong>SCLK</strong> 在空闲状态时为<strong>高电平</strong>。</li>
</ul>
</li>
<li><strong>CPHA (时钟相位) - 决定数据采样时刻</strong><ul>
<li><code>CPHA = 0</code>：数据在<strong>第一个时钟边沿</strong>（即从<strong>空闲状态跳变到有效状态</strong>的第一个边沿）被<strong>采样（读取）</strong>。数据必须在时钟边沿到来之前就保持稳定。</li>
<li><code>CPHA = 1</code>：数据在<strong>第二个时钟边沿</strong>（即<strong>返回到空闲</strong>状态的边沿）被<strong>采样（读取）</strong>。数据可以在第一个边沿时发生变化。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">CPOL</th>
<th align="left">CPHA</th>
<th align="left">时钟空闲状态</th>
<th align="left">数据采样时刻</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">低电平</td>
<td align="left"><strong>第一个边沿</strong>（上升沿）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">低电平</td>
<td align="left"><strong>第二个边沿</strong>（下降沿）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">高电平</td>
<td align="left"><strong>第一个边沿</strong>（下降沿）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">高电平</td>
<td align="left"><strong>第二个边沿</strong>（上升沿）</td>
</tr>
</tbody></table>
<ul>
<li>根据从设备的要求选择，不同设备可能支持不同的模式</li>
<li>查阅从设备的数据手册，确定其支持的SPI模式</li>
</ul>
<h1 id="SPI驱动开发"><a href="#SPI驱动开发" class="headerlink" title="SPI驱动开发"></a>SPI驱动开发</h1><h2 id="SPI控制器"><a href="#SPI控制器" class="headerlink" title="SPI控制器"></a>SPI控制器</h2><p>Linux中使用<code>spi_master</code>结构体描述SPI控制器，里面最重要的成员就是<code>transfer</code>函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* other than negative (== assign one dynamically), bus_num is fully</span></span><br><span class="line"><span class="comment">	 * board-specific.  usually that simplifies to being SOC-specific.</span></span><br><span class="line"><span class="comment">	 * example:  one SOC has three SPI controllers, numbered 0..2,</span></span><br><span class="line"><span class="comment">	 * and one board&#x27;s schematics might show it using SPI-2.  software</span></span><br><span class="line"><span class="comment">	 * would normally use bus_num=2 for that controller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s16			bus_num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chipselects will be integral to many controllers; some others</span></span><br><span class="line"><span class="comment">	 * might use board-specific GPIOs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u16			num_chipselect;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* some SPI controllers pose alignment requirements on DMAable</span></span><br><span class="line"><span class="comment">	 * buffers; let protocol drivers know about these requirements.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u16			dma_alignment;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* spi_device.mode flags understood by this controller driver */</span></span><br><span class="line">	u16			mode_bits;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bitmask of supported bits_per_word for transfers */</span></span><br><span class="line">	u32			bits_per_word_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BPW_MASK(bits) BIT((bits) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BIT_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* limits on transfer speed */</span></span><br><span class="line">	u32			min_speed_hz;</span><br><span class="line">	u32			max_speed_hz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* other constraints relevant to this driver */</span></span><br><span class="line">	u16			flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_HALF_DUPLEX	BIT(0)		<span class="comment">/* can&#x27;t do full duplex */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_NO_RX	BIT(1)		<span class="comment">/* can&#x27;t do buffer read */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_NO_TX	BIT(2)		<span class="comment">/* can&#x27;t do buffer write */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_MUST_RX      BIT(3)		<span class="comment">/* requires rx */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MASTER_MUST_TX      BIT(4)		<span class="comment">/* requires tx */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lock and mutex for SPI bus locking */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		bus_lock_spinlock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">bus_lock_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* flag indicating that the SPI bus is locked for exclusive use */</span></span><br><span class="line">	<span class="type">bool</span>			bus_lock_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup mode and clock, etc (spi driver may call many times).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * IMPORTANT:  this may be called when transfers to another</span></span><br><span class="line"><span class="comment">	 * device are active.  DO NOT UPDATE SHARED REGISTERS in ways</span></span><br><span class="line"><span class="comment">	 * which could break those transfers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			(*setup)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bidirectional bulk transfers</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * + The transfer() method may not sleep; its main role is</span></span><br><span class="line"><span class="comment">	 *   just to add the message to the queue.</span></span><br><span class="line"><span class="comment">	 * + For now there&#x27;s no remove-from-queue operation, or</span></span><br><span class="line"><span class="comment">	 *   any other request management</span></span><br><span class="line"><span class="comment">	 * + To a given spi_device, message queueing is pure fifo</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * + The master&#x27;s main job is to process its message queue,</span></span><br><span class="line"><span class="comment">	 *   selecting a chip then transferring data</span></span><br><span class="line"><span class="comment">	 * + If there are multiple spi_device children, the i/o queue</span></span><br><span class="line"><span class="comment">	 *   arbitration algorithm is unspecified (round robin, fifo,</span></span><br><span class="line"><span class="comment">	 *   priority, reservations, preemption, etc)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * + Chipselect stays active during the entire message</span></span><br><span class="line"><span class="comment">	 *   (unless modified by spi_transfer.cs_change != 0).</span></span><br><span class="line"><span class="comment">	 * + The message transfers use clock and SPI mode parameters</span></span><br><span class="line"><span class="comment">	 *   previously established by setup() for this device</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			(*transfer)(<span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">						<span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* called on release() to free memory provided by spi_master */</span></span><br><span class="line">	<span class="type">void</span>			(*cleanup)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Used to enable core support for DMA handling, if can_dma()</span></span><br><span class="line"><span class="comment">	 * exists and returns true then the transfer will be mapped</span></span><br><span class="line"><span class="comment">	 * prior to transfer_one() being called.  The driver should</span></span><br><span class="line"><span class="comment">	 * not modify or store xfer and dma_tx and dma_rx must be set</span></span><br><span class="line"><span class="comment">	 * while the device is prepared.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span>			(*can_dma)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">					   <span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">					   <span class="keyword">struct</span> spi_transfer *xfer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These hooks are for drivers that want to use the generic</span></span><br><span class="line"><span class="comment">	 * master transfer queueing mechanism. If these are used, the</span></span><br><span class="line"><span class="comment">	 * transfer() function above must NOT be specified by the driver.</span></span><br><span class="line"><span class="comment">	 * Over time we expect SPI drivers to be phased over to this API.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span>				queued;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread_worker</span>		<span class="title">kworker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">kworker_task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kthread_work</span>		<span class="title">pump_messages</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span>			queue_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">queue</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>		*<span class="title">cur_msg</span>;</span></span><br><span class="line">	<span class="type">bool</span>				idling;</span><br><span class="line">	<span class="type">bool</span>				busy;</span><br><span class="line">	<span class="type">bool</span>				running;</span><br><span class="line">	<span class="type">bool</span>				rt;</span><br><span class="line">	<span class="type">bool</span>				auto_runtime_pm;</span><br><span class="line">	<span class="type">bool</span>                            cur_msg_prepared;</span><br><span class="line">	<span class="type">bool</span>				cur_msg_mapped;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>               <span class="title">xfer_completion</span>;</span></span><br><span class="line">	<span class="type">size_t</span>				max_dma_len;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*prepare_transfer_hardware)(<span class="keyword">struct</span> spi_master *master);</span><br><span class="line">	<span class="type">int</span> (*transfer_one_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">				    <span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line">	<span class="type">int</span> (*unprepare_transfer_hardware)(<span class="keyword">struct</span> spi_master *master);</span><br><span class="line">	<span class="type">int</span> (*prepare_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">			       <span class="keyword">struct</span> spi_message *message);</span><br><span class="line">	<span class="type">int</span> (*unprepare_message)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">				 <span class="keyword">struct</span> spi_message *message);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These hooks are for drivers that use a generic implementation</span></span><br><span class="line"><span class="comment">	 * of transfer_one_message() provied by the core.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*set_cs)(<span class="keyword">struct</span> spi_device *spi, <span class="type">bool</span> enable);</span><br><span class="line">	<span class="type">int</span> (*transfer_one)(<span class="keyword">struct</span> spi_master *master, <span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">			    <span class="keyword">struct</span> spi_transfer *transfer);</span><br><span class="line">	<span class="type">void</span> (*handle_err)(<span class="keyword">struct</span> spi_master *master,</span><br><span class="line">			   <span class="keyword">struct</span> spi_message *message);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gpio chip select */</span></span><br><span class="line">	<span class="type">int</span>			*cs_gpios;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DMA channels for use with core dmaengine helpers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>		*<span class="title">dma_tx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>		*<span class="title">dma_rx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dummy data for full duplex devices */</span></span><br><span class="line">	<span class="type">void</span>			*dummy_rx;</span><br><span class="line">	<span class="type">void</span>			*dummy_tx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>transfer</code>函数，和<code>i2c_algorithm</code>中的<code>master_xfer</code>函数一样，控制器数据传输函数。</p>
</li>
<li><p>SPI主机端最终会通过transfer函数与SPI设备进行通信，因此对于SPI主机控制器的驱动编写者而言transfer函数是需要实现的</p>
</li>
</ul>
<p><strong>SPI的主机驱动的工作</strong></p>
<p>申请spi_master，然后初始化spi_master，最后向Linux内核注册spi_master。</p>
<ul>
<li><p><strong>申请与释放</strong></p>
<ul>
<li><pre><code class="language-c">struct spi_master *spi_alloc_master(struct device *dev,unsigned size)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **dev：**设备，一般是platform_device中的dev成员变量。</span><br><span class="line">  **size：**私有数据大小，可以通过spi_master_get_devdata函数获取到这些私有数据。</span><br><span class="line">  **返回值：**申请到的spi_master。</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  void spi_master_put(struct spi_master *master)</span><br></pre></td></tr></table></figure>

**master：**要释放的spi_master。
**返回值：**无。
</code></pre>
</li>
</ul>
</li>
<li><p><strong>注册与注销</strong></p>
<ul>
<li><pre><code class="language-c">int spi_register_master(struct spi_master *master)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **master：**要注册的spi_master。</span><br><span class="line">  **返回值：**0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  void spi_unregister_master(struct spi_master *master)</span><br></pre></td></tr></table></figure>

**master：**要注销的spi_master。
**返回值：**无。
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="SPI设备"><a href="#SPI设备" class="headerlink" title="SPI设备"></a>SPI设备</h2><p>struct <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/spi_device">spi_device</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">controller</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">master</span>;</span>	<span class="comment">/* compatibility layer */</span></span><br><span class="line">	u32			max_speed_hz;</span><br><span class="line">	u8			chip_select;</span><br><span class="line">	u8			bits_per_word;</span><br><span class="line">	<span class="type">bool</span>			rt;</span><br><span class="line">	u32			mode;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPHA	0x01			<span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPOL	0x02			<span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_0	(0|0)			<span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_1	(0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_2	(SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_HIGH	0x04			<span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LSB_FIRST	0x08			<span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE	0x10			<span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LOOP	0x20			<span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NO_CS	0x40			<span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_READY	0x80			<span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_DUAL	0x100			<span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_QUAD	0x200			<span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_DUAL	0x400			<span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_QUAD	0x800			<span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_WORD	0x1000			<span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_OCTAL	0x2000			<span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_OCTAL	0x4000			<span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE_HIZ	0x8000			<span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line">	<span class="type">int</span>			irq;</span><br><span class="line">	<span class="type">void</span>			*controller_state;</span><br><span class="line">	<span class="type">void</span>			*controller_data;</span><br><span class="line">	<span class="type">char</span>			modalias[SPI_NAME_SIZE];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*driver_override;</span><br><span class="line">	<span class="type">int</span>			cs_gpio;	<span class="comment">/* LEGACY: chip select gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">cs_gpiod</span>;</span>	<span class="comment">/* chip select gpio desc */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span> <span class="comment">/* inter-word delay */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the statistics */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_statistics</span>	<span class="title">statistics</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * likely need more hooks for more protocol options affecting how</span></span><br><span class="line"><span class="comment">	 * the controller talks to each chip, like:</span></span><br><span class="line"><span class="comment">	 *  - memory packing (12 bit samples into low bits, others zeroed)</span></span><br><span class="line"><span class="comment">	 *  - priority</span></span><br><span class="line"><span class="comment">	 *  - chipselect delays</span></span><br><span class="line"><span class="comment">	 *  - ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数名 (Parameter Name)</th>
<th align="left">说明 (Description)</th>
<th align="left">备注 (Notes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>max_speed_hz</strong></td>
<td align="left">该设备能支持的 <strong>SPI 时钟频率最大值</strong>。</td>
<td align="left">主设备必须配置为不超过此值的频率。</td>
</tr>
<tr>
<td align="left"><strong>chip_select</strong></td>
<td align="left">该设备在其 <strong>SPI 主机控制器（spi_master）下的片选索引号</strong>。</td>
<td align="left">此索引号用于从主控制的 <code>cs_gpios[]</code> 数组中获取具体的GPIO引脚号：<code>cs_gpio = cs_gpios[spi_device.chip_select]</code></td>
</tr>
<tr>
<td align="left"><strong>cs_gpio</strong></td>
<td align="left"><strong>(可选)</strong> 直接指定该设备片选引脚所使用的 <strong>GPIO 编号</strong>。</td>
<td align="left">如果提供，通常会优先使用此值而非通过 <code>chip_select</code> 索引查找。</td>
</tr>
<tr>
<td align="left"><strong>bits_per_word</strong></td>
<td align="left"><strong>每个基本的 SPI 传输单元包含的位数</strong>。</td>
<td align="left">默认通常是8位。可以设置为其他值（如16位），并且<strong>可以大于32位</strong>，以支持DMA进行大批量连续传输。</td>
</tr>
</tbody></table>
<p><code>mode</code> 参数是一个位掩码，用于设置SPI通信的各种模式和行为。以下是其支持的标志：</p>
<table>
<thead>
<tr>
<th align="left">模式标志 (Mode Flag)</th>
<th align="left">含义 (Meaning)</th>
<th align="left">备注 (Notes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPI_CPOL</strong></td>
<td align="left"><strong>时钟极性 (Clock Polarity)</strong>。设置时钟信号在空闲时的状态。</td>
<td align="left"><ul><li><strong>0</strong>: 空闲时 SCK 为低电平。</li><li><strong>1</strong>: 空闲时 SCK 为高电平。</li></ul></td>
</tr>
<tr>
<td align="left"><strong>SPI_CPHA</strong></td>
<td align="left"><strong>时钟相位 (Clock Phase)</strong>。设置数据采样的时刻。</td>
<td align="left"><ul><li><strong>0</strong>: 在时钟的第一个边沿（从空闲状态跳变后的边沿）采样。</li><li><strong>1</strong>: 在时钟的第二个边沿采样。</li></ul></td>
</tr>
<tr>
<td align="left"><strong>SPI_MODE_0</strong></td>
<td align="left"><strong>模式 0</strong>。</td>
<td align="left"><code>SPI_CPOL = 0</code>, <code>SPI_CPHA = 0</code></td>
</tr>
<tr>
<td align="left"><strong>SPI_MODE_1</strong></td>
<td align="left"><strong>模式 1</strong>。</td>
<td align="left"><code>SPI_CPOL = 0</code>, <code>SPI_CPHA = 1</code></td>
</tr>
<tr>
<td align="left"><strong>SPI_MODE_2</strong></td>
<td align="left"><strong>模式 2</strong>。</td>
<td align="left"><code>SPI_CPOL = 1</code>, <code>SPI_CPHA = 0</code></td>
</tr>
<tr>
<td align="left"><strong>SPI_MODE_3</strong></td>
<td align="left"><strong>模式 3</strong>。</td>
<td align="left"><code>SPI_CPOL = 1</code>, <code>SPI_CPHA = 1</code></td>
</tr>
<tr>
<td align="left"><strong>SPI_CS_HIGH</strong></td>
<td align="left"><strong>片选信号高有效</strong>。</td>
<td align="left">通常片选是低电平有效（CS引脚拉低表示选中）。设置此标志则表示片选为<strong>高电平有效</strong>。</td>
</tr>
<tr>
<td align="left"><strong>SPI_LSB_FIRST</strong></td>
<td align="left"><strong>数据传输从最低位 (LSB) 开始</strong>。</td>
<td align="left">标准SPI协议通常先传输最高位（MSB）。<strong>注意：很多SPI控制器硬件不支持此模式。</strong></td>
</tr>
<tr>
<td align="left"><strong>SPI_3WIRE</strong></td>
<td align="left"><strong>使用 3线制（半双工）</strong>。</td>
<td align="left">输入（MISO）和输出（MOSI）数据线合并为一条（SISO）。</td>
</tr>
<tr>
<td align="left"><strong>SPI_LOOP</strong></td>
<td align="left"><strong>回环测试模式</strong>。</td>
<td align="left">控制器内部将输出（MOSI）与输入（MISO）短接，用于自检。</td>
</tr>
<tr>
<td align="left"><strong>SPI_NO_CS</strong></td>
<td align="left"><strong>不使用片选信号</strong>。</td>
<td align="left">适用于总线上只有一个从设备的情况，无需片选操作。</td>
</tr>
<tr>
<td align="left"><strong>SPI_READY</strong></td>
<td align="left"><strong>支持从设备就绪信号</strong>。</td>
<td align="left">从设备可以通过拉低某条信号线来通知主设备自己“未就绪”，主设备应等待。</td>
</tr>
<tr>
<td align="left"><strong>SPI_TX_DUAL</strong></td>
<td align="left"><strong>发送时使用 2 条数据线</strong>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>SPI_TX_QUAD</strong></td>
<td align="left"><strong>发送时使用 4 条数据线</strong>。</td>
<td align="left">这些是SPI的扩展模式（Dual&#x2F;Quad SPI），常用于高速SPI Flash等器件，以提升数据传输带宽。</td>
</tr>
<tr>
<td align="left"><strong>SPI_RX_DUAL</strong></td>
<td align="left"><strong>接收时使用 2 条数据线</strong>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>SPI_RX_QUAD</strong></td>
<td align="left"><strong>接收时使用 4 条数据线</strong>。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="SPI设备树"><a href="#SPI设备树" class="headerlink" title="SPI设备树"></a>SPI设备树</h2><ul>
<li><p><strong>SPI Master</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ecspi1: ecspi@<span class="number">02008000</span> &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">31</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI1&gt;,</span><br><span class="line">		 &lt;&amp;clks IMX6UL_CLK_ECSPI1&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	dmas = &lt;&amp;sdma <span class="number">3</span> <span class="number">7</span> <span class="number">1</span>&gt;, &lt;&amp;sdma <span class="number">4</span> <span class="number">7</span> <span class="number">2</span>&gt;;</span><br><span class="line">	dma-names = <span class="string">&quot;rx&quot;</span>, <span class="string">&quot;tx&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在设备树中，对于SPI Master，<strong>必须的属性</strong>如下：</p>
<ul>
<li><strong>#address-cells</strong>：这个SPI Master下的SPI设备，需要多少个cell来表述它的片选引脚</li>
<li><strong>#size-cells</strong>：必须设置为0</li>
<li><strong>compatible</strong>：根据它找到SPI Master驱动</li>
</ul>
<p><strong>可选的属性</strong>如下：</p>
<ul>
<li><strong>cs-gpios</strong>：SPI Master可以使用多个GPIO当做片选，可以在这个属性列出那些GPIO</li>
<li><strong>num-cs</strong>：片选引脚总数</li>
</ul>
</li>
<li><p><strong>SPI Device</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">	fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;				<span class="comment">/* 1个片选 */</span></span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;		<span class="comment">/* 片选引脚，软件片选！ */</span></span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对应的SPI芯片子节点 */</span></span><br><span class="line">	spidev0: icm20608@<span class="number">0</span> &#123;			<span class="comment">/* @后面的0表示次SPI芯片接到哪个硬件片选上 */</span></span><br><span class="line">		reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		compatible = <span class="string">&quot;kevin,icm20608&quot;</span>;</span><br><span class="line">		spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;	<span class="comment">/*  SPI时钟频率8MHz*/</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在SPI Master对应的设备树节点下，每一个子节点都对应一个SPI设备，这个SPI设备连接在该SPI Master下面。</p>
<p>这些子节点中，必选的属性如下：</p>
<ul>
<li>**compatible：**根据它找到SPI Device驱动</li>
<li>**reg：**用来表示它使用哪个片选引脚</li>
<li>**spi-max-frequency：**必选，该SPI设备支持的最大SPI时钟</li>
</ul>
<p>可选的属性如下：</p>
<ul>
<li>**spi-cpol：**这是一个空属性(没有值)，表示CPOL为1，即平时SPI时钟为低电平</li>
<li>**spi-cpha：**这是一个空属性(没有值)，表示CPHA为1)，即在时钟的第2个边沿采样数据</li>
<li>**spi-cs-high：**这是一个空属性(没有值)，表示片选引脚高电平有效</li>
<li>**spi-3wire：**这是一个空属性(没有值)，表示使用SPI 三线模式</li>
</ul>
</li>
</ul>
<h2 id="SPI设备驱动"><a href="#SPI设备驱动" class="headerlink" title="SPI设备驱动"></a>SPI设备驱动</h2><p>struct <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/spi_driver">spi_driver</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*probe)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">int</span>			(*remove)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">void</span>			(*shutdown)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span>	<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>spi_driver 和i2c_driver、platform_driver 基本一样，当SPI设备和驱动匹配成功以后probe 函数就会执行。</p>
<ul>
<li><p><strong>spi_driver 注册函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_driver</span><span class="params">(<span class="keyword">struct</span> spi_driver *sdrv)</span></span><br></pre></td></tr></table></figure>

<p>**sdrv：**要注册的spi_driver。<br>**返回值：**0，注册成功；赋值，注册失败。</p>
</li>
<li><p><strong>spi_driver 注销函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_unregister_driver</span><span class="params">(<span class="keyword">struct</span> spi_driver *sdrv)</span></span><br></pre></td></tr></table></figure>

<p>**sdrv：**要注销的spi_driver。</p>
<p>**返回值：**无。</p>
</li>
</ul>
<h2 id="SPI设备与驱动匹配"><a href="#SPI设备与驱动匹配" class="headerlink" title="SPI设备与驱动匹配"></a>SPI设备与驱动匹配</h2><p>SPI设备和驱动的匹配过程是由SPI总线来完成的，SPI总线为<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/spi_bus_type">spi_bus_type</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">spi_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;spi&quot;</span>,</span><br><span class="line">	.dev_groups	= spi_dev_groups,</span><br><span class="line">	.match		= spi_match_device,</span><br><span class="line">	.uevent		= spi_uevent,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配的函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_match_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>	*<span class="title">sdrv</span> =</span> to_spi_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check override first, and if set, only use the named driver */</span></span><br><span class="line">	<span class="keyword">if</span> (spi-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;driver_override, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spi_match_device 函数和i2c_match_device 函数对于设备和驱动的匹配过程基本一样</p>
<ul>
<li><code>of_driver_match_device</code> 函数用于完成<strong>设备树</strong>设备和驱动匹配。比较SPI设备节点的compatible 属性和of_device_id 中的compatible 属性是否相等，如果相当的话就表示SPI设备和驱动匹配。</li>
<li><code>spi_match_id</code>函数用于传统的、<strong>无设备树</strong>的SPI 设备和驱动匹配过程。比较SPI设备名字和spi_device_id 的name 字段是否相等，相等的话就说明SPI 设备和驱动匹配。</li>
</ul>
<h2 id="SPI控制器驱动"><a href="#SPI控制器驱动" class="headerlink" title="SPI控制器驱动"></a>SPI控制器驱动</h2><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/spi/spi-imx.c">spi-imx.c</a>该驱动作为所有SPI设备驱动的基础，<strong>负责处理SPI总线的底层通信</strong>。SPI核心驱动提供了统一的接口，使得不同的SPI设备驱动可以方便地接入。</p>
<table>
<thead>
<tr>
<th align="left">工作类别</th>
<th align="left">具体描述</th>
<th align="left">关键函数&#x2F;操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>驱动初始化</strong></td>
<td align="left">向内核注册平台驱动，并在匹配到设备时执行探测函数。</td>
<td align="left"><code>platform_driver_register</code>, <code>spi_imx_probe</code></td>
</tr>
<tr>
<td align="left"><strong>主机控制器注册</strong></td>
<td align="left">申请并设置 <code>spi_master</code> 结构体，包括片选数量、模式支持、回调函数等。</td>
<td align="left"><code>spi_alloc_master</code>, 设置 <code>master-&gt;bits_per_word_mask</code>, <code>master-&gt;num_chipselect</code>, <code>master-&gt;mode_bits</code> 等</td>
</tr>
<tr>
<td align="left"><strong>硬件资源申请</strong></td>
<td align="left">获取并映射 IO 内存空间、申请中断、配置 GPIO 片选引脚、使能时钟。</td>
<td align="left"><code>platform_get_resource</code>, <code>devm_ioremap_resource</code>, <code>platform_get_irq</code>, <code>devm_request_irq</code>, <code>of_get_named_gpio</code></td>
</tr>
<tr>
<td align="left"><strong>回调函数设置</strong></td>
<td align="left">实现并设置一系列操作 SPI 控制器的回调函数，用于配置、数据传输等。</td>
<td align="left"><code>spi_imx_setup</code>, <code>spi_imx_transfer</code>, <code>spi_imx_prepare_message</code> 等</td>
</tr>
<tr>
<td align="left"><strong>传输队列管理</strong></td>
<td align="left">启动传输队列，处理上层提交的 SPI 消息。</td>
<td align="left"><code>spi_bitbang_start</code></td>
</tr>
</tbody></table>
<p>SPI主机驱动器采用了platfom 驱动框架。当设备和驱动匹配成功以后spi_imx_probe 函数就会执行。</p>
<h2 id="SPI设备数据收发处理流程"><a href="#SPI设备数据收发处理流程" class="headerlink" title="SPI设备数据收发处理流程"></a>SPI设备数据收发处理流程</h2><ol>
<li><strong>设 Transfer</strong>：初始化一个<code>spi_transfer</code>结构体，填入<strong>发送缓冲区</strong>（<code>tx_buf</code>）、<strong>接收缓冲区</strong>（<code>rx_buf</code>）和<strong>传输长度</strong>（<code>len</code>）。</li>
<li><strong>初始 Message</strong>：使用<code>spi_message_init()</code>初始化一个<code>spi_message</code>。</li>
<li><strong>挂载 Transfer</strong>：使用<code>spi_message_add_tail()</code>将设置好的<code>spi_transfer</code>添加到<code>spi_message</code>的队列中。</li>
<li><strong>同步传输</strong>：调用<code>spi_sync()</code>函数。此函数会<strong>阻塞</strong>直到整个传输完成，此时数据已存在于<code>rx_buf</code>中。</li>
</ol>
<p><strong><code>transfer</code>是单元，<code>message</code>是序列</strong>：<code>transfer</code>描述“做什么”（发什么，收什么），<code>message</code>描述“做的顺序和时机”（一系列动作在一个片选周期内完成）。</p>
<ul>
<li><p>struct <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/spi_transfer">spi_transfer</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">	<span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment">	 * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment">	 * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment">	 *   spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span>	*tx_buf;</span><br><span class="line">	<span class="type">void</span>		*rx_buf;</span><br><span class="line">	<span class="type">unsigned</span>	len;</span><br><span class="line"></span><br><span class="line">	<span class="type">dma_addr_t</span>	tx_dma;</span><br><span class="line">	<span class="type">dma_addr_t</span>	rx_dma;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span>	cs_change:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	tx_nbits:<span class="number">3</span>;</span><br><span class="line">	<span class="type">unsigned</span>	rx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_SINGLE	0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_DUAL		0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NBITS_QUAD		0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line">	u8		bits_per_word;</span><br><span class="line">	u16		delay_usecs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">delay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">cs_change_delay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span></span><br><span class="line">	u32		speed_hz;</span><br><span class="line"></span><br><span class="line">	u32		effective_speed_hz;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	ptp_sts_word_pre;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	ptp_sts_word_post;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ptp_system_timestamp</span> *<span class="title">ptp_sts</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>		timestamped;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TRANS_FAIL_NO_START	BIT(0)</span></span><br><span class="line">	u16		error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>tx_buf</strong>：保存着要发送的数据。</li>
<li><strong>rx_buf</strong>：用于保存接收到的数据。</li>
<li><strong>len</strong>：是要进行传输的数据长度，SPI是全双工通信，因此在<strong>一次通信中发送和接收的字节数都是一样的</strong>，所以spi_transfer中也就没有发送长度和接收长度之分。</li>
</ul>
</li>
<li><p>struct <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/spi_message">spi_message</a></p>
<p>spi_transfer 需要组织成spi_message</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">transfers</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span>		is_dma_mapped:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* REVISIT:  we might want a flag affecting the behavior of the</span></span><br><span class="line"><span class="comment">	 * last transfer ... allowing things like &quot;read 16 bit length L&quot;</span></span><br><span class="line"><span class="comment">	 * immediately followed by &quot;read L bytes&quot;.  Basically imposing</span></span><br><span class="line"><span class="comment">	 * a specific message scheduling algorithm.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Some controller drivers (message-at-a-time queue processing)</span></span><br><span class="line"><span class="comment">	 * could provide that as their default scheduling algorithm.  But</span></span><br><span class="line"><span class="comment">	 * others (with multi-message pipelines) could need a flag to</span></span><br><span class="line"><span class="comment">	 * tell them about such special cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* completion is reported through a callback */</span></span><br><span class="line">	<span class="type">void</span>			(*complete)(<span class="type">void</span> *context);</span><br><span class="line">	<span class="type">void</span>			*context;</span><br><span class="line">	<span class="type">unsigned</span>		frame_length;</span><br><span class="line">	<span class="type">unsigned</span>		actual_length;</span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for optional use by whatever driver currently owns the</span></span><br><span class="line"><span class="comment">	 * spi_message ...  between calls to spi_async and then later</span></span><br><span class="line"><span class="comment">	 * complete(), that&#x27;s the spi_controller controller driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">queue</span>;</span></span><br><span class="line">	<span class="type">void</span>			*state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* list of spi_res reources when the spi message is processed */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">resources</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在使用spi_message之前需要对其进行<strong>初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_message_init</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br></pre></td></tr></table></figure>

<p>**m：**要初始化的spi_message。<br>**返回值：**无。</p>
</li>
<li><p>spi_message 初始化完成以后需要<strong>将spi_transfer添加到spi_message 队列中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)</span><br></pre></td></tr></table></figure>

<p>**t：**要添加到队列中的spi_transfer。<br>**m：**spi_transfer 要加入的spi_message。<br>**返回值：**无。</p>
</li>
<li><p>spi_message 准备好以后就可以进行<strong>数据传输</strong>了，数据传输分为<strong>同步传输</strong>和<strong>异步传输</strong>，</p>
<ul>
<li><p><strong>同步传输会阻塞</strong>的等待SPI 数据传输完成，同步传输函数为spi_sync</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_sync</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br></pre></td></tr></table></figure>

<p>**spi：**要进行数据传输的spi_device。<br>**message：**要传输的spi_message。<br>**返回值：**无。</p>
</li>
<li><p><strong>异步传输不会阻塞</strong>的等到SPI 数据传输完成，异步传输需要设置spi_message 中的complete成员变量，complete 是一个回调函数，当SPI 异步传输完成以后此函数就会被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_async</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br></pre></td></tr></table></figure>

<p>**spi：**要进行数据传输的spi_device。<br>**message：**要传输的spi_message。<br>**返回值：**无。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>因此SPI的收发为：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI 多字节发送 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_send</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">        .tx_buf = buf,</span><br><span class="line">        .len = len,</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_message_init(&amp;m); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">    spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">    ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* SPI 多字节接收 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_receive</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">        .rx_buf = buf,</span><br><span class="line">        .len = len,</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_message_init(&amp;m); <span class="comment">/* 初始化spi_message */</span></span><br><span class="line">    spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer 添加到spi_message 队列 */</span></span><br><span class="line">    ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集成之后就是：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608寄存器读写数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  寄存器地址</span></span><br><span class="line"><span class="comment"> * @param -buf:   数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - len:  数据长度</span></span><br><span class="line"><span class="comment"> * @param - is_read: 是否为读操作，true为读，false为写</span></span><br><span class="line"><span class="comment"> * @return 	  :   操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_transfer</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">bool</span> is_read)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *txdata;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rxdata = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">    <span class="keyword">if</span>(!t) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为发送数据分配内存 */</span></span><br><span class="line">    txdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) + len, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!txdata) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是读操作，还需要为接收数据分配内存 */</span></span><br><span class="line">    <span class="keyword">if</span> (is_read) &#123;</span><br><span class="line">        rxdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span>(!rxdata) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置寄存器地址，读操作时bit8置1，写操作时bit8清零 */</span></span><br><span class="line">    txdata[<span class="number">0</span>] = is_read ? (reg | <span class="number">0x80</span>) : (reg &amp; ~<span class="number">0x80</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 写操作需要将要写入的数据拷贝到发送缓冲区 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_read) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(txdata + <span class="number">1</span>, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置SPI传输 */</span></span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;rx_buf = is_read ? rxdata : <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;len = len + <span class="number">1</span>;  <span class="comment">/* 包含寄存器地址的总长度 */</span></span><br><span class="line">    </span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">    spi_message_add_tail(t, &amp;m);</span><br><span class="line">    ret = spi_sync(spi, &amp;m);</span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读操作需要将接收的数据拷贝到输出缓冲区 */</span></span><br><span class="line">    <span class="keyword">if</span> (is_read) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, rxdata, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out3:</span><br><span class="line">    <span class="keyword">if</span> (is_read) &#123;</span><br><span class="line">        kfree(rxdata);  <span class="comment">/* 释放接收缓冲区 */</span></span><br><span class="line">    &#125;</span><br><span class="line">out2:</span><br><span class="line">    kfree(txdata);    <span class="comment">/* 释放发送缓冲区 */</span></span><br><span class="line">out1:</span><br><span class="line">    kfree(t);         <span class="comment">/* 释放spi_transfer结构体 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读寄存器的封装函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> icm20608_transfer(dev, reg, buf, len, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写寄存器的封装函数 */</span></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> icm20608_transfer(dev, reg, buf, len, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="spidev"><a href="#spidev" class="headerlink" title="spidev"></a>spidev</h1><p>spidev接口是一个在用户空间与内核空间之间提供SPI通信能力的桥梁。它通过一组文件操作接口（如open、read、write、ioctl等）暴露给用户空间程序。当用户空间程序打开spidev设备文件时，内核会为该程序创建一个表示SPI设备的文件描述符。随后，程序可以使用write和read系统调用来发送和接收数据，使用ioctl系统调用来配置SPI通信的参数（如时钟频率、时钟极性、时钟相位等）。spidev接口简化了SPI通信的复杂性，使得开发者无需深入了解内核驱动开发即可实现SPI通信。</p>
<p><img src="image-20250914212501998.png" alt="image-20250914212501998"></p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>设备树里你需要的spi设备节点的<strong>compatible属性</strong>等于下列值，就会跟spidev驱动匹配：</p>
<ul>
<li>“rohm,dh2228fv”</li>
<li>“lineartechnology,ltc2488”</li>
<li>“spidev”</li>
</ul>
<p>匹配之后，spidev.c的<code>spidev_probe</code>会被调用，它会：</p>
<ul>
<li>分配一个spidev_data结构体，用来记录对于的<strong>spi_device</strong></li>
<li><strong>spidev_data</strong>会被<strong>记录在一个链表里</strong></li>
<li><strong>分配一个次设备号</strong>，以后可以根据这个次设备号在链表里<strong>找到spidev_data</strong></li>
<li>device_create：这会生产一个设备节点<code>/dev/spidevB.D</code>，B表示总线号，D表示它是这个SPI Master下第几个设备</li>
</ul>
<p>以后，我们就可以通过<code>/dev/spidevB.D</code>来访问spidev驱动程序。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>内核提供的测试程序：<code>tools\spi\spidev_fdx.c</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spidev_fdx [-h] [-m N] [-r N] /dev/spidevB.D</span><br></pre></td></tr></table></figure>

<ul>
<li>-h: 打印用法</li>
<li>-m N：先写1个字节0xaa，再读N个字节，**注意：**不是同时写同时读</li>
<li>-r N：读N个字节</li>
</ul>
<p><code>spidev.c</code>通过file_operations向应用层提供接口：</p>
<ul>
<li><p>单独的读&#x2F;写函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Read-only message with current device setup */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">spidev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="type">ssize_t</span>			status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chipselect only toggles at start or end of operation */</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt; bufsiz)</span><br><span class="line">		<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line"></span><br><span class="line">	spidev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">	status = spidev_sync_read(spidev, count);</span><br><span class="line">	<span class="keyword">if</span> (status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span>	missing;</span><br><span class="line"></span><br><span class="line">		missing = copy_to_user(buf, spidev-&gt;rx_buffer, status);</span><br><span class="line">		<span class="keyword">if</span> (missing == status)</span><br><span class="line">			status = -EFAULT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			status = status - missing;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;spidev-&gt;buf_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-only message with current device setup */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">spidev_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="type">ssize_t</span>			status;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		missing;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chipselect only toggles at start or end of operation */</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt; bufsiz)</span><br><span class="line">		<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line"></span><br><span class="line">	spidev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">	missing = copy_from_user(spidev-&gt;tx_buffer, buf, count);</span><br><span class="line">	<span class="keyword">if</span> (missing == <span class="number">0</span>)</span><br><span class="line">		status = spidev_sync_write(spidev, count);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		status = -EFAULT;</span><br><span class="line">	mutex_unlock(&amp;spidev-&gt;buf_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双工传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">spidev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			retval = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line">	u32			tmp;</span><br><span class="line">	<span class="type">unsigned</span>		n_ioc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_ioc_transfer</span>	*<span class="title">ioc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check type and command number */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* guard against device removal before, or while,</span></span><br><span class="line"><span class="comment">	 * we issue this ioctl.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spidev = filp-&gt;private_data;</span><br><span class="line">	spin_lock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line">	spi = spi_dev_get(spidev-&gt;spi);</span><br><span class="line">	spin_unlock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (spi == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ESHUTDOWN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* use the buffer lock here for triple duty:</span></span><br><span class="line"><span class="comment">	 *  - prevent I/O (from us) so calling spi_setup() is safe;</span></span><br><span class="line"><span class="comment">	 *  - prevent concurrent SPI_IOC_WR_* from morphing</span></span><br><span class="line"><span class="comment">	 *    data fields while SPI_IOC_RD_* reads them;</span></span><br><span class="line"><span class="comment">	 *  - SPI_IOC_MESSAGE needs the buffer locked &quot;normally&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;spidev-&gt;buf_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="comment">/* read requests */</span></span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_RD_MODE:</span><br><span class="line">		retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">					(__u8 __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_RD_MODE32:</span><br><span class="line">		retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">					(__u32 __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_RD_LSB_FIRST:</span><br><span class="line">		retval = put_user((spi-&gt;mode &amp; SPI_LSB_FIRST) ?  <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">					(__u8 __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_RD_BITS_PER_WORD:</span><br><span class="line">		retval = put_user(spi-&gt;bits_per_word, (__u8 __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_RD_MAX_SPEED_HZ:</span><br><span class="line">		retval = put_user(spidev-&gt;speed_hz, (__u32 __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* write requests */</span></span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_WR_MODE:</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_WR_MODE32:</span><br><span class="line">		<span class="keyword">if</span> (cmd == SPI_IOC_WR_MODE)</span><br><span class="line">			retval = get_user(tmp, (u8 __user *)arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			retval = get_user(tmp, (u32 __user *)arg);</span><br><span class="line">		<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span> =</span> spi-&gt;controller;</span><br><span class="line">			u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tmp &amp; ~SPI_MODE_MASK) &#123;</span><br><span class="line">				retval = -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ctlr-&gt;use_gpio_descriptors &amp;&amp; ctlr-&gt;cs_gpiods &amp;&amp;</span><br><span class="line">			    ctlr-&gt;cs_gpiods[spi-&gt;chip_select])</span><br><span class="line">				tmp |= SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line">			tmp |= spi-&gt;mode &amp; ~SPI_MODE_MASK;</span><br><span class="line">			spi-&gt;mode = (u16)tmp;</span><br><span class="line">			retval = spi_setup(spi);</span><br><span class="line">			<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">				spi-&gt;mode = save;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;spi mode %x\n&quot;</span>, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_WR_LSB_FIRST:</span><br><span class="line">		retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">		<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">			u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tmp)</span><br><span class="line">				spi-&gt;mode |= SPI_LSB_FIRST;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				spi-&gt;mode &amp;= ~SPI_LSB_FIRST;</span><br><span class="line">			retval = spi_setup(spi);</span><br><span class="line">			<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">				spi-&gt;mode = save;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%csb first\n&quot;</span>,</span><br><span class="line">						tmp ? <span class="string">&#x27;l&#x27;</span> : <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_WR_BITS_PER_WORD:</span><br><span class="line">		retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">		<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">			u8	save = spi-&gt;bits_per_word;</span><br><span class="line"></span><br><span class="line">			spi-&gt;bits_per_word = tmp;</span><br><span class="line">			retval = spi_setup(spi);</span><br><span class="line">			<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">				spi-&gt;bits_per_word = save;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d bits per word\n&quot;</span>, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SPI_IOC_WR_MAX_SPEED_HZ:</span><br><span class="line">		retval = get_user(tmp, (__u32 __user *)arg);</span><br><span class="line">		<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">			u32	save = spi-&gt;max_speed_hz;</span><br><span class="line"></span><br><span class="line">			spi-&gt;max_speed_hz = tmp;</span><br><span class="line">			retval = spi_setup(spi);</span><br><span class="line">			<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">				spidev-&gt;speed_hz = tmp;</span><br><span class="line">				dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d Hz (max)\n&quot;</span>,</span><br><span class="line">					spidev-&gt;speed_hz);</span><br><span class="line">			&#125;</span><br><span class="line">			spi-&gt;max_speed_hz = save;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* segmented and/or full-duplex I/O request */</span></span><br><span class="line">		<span class="comment">/* Check message and copy into scratch area */</span></span><br><span class="line">		ioc = spidev_get_ioc_message(cmd,</span><br><span class="line">				(<span class="keyword">struct</span> spi_ioc_transfer __user *)arg, &amp;n_ioc);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(ioc)) &#123;</span><br><span class="line">			retval = PTR_ERR(ioc);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!ioc)</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">/* n_ioc is also 0 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* translate to spi_message, execute */</span></span><br><span class="line">		retval = spidev_message(spidev, ioc, n_ioc);</span><br><span class="line">		kfree(ioc);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">	spi_dev_put(spi);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="icm20608实验"><a href="#icm20608实验" class="headerlink" title="icm20608实验"></a>icm20608实验</h1><h2 id="ICM-20608"><a href="#ICM-20608" class="headerlink" title="ICM-20608"></a>ICM-20608</h2><p>ICM-20608 是InvenSense 出品的一款6 轴MEMS 传感器，包括3 轴加速度和3 轴陀螺仪。</p>
<p>使用SPI 接口读写寄存器需要16 个时钟或者更多(如果读写操作包括多个字节的话)，<strong>第一个字节包含要读写的寄存器地址</strong>，寄存器地址<strong>最高位是读写标志位</strong>，如果是<strong>读的话寄存器地址最高位要为1</strong>，如果是<strong>写的话寄存器地址最高位要为0</strong>，剩下的<strong>7 位</strong>才是实际的<strong>寄存器地址</strong>，寄存器地址后面跟着的就是读写的数据。</p>
<img src="image-20250827212420473.png" alt="image-20250827212420473" style="zoom:50%;">

<img src="image-20250827212517570.png" alt="image-20250827212517570" style="zoom:50%;">

<img src="image-20250827212538389.png" alt="image-20250827212538389" style="zoom: 50%;">

<img src="image-20250827212628763.png" alt="image-20250827212628763" style="zoom:50%;">

<p>在icm20608 驱动中将陀螺仪和加速度计的测量范围全部设置到了最大，分别为±2000 和±16g。因此，在计算实际值的时候<strong>陀螺仪使用16.4</strong>，<strong>加速度计使用2048</strong>。</p>
<h2 id="设备树编写"><a href="#设备树编写" class="headerlink" title="设备树编写"></a><strong>设备树编写</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">	fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;				<span class="comment">/* 1个片选 */</span></span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;		<span class="comment">/* 片选引脚，软件片选！ */</span></span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对应的SPI芯片子节点 */</span></span><br><span class="line">	spidev0: icm20608@<span class="number">0</span> &#123;			<span class="comment">/* @后面的0表示次SPI芯片接到哪个硬件片选上 */</span></span><br><span class="line">		reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">		compatible = <span class="string">&quot;kevin,icm20608&quot;</span>;</span><br><span class="line">		spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;	<span class="comment">/*  SPI时钟频率8MHz*/</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_ecspi3: ecspi3grp&#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20		<span class="number">0x10b0</span><span class="comment">/* CS */</span></span><br><span class="line">		MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK	<span class="number">0X10b1</span><span class="comment">/* SCLK */</span></span><br><span class="line">		MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI		<span class="number">0x10b1</span><span class="comment">/* MISO */</span></span><br><span class="line">		MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO		<span class="number">0x10b1</span><span class="comment">/* MOSI */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置当前片选数量为1，因为就只接了一个ICM20608。</li>
<li>一定要<strong>使用 “cs-gpios”属性来描述片选引脚</strong>，SPI 主机驱动就会控制片选引脚</li>
<li>设置IO 要使用的pinctrl 子节点，也就是我们在示例代码62.5.1.1 中新建的pinctrl_ecspi3</li>
<li>icm20608 设备子节点，因为icm20608 连接在ECSPI3 的第0 个通道上，因此@后面为0。</li>
<li>设置节点属性兼容值为“kevin,icm20608”</li>
<li>设置SPI 最大时钟频率为8MHz，这是ICM20608 的SPI 接口所能支持的最大的时钟频率。</li>
<li>icm20608连接在通道0上，因此reg 为0。</li>
</ul>
<h2 id="驱动编写"><a href="#驱动编写" class="headerlink" title="驱动编写"></a>驱动编写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FSYNC_INT				0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_ENABLE			0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_STATUS			0x3A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_USER_CTRL				0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_R_W				0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_NAME	<span class="string">&quot;icm20608&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;				<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>			<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 	<span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;					<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;			<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc;		<span class="comment">/* 陀螺仪X轴原始值 	 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_adc;		<span class="comment">/* 陀螺仪Y轴原始值		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_adc;		<span class="comment">/* 陀螺仪Z轴原始值 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc;		<span class="comment">/* 加速度计X轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_adc;		<span class="comment">/* 加速度计Y轴原始值	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_adc;		<span class="comment">/* 加速度计Z轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;		<span class="comment">/* 温度原始值 			*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> <span class="title">icm20608dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 从icm20608读取多个寄存器数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  读取到的数据</span></span><br><span class="line"><span class="comment"> * @param - len:  要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @return 		: 操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> txdata[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> * rxdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rxdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len, GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!rxdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，一共要读取len个字节长度的数据，*/</span></span><br><span class="line">	txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;		<span class="comment">/* 写数据的时候首寄存器地址bit8要置1 */</span>			</span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">    t-&gt;rx_buf = rxdata;			<span class="comment">/* 要读取的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">	<span class="keyword">if</span>(ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">memcpy</span>(buf , rxdata+<span class="number">1</span>, len);  <span class="comment">/* 只需要读取的数据 */</span></span><br><span class="line"></span><br><span class="line">out2:</span><br><span class="line">	kfree(rxdata);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:	</span><br><span class="line">	kfree(t);						<span class="comment">/* 释放内存 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608多个寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写入的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  要写入的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - len:  要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @return 	  :   操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *txdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	txdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>)+len, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(!txdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，len为要写入的寄存器的集合，*/</span></span><br><span class="line">	*txdata = reg &amp; ~<span class="number">0x80</span>;	<span class="comment">/* 写数据的时候首寄存器地址bit8要清零 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(txdata+<span class="number">1</span>, buf, len);	<span class="comment">/* 把len个寄存器拷贝到txdata里，等待发送 */</span></span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">out2:</span><br><span class="line">	kfree(txdata);				<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:</span><br><span class="line">	kfree(t);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取icm20608指定寄存器值，读取一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器</span></span><br><span class="line"><span class="comment"> * @return 	  :   读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line">	icm20608_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608指定寄存器写入指定的值，写一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写的寄存器</span></span><br><span class="line"><span class="comment"> * @param - data: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return   :    无</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">icm20608_write_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 buf = value;</span><br><span class="line">	icm20608_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、</span></span><br><span class="line"><span class="comment"> * 				: 三轴加速度计和内部温度。</span></span><br><span class="line"><span class="comment"> * @param - dev	: ICM20608设备</span></span><br><span class="line"><span class="comment"> * @return 		: 无。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_readdata</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]); </span><br><span class="line">	dev-&gt;accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]); </span><br><span class="line">	dev-&gt;accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]); </span><br><span class="line">	dev-&gt;temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]); </span><br><span class="line">	dev-&gt;gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]); </span><br><span class="line">	dev-&gt;gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">	dev-&gt;gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做pr似有ate_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data似有向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;icm20608dev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp 	: 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf 	: 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt 	: 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt 	: 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return 			: 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">icm20608_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> data[<span class="number">7</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> icm20608_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	icm20608_readdata(dev);</span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;gyro_x_adc;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;gyro_y_adc;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;gyro_z_adc;</span><br><span class="line">	data[<span class="number">3</span>] = dev-&gt;accel_x_adc;</span><br><span class="line">	data[<span class="number">4</span>] = dev-&gt;accel_y_adc;</span><br><span class="line">	data[<span class="number">5</span>] = dev-&gt;accel_z_adc;</span><br><span class="line">	data[<span class="number">6</span>] = dev-&gt;temp_adc;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* icm20608操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">icm20608_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = icm20608_open,</span><br><span class="line">	.read = icm20608_read,</span><br><span class="line">	.release = icm20608_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ICM20608内部寄存器初始化函数 </span></span><br><span class="line"><span class="comment"> * @param  	: 无</span></span><br><span class="line"><span class="comment"> * @return 	: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_reginit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 value = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x80</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	value = icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);</span><br><span class="line">	printk(<span class="string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);	</span><br><span class="line"></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, <span class="number">0x00</span>); 	<span class="comment">/* 输出速率是内部采样率					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 陀螺仪±2000dps量程 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 加速度计±16G量程 					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, <span class="number">0x04</span>); 		<span class="comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); <span class="comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, <span class="number">0x00</span>); 	<span class="comment">/* 打开加速度计和陀螺仪所有轴 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, <span class="number">0x00</span>); 	<span class="comment">/* 关闭低功耗 						*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, <span class="number">0x00</span>);		<span class="comment">/* 关闭FIFO						*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : spi驱动的probe函数，当驱动与</span></span><br><span class="line"><span class="comment">  *                    设备匹配以后此函数就会执行</span></span><br><span class="line"><span class="comment">  * @param - client  : i2c设备</span></span><br><span class="line"><span class="comment">  * @param - id      : i2c设备ID</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span>	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 1、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (icm20608dev.major) &#123;</span><br><span class="line">		icm20608dev.devid = MKDEV(icm20608dev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;icm20608dev.devid, <span class="number">0</span>, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">		icm20608dev.major = MAJOR(icm20608dev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、注册设备 */</span></span><br><span class="line">	cdev_init(&amp;icm20608dev.cdev, &amp;icm20608_ops);</span><br><span class="line">	cdev_add(&amp;icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、创建类 */</span></span><br><span class="line">	icm20608dev.class = class_create(THIS_MODULE, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、创建设备 */</span></span><br><span class="line">	icm20608dev.device = device_create(icm20608dev.class, <span class="literal">NULL</span>, icm20608dev.devid, <span class="literal">NULL</span>, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化spi_device */</span></span><br><span class="line">	spi-&gt;mode = SPI_MODE_0;	<span class="comment">/*MODE0，CPOL=0，CPHA=0*/</span></span><br><span class="line">	spi_setup(spi);</span><br><span class="line">	icm20608dev.private_data = spi; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化ICM20608内部寄存器 */</span></span><br><span class="line">	icm20608_reginit();		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - client 	: i2c设备</span></span><br><span class="line"><span class="comment"> * @return          : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 删除设备 */</span></span><br><span class="line">	cdev_del(&amp;icm20608dev.cdev);</span><br><span class="line">	unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注销掉类和设备 */</span></span><br><span class="line">	device_destroy(icm20608dev.class, icm20608dev.devid);</span><br><span class="line">	class_destroy(icm20608dev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">icm20608_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,icm20608&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">icm20608_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,icm20608&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI驱动结构体 */</span>	</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">icm20608_driver</span> =</span> &#123;</span><br><span class="line">	.probe = icm20608_probe,</span><br><span class="line">	.remove = icm20608_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;icm20608&quot;</span>,</span><br><span class="line">		   	.of_match_table = icm20608_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line">		   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">icm20608_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">icm20608_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(icm20608_init);</span><br><span class="line">module_exit(icm20608_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;KEVIN&quot;</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">设置值</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>ICM20_SMPLRT_DIV</code> (0x19)</strong></td>
<td align="left"><strong><code>0x00</code></strong></td>
<td align="left"><strong>采样率分频器</strong> 计算公式：<code>采样率 = 内部采样率 / (1 + SMPLRT_DIV)</code>。 设置 <code>0x00</code> 意味着 <code>SMPLRT_DIV = 0</code>，因此采样率等于内部采样率（通常为1kHz）。<strong>这是为了获得最高的输出数据率（ODR）。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_GYRO_CONFIG</code> (0x1B)</strong></td>
<td align="left"><strong><code>0x18</code></strong></td>
<td align="left"><strong>陀螺仪配置</strong> 查看寄存器位定义： - <code>Bit 4:3 FS_SEL[1:0]</code>: 陀螺仪量程选择。 - <code>00</code> &#x3D; ±250 dps - <code>01</code> &#x3D; ±500 dps - <code>10</code> &#x3D; ±1000 dps - <strong><code>11</code> &#x3D; ±2000 dps</strong> - <code>Bit 1:0 FCHOICE_B[1:0]</code>: 用于选择是否 bypass 数字低通滤波器 (DLPF)。 - <strong><code>00</code> &#x3D; 使用 DLPF</strong> (由 <code>CONFIG</code> 寄存器配置) - 其他值 &#x3D; bypass DLPF (带宽更宽，噪声更大)  <code>0x18</code> 的二进制是 <code>0001 1000</code>。 - <code>FS_SEL[1:0]</code> (Bit4:3) &#x3D; <code>11</code> → <strong>±2000 dps</strong> - <code>FCHOICE_B[1:0]</code> (Bit1:0) &#x3D; <code>00</code> → <strong>使用 DLPF</strong>  <strong>此设置选择了陀螺仪的最大量程并启用了抗混叠滤波。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_ACCEL_CONFIG</code> (0x1C)</strong></td>
<td align="left"><strong><code>0x18</code></strong></td>
<td align="left"><strong>加速度计配置</strong> 位定义类似陀螺仪： - <code>Bit 4:3 ACCEL_FS_SEL[1:0]</code>: 加速度计量程选择。 - <code>00</code> &#x3D; ±2g - <code>01</code> &#x3D; ±4g - <code>10</code> &#x3D; ±8g - <strong><code>11</code> &#x3D; ±16g</strong>  <code>0x18</code> 的二进制是 <code>0001 1000</code>。 - <code>ACCEL_FS_SEL[1:0]</code> (Bit4:3) &#x3D; <code>11</code> → <strong>±16g</strong>  <strong>此设置选择了加速度计的最大量程。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_CONFIG</code> (0x1A)</strong></td>
<td align="left"><strong><code>0x04</code></strong></td>
<td align="left"><strong>全局配置 (主要配置陀螺仪DLPF)</strong> - <code>Bit 2:0 DLPF_CFG[2:0]</code>: 数字低通滤波器配置。 根据手册中的表格，<code>DLPF_CFG = 4</code> (即 <code>0x04</code> 的二进制 <code>100</code>) 对应的陀螺仪带宽为 <strong>20Hz</strong> (噪声带宽 30.5Hz)。  <strong>此设置将陀螺仪的通路限制在20Hz，有效抑制高频噪声，适用于大多数运动检测场景。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_ACCEL_CONFIG2</code> (0x1D)</strong></td>
<td align="left"><strong><code>0x04</code></strong></td>
<td align="left"><strong>加速度计配置2</strong> - <code>Bit 3 ACCEL_FCHOICE_B</code>: 加速度计DLPF选择位。 - <code>1</code> &#x3D; bypass DLPF (带宽 ~1046Hz) - <strong><code>0</code> &#x3D; 使用 DLPF</strong> - <code>Bit 2:0 A_DLPF_CFG[2:0]</code>: 加速度计DLPF配置。 根据手册表格，<code>A_DLPF_CFG = 4</code> (即 <code>0x04</code> 的二进制 <code>100</code>) 对应的加速度计带宽为 <strong>21.2Hz</strong> (噪声带宽 31.0Hz)。  <strong>此设置将加速度计的通路也限制在约21Hz，与陀螺仪设置匹配，同样是为了滤除高频噪声。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_PWR_MGMT_2</code> (0x6C)</strong></td>
<td align="left"><strong><code>0x00</code></strong></td>
<td align="left"><strong>电源管理2</strong> 这个寄存器的低6位用于控制各轴的待机模式： - <code>Bit 5: STBY_XA</code> (X加速度计待机) - <code>Bit 4: STBY_YA</code> (Y加速度计待机) - <code>Bit 3: STBY_ZA</code> (Z加速度计待机) - <code>Bit 2: STBY_XG</code> (X陀螺仪待机) - <code>Bit 1: STBY_YG</code> (Y陀螺仪待机) - <code>Bit 0: STBY_ZG</code> (Z陀螺仪待机)  <code>1</code> &#x3D; 关闭该轴， <code>0</code> &#x3D; 开启该轴。 <code>0x00</code> 的二进制是 <code>0000 0000</code>，意味着<strong>所有低6位都是0</strong>。  <strong>此设置开启了加速度计和陀螺仪的所有轴，使它们全部进入工作状态。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_LP_MODE_CFG</code> (0x1E)</strong></td>
<td align="left"><strong><code>0x00</code></strong></td>
<td align="left"><strong>低功耗模式配置</strong> 设置 <code>0x00</code> 会关闭低功耗模式下的各种循环采样功能。 <strong>此设置确保了传感器工作在正常的“低噪声”全功耗模式，而不是为了省电而间歇工作的“标准”模式，从而获得最佳性能。</strong></td>
</tr>
<tr>
<td align="left"><strong><code>ICM20_FIFO_EN</code> (0x23)</strong></td>
<td align="left"><strong><code>0x00</code></strong></td>
<td align="left"><strong>FIFO使能</strong> 这个寄存器的每一位控制是否将一种传感器数据（温度、各轴陀螺仪、加速度计）写入FIFO缓冲区。 <code>0x00</code> 表示<strong>禁止所有数据写入FIFO</strong>。 <strong>此设置意味着我们选择直接读取传感器数据寄存器，而不是使用FIFO功能。这简化了数据读取流程，适合常规应用。</strong></td>
</tr>
</tbody></table>
<h2 id="应用层代码编写"><a href="#应用层代码编写" class="headerlink" title="应用层代码编写"></a>应用层代码编写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: main主程序</span></span><br><span class="line"><span class="comment"> * @param - argc 	: argv数组元素个数</span></span><br><span class="line"><span class="comment"> * @param - argv 	: 具体参数</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> databuf[<span class="number">7</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc, gyro_y_adc, gyro_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc, accel_y_adc, accel_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;</span><br><span class="line">	<span class="type">float</span> accel_x_act, accel_y_act, accel_z_act;</span><br><span class="line">	<span class="type">float</span> temp_act;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			gyro_x_adc = databuf[<span class="number">0</span>];</span><br><span class="line">			gyro_y_adc = databuf[<span class="number">1</span>];</span><br><span class="line">			gyro_z_adc = databuf[<span class="number">2</span>];</span><br><span class="line">			accel_x_adc = databuf[<span class="number">3</span>];</span><br><span class="line">			accel_y_adc = databuf[<span class="number">4</span>];</span><br><span class="line">			accel_z_adc = databuf[<span class="number">5</span>];</span><br><span class="line">			temp_adc = databuf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 计算实际值 */</span></span><br><span class="line">			gyro_x_act = (<span class="type">float</span>)(gyro_x_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_y_act = (<span class="type">float</span>)(gyro_y_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_z_act = (<span class="type">float</span>)(gyro_z_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			accel_x_act = (<span class="type">float</span>)(accel_x_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_y_act = (<span class="type">float</span>)(accel_y_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_z_act = (<span class="type">float</span>)(accel_z_adc) / <span class="number">2048</span>;</span><br><span class="line">			temp_act = ((<span class="type">float</span>)(temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n原始值:\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc, gyro_y_adc, gyro_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;temp = %d\r\n&quot;</span>, temp_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;实际值:&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act temp = %.2f°C\r\n&quot;</span>, temp_act);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始值:</span><br><span class="line">gx = -4, gy = 2, gz = -1</span><br><span class="line">ax = -7, ay = 339, az = 2007</span><br><span class="line">temp = 649</span><br><span class="line">实际值:act gx = -0.24°/S, act gy = 0.12°/S, act gz = -0.06°/S</span><br><span class="line">act ax = -0.00g, act ay = 0.17g, act az = 0.98g</span><br><span class="line">act temp = 26.91°C</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/06/20/DRIVER-CH4-SPI/">https://leonardo272.github.io/2025/06/20/DRIVER-CH4-SPI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">驱动开发</a></div><div class="post-share"><div class="social-share" data-image="/page_images/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img class="cover" src="/page_images/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">镜像烧录+ssh远程登录</div></div><div class="info-2"><div class="info-item-1">1.系统安装1.1启动设置选择SD卡启动，首先需要将启动拨码开关配置成SD卡启动模式，配置方法如下图：  1.2镜像下载**下载地址：**通过如下百度云盘链接或者联系销售获取到镜像，镜像链接：https://pan.baidu.com/s/1pStiyqohrB3SxHAFFk8R6Q 提取码：dzdv &#x3D;&#x3D;注意：&#x3D;&#x3D;镜像需下载对应内存大小的版本，目前 4GB DDR使用长鑫存储（ CXMT）的颗粒 ，2GB DDR使用兆易创新（ GigaDevice）的颗粒，如果不清楚开发板是哪个容量的 DDR，可通过DDR颗粒的上丝印字样来判断。我们拿到的是最拉的板子4GB的V2.2版本的开发板。 4GB-V2.2可以选择的镜像：(按照更新的时间来排序的) xfce_v2.1_4GB_231116.tar.gz xfce_v2.1_4GB_240123.tar.gz 飞腾派v2.1_4GB_240517.tar.gz 本次项目选择的是xfce_v2.1_4GB_240123.tar.gz，不新不老。 1.3镜像烧录准备一张存储空间 32G以上的 SD卡...</div></div></div></a><a class="pagination-related" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍"><img class="cover" src="/page_images/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">kernel-sysfs文件系统介绍</div></div><div class="info-2"><div class="info-item-1">sysfs文件系统 sysfs 文件系统的目录  定义：sysfs是一个基于内存的虚拟文件系统（Virtual Filesystem）。它被挂载在 /sys 目录下，是Linux内核中内核对象（kobject）、属性（attribute）和关系（relationship） 的直观体现。 核心作用：sysfs的主要作用是在用户空间（Userspace） 和内核空间（Kernelspace） 之间搭建一座桥梁，提供一个标准化的接口，使得用户空间的程序能够安全、方便地查看和配置内核的运行参数、硬件设备信息、驱动程序状态、电源管理选项等。 具体作用包括：  展示设备层次结构：以目录树的形式清晰地展示系统中总线（bus）、设备（device）、驱动（driver）、类（class）等内核对象的层次关系。 导出对象属性：将内核对象的属性（通常是变量或状态）以普通文件的形式暴露出来。用户可以通过cat命令读取属性，通过echo命令修改属性（如果该属性可写）。 支持用户空间事件：通过poll或select系统调用，用户空间程序可以监听内核发出的事件通知（例如，设备的插拔）。  特点：  层次化结...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/05/00008/" title="驱动开发-pinctrl与gpio子系统"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">驱动开发-pinctrl与gpio子系统</div></div><div class="info-2"><div class="info-item-1">pinctrl子系统i.MX 芯片（以及很多其他 SoC）面临的一个根本问题：芯片的引脚（PAD）数量有限，但内部功能模块（如 USDHC, UART, I2C, GPIO 等）非常多。为了解决这个矛盾，芯片设计引入了 IOMUX Controller (IOMUXC)。  IOMUXC (I&#x2F;O Multiplexer Controller)： 功能：它是一个硬件控制器，允许一个物理引脚（PAD）被复用到多个内部功能模块上。 工作方式：通过寄存器配置，为每个引脚选择 up to 8 种不同的工作模式（ALT modes，即 Alternate Function 复用功能）。例如，一个引脚可以被配置为 GPIO1_IO00、UART1_TXD 或 I2C1_SDA 等功能。 额外控制：除了选择功能，IOMUXC 还控制每个引脚的电气特性，如上拉&#x2F;下拉电阻、驱动强度、转换速率等。这被称为 Pad Settings。    我们需要在设备树中设置PIN的信息，在imx6ull.dtsi文件中，找到iomuxc的节点，iomuxc 节点就是I.MX6ULL的IOMU...</div></div></div></a><a class="pagination-related" href="/2025/06/05/0001/" title="驱动开发-PWM"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">驱动开发-PWM</div></div><div class="info-2"><div class="info-item-1">PWM(Pulse Width Modulation)基础概念与理论1.什么是 PWM？它的主要参数是什么？ PWM (Pulse Width Modulation) 即脉冲宽度调制，是一种通过控制数字信号在一个周期内高电平时间（脉宽）与周期时间之比（占空比）来模拟连续电平的技术。  主要参数： 周期 (Period) &#x2F; 频率 (Frequency)： 一个完整 PWM 波形的持续时间 (T)。频率 f = 1 / T。 占空比 (Duty Cycle)： 高电平时间 (Ton) 占整个周期 (T) 的百分比 (D = (Ton / T) * 100%)。 极性 (Polarity)： PWM 信号有效电平（Active Level）是高电平有效 (Normal) 还是低电平有效 (Inversed)。    2.应用场景 电机控制： 调节速度和方向（如直流电机、步进电机）。 LED 调光： 控制亮度（通过改变平均电流）。 电源管理： DCDC 转换器输出电压调节（通过控制开关管导通时间）。 音频： 简单的 D 类放大器。 伺服控制： 控制舵机角度（特定脉宽范围对应特...</div></div></div></a><a class="pagination-related" href="/2024/11/12/0002/" title="驱动开发-基于GPIO的LED"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">驱动开发-基于GPIO的LED</div></div><div class="info-2"><div class="info-item-1">前言本次实验是基于正点原子开发板I.MX6ULL开发板来学习的 硬件原理分析本次实验我们使用的是正点原子开发板上的led灯，我们查看开发板原理图可以看到led灯连接在GPIO_3引脚上的  我们打开芯片核心原理图可以找到GPIO_3对应的是IMX6ULL芯片的GPIO1_IO03引脚  我们本次实验使用的就是I/O功能，因此我们打开arch/arm/boot/dts/imx6ul-pinfunc.h文件找到对应的宏MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  设备树编写dtbs文件：  添加pinctrl节点 在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为pinctrl_led的子节点,将 GPIO1_IO03 这个 PIN 复用为 GPIO1_IO03，电气属性值为 0X10B0。 在imx6ull-alientek-emmc.dts文件中找到&amp;iomuxc 节点，添加对应的电气属性 格式： 123456pinctrl_自定义名字: 自定义名字&#123;	fsl,pins = &lt;	引脚复用宏定义PAD（引脚）属性	引脚...</div></div></div></a><a class="pagination-related" href="/2025/02/07/0003/" title="驱动开发-并发与竞争01原理"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">驱动开发-并发与竞争01原理</div></div><div class="info-2"><div class="info-item-1">竞争的概念什么是竞争Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。 Linux 系统并发产生的原因有下面几个主要原因： ①多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。 ②抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。 ③中断程序并发访问 ④SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。 &#x3D;&#x3D;所谓的临界区就是共享数据段，对于临界区必须保证一次只有一个线程访问&#x3D;&#x3D;，也就是要保证临界区是原子访问的 什么是共享资源共享资源是指在同一时间内可以被多个执行单元（如进程、线程、中断处理程序、内核任务等）访问（读取或修改） 的任何数据、数据结构、硬件设备或状态信息。  关键特性：  并发访问可能性： 多个执行单元（几乎）同时或在时间上重...</div></div></div></a><a class="pagination-related" href="/2025/02/07/0004/" title="驱动开发-并发与竞争02原子操作"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">驱动开发-并发与竞争02原子操作</div></div><div class="info-2"><div class="info-item-1">原子操作原子操作就是指不能再进一步分割的操作，一般原子操作用于变量或者位操作。 原子操作 API 函数Linux内核定义了叫做 atomic_t 的结构体来完成用于 32 位整数的原子操作。在使用中用原子变量来代替整形变量，此结构体定义在 include/linux/types.h 文件中，定义如下： 123typedef struct &#123;	int counter;&#125; atomic_t;  用于 64 位整数的原子操作 (在支持 64 位原子操作的体系结构上)。 123typedef struct &#123;    long long counter;&#125; atomic64_t;  初始化1234567//-------编译时初始化：-----ATOMIC_INIT(int i);// 静态初始化 atomic_t 变量为 iatomic_t v ATOMIC_INIT(0);// 示例atomic64_t v64 = ATOMIC64_INIT(0); // 64位初始化宏//------运行时初始化：-------atomic_t vatomic...</div></div></div></a><a class="pagination-related" href="/2025/02/07/0007/" title="驱动开发-并发与竞争05互斥锁"><img class="cover" src="/page_images/2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">驱动开发-并发与竞争05互斥锁</div></div><div class="info-2"><div class="info-item-1">互斥锁提供比自旋锁更安全的互斥机制，支持睡眠等待，适用于可能阻塞的长临界区场景。 关键特性 强所有者模型：  仅持有者线程可解锁 严格禁止递归锁定   状态跟踪：  owner 字段存储持有者的 task_struct 指针 + 状态标志位  12345[ 持有者地址 | flags ]// flags 位含义：//   bit0: 锁是否被持有 (MUTEX_FLAG_HOLD)//   bit1: 是否有等待者 (MUTEX_FLAG_WAITERS)//   bit2: 是否启用乐观自旋 (MUTEX_FLAG_HANDOFF)  乐观自旋优化：  当 CONFIG_MUTEX_SPIN_ON_OWNER 启用时 若持有者正在运行，新竞争者短暂自旋而非立即睡眠   等待队列：  竞争失败线程加入 wait_list 并进入 TASK_UNINTERRUPTIBLE 状态   上下文限制严格 1234// 禁止在中断上下文使用void interrupt_handler() &#123;    mutex_lock(&amp;lock); // 触发 BUG()&#125; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">SPI原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">SPI特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">SPI通信流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">SPI工作模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">SPI驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">SPI控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87"><span class="toc-number">2.2.</span> <span class="toc-text">SPI设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">SPI设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.4.</span> <span class="toc-text">SPI设备驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8%E5%8C%B9%E9%85%8D"><span class="toc-number">2.5.</span> <span class="toc-text">SPI设备与驱动匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.6.</span> <span class="toc-text">SPI控制器驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">SPI设备数据收发处理流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spidev"><span class="toc-number">3.</span> <span class="toc-text">spidev</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">使用方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8"><span class="toc-number">3.2.</span> <span class="toc-text">驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#icm20608%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.</span> <span class="toc-text">icm20608实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICM-20608"><span class="toc-number">4.1.</span> <span class="toc-text">ICM-20608</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BC%96%E5%86%99"><span class="toc-number">4.2.</span> <span class="toc-text">设备树编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99"><span class="toc-number">4.3.</span> <span class="toc-text">驱动编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-number">4.4.</span> <span class="toc-text">应用层代码编写</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高危工作环境中人员安全装备佩戴检测系统"/></a><div class="content"><a class="title" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统">高危工作环境中人员安全装备佩戴检测系统</a><time datetime="2025-07-20T14:33:00.000Z" title="发表于 2025-07-20 22:33:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-SPI"/></a><div class="content"><a class="title" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI">驱动开发-SPI</a><time datetime="2025-06-20T13:12:00.000Z" title="发表于 2025-06-20 21:12:00">2025-06-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>