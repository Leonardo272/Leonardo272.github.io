<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CH4-中断的上半部与下半部 | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="中断的上半部与下半部Linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下">
<meta property="og:type" content="article">
<meta property="og:title" content="CH4-中断的上半部与下半部">
<meta property="og:url" content="https://leonardo272.github.io/2025/05/10/kernel-intc-ch4/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="中断的上半部与下半部Linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/7.jpg">
<meta property="article:published_time" content="2025-05-10T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-10T14:31:10.412Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CH4-中断的上半部与下半部",
  "url": "https://leonardo272.github.io/2025/05/10/kernel-intc-ch4/",
  "image": "https://leonardo272.github.io/page_images/7.jpg",
  "datePublished": "2025-05-10T13:12:00.000Z",
  "dateModified": "2025-09-10T14:31:10.412Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/05/10/kernel-intc-ch4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CH4-中断的上半部与下半部',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">CH4-中断的上半部与下半部</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CH4-中断的上半部与下半部</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T13:12:00.000Z" title="发表于 2025-05-10 21:12:00">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-10T14:31:10.412Z" title="更新于 2025-09-10 22:31:10">2025-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/">中断子系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="中断的上半部与下半部"><a href="#中断的上半部与下半部" class="headerlink" title="中断的上半部与下半部"></a>中断的上半部与下半部</h1><p>Linux内核将中断分为上半部和下半部的主要目的就是<strong>实现中断处理函数的快进快出</strong>，我们在使用<strong>request_irq</strong>申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。</p>
<p><strong>上半部：<strong>上半部就是中断处理函数，那些</strong>处理过程比较快</strong>，<strong>不会占用很长时间</strong>的处理就可以放在上半部完成。</p>
<p><strong>下半部：<strong>如果中断</strong>处理过程比较耗时</strong>，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</p>
<p><strong>可以参考：</strong></p>
<ul>
<li>如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li>
<li>如果要处理的任务对时间敏感，可以放到上半部。</li>
<li>如果要处理的任务与硬件有关，可以放到上半部</li>
<li>除了上述三点以外的其他任务，优先考虑放到下半部</li>
</ul>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>Linux 内核使用<strong>结构体softirq_action 表示软中断</strong>， softirq_action结构体定义在文include&#x2F;linux&#x2F;interrupt.h中<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L555">softirq_action</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span>	(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在&#x2F;include&#x2F;linux&#x2F;interrupt.h 文件中一共定义了10 个软中断，如下所示：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L528">interrupt.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组softirq_vec 有10 个元素。softirq_action结构体中的action成员变量就是软中断的服务函数，数组softirq_vec是个全局数组，因此所有的CPU(对于SMP系统而言)都可以访问到，每个CPU都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个CPU所执行的软中断服务函数确是相同的，都是数组softirq_vec 中定义的action函数。</p>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>执行上下文</strong>：<strong>软中断上下文</strong>。处于中断退出阶段，不属于任何进程。</p>
</li>
<li><p><strong>抢占与睡眠</strong>：<strong>不能睡眠&#x2F;阻塞</strong>（因为不属于进程，没有任务结构体去调度）。执行时<strong>开中断</strong>，可以被新的硬件中断打断，但不能被自身嵌套（同一个CPU上同类型软中断不会重入）。</p>
</li>
<li><p><strong>并发性</strong>：<strong>所有CPU上都可以同时运行</strong>，即使是同一种类型的软中断。这意味着开发者必须自己处理复杂的<strong>锁机制</strong>（如自旋锁）来保护共享数据，编程难度高。</p>
</li>
<li><p><strong>执行延迟</strong>：<strong>延迟极低</strong>。一旦中断退出，会立刻检查并执行pending的软中断，响应非常快。</p>
</li>
<li><p><strong>静态分配</strong>：内核编译时静态定义（如 <code>HI_SOFTIRQ</code>, <code>TIMER_SOFTIRQ</code>, <code>NET_TX_SOFTIRQ</code>, <code>NET_RX_SOFTIRQ</code>），数量有限，不能动态注册。</p>
</li>
<li><p><strong>机制</strong>：通过 <code>raise_softirq()</code> 触发，在 <code>irq_exit()</code> 中检查并执行。</p>
</li>
<li><p>对<strong>性能要求极高</strong>、<strong>执行频率非常高</strong>的场景。</p>
</li>
<li><p>典型代表：<strong>网络子系统</strong>（收发数据包）、<strong>块设备子系统</strong>（IO调度）。</p>
</li>
<li><p>内核定时器的底半部 (<code>TIMER_SOFTIRQ</code>) 也使用它。</p>
</li>
</ul>
<h3 id="软中断API函数"><a href="#软中断API函数" class="headerlink" title="软中断API函数"></a>软中断API函数</h3><p><strong>注册软中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>nr</code>：软中断号（0-9），例如：<code>TASKLET_SOFTIRQ</code>、<code>HI_SOFTIRQ</code>等</li>
<li><code>action</code>：软中断处理函数指针</li>
</ul>
</li>
<li><strong>说明</strong>：注册一个软中断类型及其处理函数</li>
</ul>
<p><strong>触发软中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>nr</code>：要触发的软中断号</li>
</ul>
</li>
<li><strong>说明</strong>：在适当的时候（通常是中断返回时），内核会检查并执行已触发的软中断</li>
</ul>
<h3 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h3><p>伪代码：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义软中断号 (需要在已定义的软中断之后)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_SOFTIRQ 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_device</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">// 其他设备相关数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *softirq_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软中断共享的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">softirq_data</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> jiffies;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">my_device</span> my_dev;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *local_data = data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在软中断上下文中处理数据</span></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;My softirq handler running on CPU %d, count: %u, jiffies: %lu\n&quot;</span>,</span><br><span class="line">           <span class="built_in">smp_processor_id</span>(), local_data-&gt;count, local_data-&gt;jiffies);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟一些处理工作</span></span><br><span class="line">    local_data-&gt;count++;</span><br><span class="line">    local_data-&gt;jiffies = jiffies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断处理函数（顶半部）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">my_device</span> *dev = (<span class="keyword">struct</span> my_device *)dev_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速处理紧急任务</span></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;IRQ handler running on CPU %d\n&quot;</span>, <span class="built_in">smp_processor_id</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新要传递给软中断的数据</span></span><br><span class="line">    data-&gt;count = <span class="number">1</span>;</span><br><span class="line">    data-&gt;jiffies = jiffies;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发软中断</span></span><br><span class="line">    <span class="built_in">raise_softirq</span>(MY_SOFTIRQ);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">my_softirq_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Initializing my softirq module\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配软中断数据结构</span></span><br><span class="line">    data = <span class="built_in">kmalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> softirq_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;Failed to allocate softirq data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化设备结构</span></span><br><span class="line">    my_dev.name = <span class="string">&quot;my_softirq_device&quot;</span>;</span><br><span class="line">    my_dev.softirq_data = data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册软中断</span></span><br><span class="line">    <span class="built_in">open_softirq</span>(MY_SOFTIRQ, my_softirq_handler);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Registered softirq %d\n&quot;</span>, MY_SOFTIRQ);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在实际驱动中，这里会请求硬件IRQ</span></span><br><span class="line">    <span class="comment">// 为了示例，我们假设IRQ号为10</span></span><br><span class="line">    ret = <span class="built_in">request_irq</span>(<span class="number">10</span>, my_irq_handler, IRQF_SHARED, </span><br><span class="line">                     <span class="string">&quot;my_softirq_device&quot;</span>, &amp;my_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;Failed to request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="built_in">kfree</span>(data);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">my_softirq_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Exiting my softirq module\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放IRQ</span></span><br><span class="line">    <span class="built_in">free_irq</span>(<span class="number">10</span>, &amp;my_dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(my_softirq_init);</span><br><span class="line"><span class="built_in">module_exit</span>(my_softirq_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;kevin&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_DESCRIPTION</span>(<span class="string">&quot;Example of using softirq in a driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>Tasklet 是一种<strong>软中断（SoftIRQ）</strong> 机制，用于处理中断下半部（bottom half）的任务。它运行在<strong>中断上下文</strong>（但不在硬中断处理函数中），具有以下特点：</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>执行上下文</strong>：<strong>软中断上下文</strong>（基于 <code>HI_SOFTIRQ</code> 和 <code>TASKLET_SOFTIRQ</code> 两种软中断实现）。</li>
<li><strong>抢占与睡眠</strong>：<strong>不能睡眠&#x2F;阻塞</strong>，原因同软中断。</li>
<li><strong>并发性</strong>：这是与软中断的<strong>关键区别</strong>。<strong>同一种类的tasklet在多个CPU上是串行执行的</strong>。一个tasklet一旦在某CPU上被调度执行，其他CPU不会同时执行同一种类的tasklet。这大大<strong>降低了并发编程的复杂度</strong>，通常不需要考虑复杂的锁。</li>
<li><strong>执行延迟</strong>：延迟低，与软中断类似，机制相同。</li>
<li><strong>动态分配</strong>：可以动态创建和初始化，使用灵活。</li>
<li><strong>机制</strong>：通过 <code>tasklet_schedule()</code> 调度。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要延后执行、<strong>频率较高</strong>但<strong>不需要复杂并发控制</strong>的设备驱动程序。</li>
<li>是<strong>大多数设备驱动程序首选的底半部机制</strong>（除非性能要求极高到必须用软中断）。</li>
<li>典型例子：<strong>按键中断</strong>、<strong>鼠标中断</strong>等。将读取数据等操作放在顶半部，将数据处理和报告事件的工作放在tasklet中。</li>
</ul>
<img src="image-20250903221103956.png" alt="image-20250903221103956" style="zoom: 67%;">

<h3 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h3><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DECLARE_TASKLET(name, _callback)</code></td>
<td align="left">声明并初始化一个 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data)</code></td>
<td align="left">动态初始化一个 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_schedule(struct tasklet_struct *t)</code></td>
<td align="left">调度一个普通优先级的 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_hi_schedule(struct tasklet_struct *t)</code></td>
<td align="left">调度一个高优先级的 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_kill(struct tasklet_struct *t)</code></td>
<td align="left">杀死（取消）一个 tasklet</td>
</tr>
</tbody></table>
<h3 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h3><p>本次实验是基于实验一中的代码进行编写，我们首先分析需要将哪部分的代码放在中断的下半部分，按键消抖和状态检测不需要在中断上半部立即执行，因为它们<strong>非紧急处理</strong>。</p>
<p><strong>主要的代码分析：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;&#125;</span><br><span class="line">tasklet_init(&amp;dev-&gt;tasklet, key_tasklet_func, (<span class="type">unsigned</span> <span class="type">long</span>)dev);<span class="comment">//初始化</span></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;tasklet);<span class="comment">//中断服务函数的最后调用</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span>  <span class="comment">/* 新增：软中断相关头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>				<span class="comment">/* GPIO描述符 */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span> <span class="comment">/* platform设备 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span> <span class="comment">/* 新增：tasklet软中断结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新增：软中断处理函数，替代原来的定时器函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)data;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 延时一小段时间进行消抖 */</span></span><br><span class="line">	udelay(<span class="number">10000</span>);  <span class="comment">/* 10ms延时 */</span></span><br><span class="line">	</span><br><span class="line">	value = gpiod_get_value(keydesc-&gt;gpiod); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description		: 中断服务函数，触发软中断处理</span></span><br><span class="line"><span class="comment"> * @param - irq 	: 中断号 </span></span><br><span class="line"><span class="comment"> * @param - dev_id	: 设备结构。</span></span><br><span class="line"><span class="comment"> * @return 			: 中断执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 触发软中断，替代原来的定时器 */</span></span><br><span class="line">	tasklet_schedule(&amp;dev-&gt;tasklet);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 按键IO初始化</span></span><br><span class="line"><span class="comment"> * @param - dev	: 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="keyword">struct</span> imx6uirq_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span> =</span> &amp;dev-&gt;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用devm_gpiod_get获取GPIO描述符 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod = devm_gpiod_get(pdev, <span class="string">&quot;key&quot;</span>, GPIOD_IN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod)) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用platform_get_irq获取中断号 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum = platform_get_irq(dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化key描述 */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;irqkeydesc[<span class="number">0</span>].name, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key0: gpio=%d, irqnum=%d\r\n&quot;</span>, </span><br><span class="line">	       desc_to_gpio(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod), </span><br><span class="line">	       dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	ret = devm_request_irq(pdev, dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].handler, </span><br><span class="line">	                      IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].name, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;irq %d request failed!\r\n&quot;</span>, </span><br><span class="line">		        dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化tasklet软中断，替代原来的定时器初始化 */</span></span><br><span class="line">	tasklet_init(&amp;dev-&gt;tasklet, key_tasklet_func, (<span class="type">unsigned</span> <span class="type">long</span>)dev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> imx6uirq_dev, cdev);</span><br><span class="line">	filp-&gt;private_data = dev;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : 从设备读取数据 </span></span><br><span class="line"><span class="comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment">  * @param - buf     : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment">  * @param - cnt     : 要读取的数据长度</span></span><br><span class="line"><span class="comment">  * @param - offt    : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment">  * @return          : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span>	</span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的probe函数，驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1、分配设备结构体 */</span></span><br><span class="line">	dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6uirq_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dev-&gt;pdev = pdev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;major) &#123;</span><br><span class="line">		dev-&gt;devid = MKDEV(dev-&gt;major, <span class="number">0</span>);</span><br><span class="line">		ret = register_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;dev-&gt;devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		dev-&gt;major = MAJOR(dev-&gt;devid);</span><br><span class="line">		dev-&gt;minor = MINOR(dev-&gt;devid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_devid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、注册字符设备 */</span></span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;imx6uirq_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_cdev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;class);</span><br><span class="line">		<span class="keyword">goto</span> fail_class;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dev-&gt;device = device_create(dev-&gt;class, <span class="literal">NULL</span>, dev-&gt;devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;device);</span><br><span class="line">		<span class="keyword">goto</span> fail_device;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、初始化按键 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);</span><br><span class="line">	ret = keyio_init(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_keyinit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 7、保存设备结构体到平台设备中 */</span></span><br><span class="line">	platform_set_drvdata(pdev, dev);</span><br><span class="line">	</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;imx6uirq driver probe success\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">fail_keyinit:</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">fail_device:</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">fail_class:</span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的remove函数，移除platform驱动时此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 销毁tasklet软中断，替代原来的删除定时器 */</span></span><br><span class="line">	tasklet_kill(&amp;dev-&gt;tasklet);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注销字符设备 */</span></span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx6uirq_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;kevin,key&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, imx6uirq_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6uirq_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6uirq&quot;</span>,</span><br><span class="line">		.of_match_table = imx6uirq_of_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6uirq_probe,</span><br><span class="line">	.remove = imx6uirq_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(imx6uirq_init);</span><br><span class="line">module_exit(imx6uirq_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kevin&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>工作队列（Workqueue）</strong> 就是一种非常常用的将工作推后到<strong>进程上下文</strong>中执行的方法。</p>
<p>它的核心思想是：</p>
<ol>
<li><p>你把一个想要推后执行的任务（函数）包装成一个<strong>工作（work）</strong>。</p>
</li>
<li><p>将这个工作提交到一个<strong>队列（queue）</strong> 中。</p>
</li>
<li><p>内核会有一个或多个专用的内核线程（称为<strong>工作者线程，worker thread</strong>）被创建来处理这个队列。</p>
</li>
<li><p>当线程被调度时，它会从队列中取出工作并执行其中指定的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的工作 (work) ---&gt; 被加入 ---&gt; 工作队列 (workqueue) ---&gt; 由 ---&gt; 工作者线程 (worker thread) 处理</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>执行上下文</strong>：<strong>进程上下文</strong>。由专门的内核线程(<code>kworker</code>)来执行其工作函数。</li>
<li><strong>抢占与睡眠</strong>：<strong>可以睡眠&#x2F;阻塞</strong>！这是它与前两者最根本的区别。因为它运行在进程上下文，可以被调度器抢占，也可以调用<code>schedule()</code>主动让出CPU，或者等待信号量、分配内存时阻塞。</li>
<li><strong>并发性</strong>：默认情况下，工作项（work）会被排入一个全局队列，由某个<code>kworker</code>线程执行，并发性由锁控制。也有并发工作队列（<code>CMWQ</code>）等更先进的机制来精细控制并发度。</li>
<li><strong>执行延迟</strong>：<strong>延迟相对较高</strong>。因为它需要唤醒一个内核线程，然后由调度器来分配CPU时间片，这比直接在中退出路径上执行的软中断&#x2F; tasklet 要慢。</li>
<li><strong>动态分配</strong>：可以动态创建。可以创建自己的专用工作队列线程，也可以使用内核共享的默认工作队列。</li>
<li><strong>机制</strong>：通过 <code>schedule_work()</code> 调度到默认队列，或 <code>queue_work()</code> 到自定义队列。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要<strong>睡眠</strong>的任务。这是选择工作队列的<strong>最决定性因素</strong>。</li>
<li>需要<strong>执行大量、耗时操作</strong>的任务（如大数据块IO、文件系统操作）。</li>
<li>典型例子：驱动需要与用户空间交互（这可能需要等待）、需要分配可能阻塞的内存（<code>GFP_KERNEL</code>）、需要等待磁盘IO完成。</li>
</ul>
<h3 id="工作队列的运行模式"><a href="#工作队列的运行模式" class="headerlink" title="工作队列的运行模式"></a>工作队列的运行模式</h3><ul>
<li><p><strong>单线程式 (Single-threaded)</strong>：所有提交到某个工作队列的工作都由<strong>同一个</strong>内核线程处理。这意味着工作是串行执行的，一个接一个。</p>
<p><img src="image-20250903222052475.png" alt="image-20250903222052475"></p>
</li>
<li><p><strong>多线程式 (Multi-threaded)</strong>：工作可以由<strong>多个</strong>内核线程处理（例如，每个CPU一个线程，或者为不同类型的任务创建不同优先级的线程池）。这允许工作在多个CPU上<strong>并发</strong>执行，提高了吞吐量。</p>
<p><img src="image-20250903222104650.png" alt="image-20250903222104650"></p>
</li>
</ul>
<h3 id="工作队列的弊端"><a href="#工作队列的弊端" class="headerlink" title="工作队列的弊端"></a>工作队列的弊端</h3><p><strong>工作项（work item）的延迟执行和阻塞</strong>。</p>
<img src="image-20250903222213819.png" alt="image-20250903222213819" style="zoom:50%;">

<p><strong>场景分析：</strong></p>
<ul>
<li>有三个工作项 <code>w0</code>, <code>w1</code>, <code>w2</code> 被加入到<strong>同一个</strong>工作队列（绑定到同一个CPU）。</li>
<li><code>w0</code> 先执行：<ul>
<li><code>0-5ms</code>: 占用CPU（执行计算）。</li>
<li><code>5-15ms</code>: <strong>睡眠（sleep）</strong>。这是关键！因为它运行在<strong>同一个</strong>工作者线程中，所以当 <code>w0</code> 睡眠时，整个线程都被挂起了。</li>
<li><code>15-20ms</code>: 醒来继续占用CPU直到结束。</li>
</ul>
</li>
<li><code>w0</code> 在 <code>20ms</code> 结束后，线程才开始处理 <code>w1</code>。</li>
<li>同理，<code>w1</code> 的睡眠又阻塞了 <code>w2</code> 的执行</li>
</ul>
<p><strong>结论：<strong>因为 <code>w0</code>, <code>w1</code>, <code>w2</code> 共享同一个执行线程，所以任何一个工作的</strong>睡眠或长时间操作</strong>都会<strong>阻塞</strong>后续所有工作的执行。这会导致其他工作的处理产生不可预测的<strong>延迟（latency）</strong>。</p>
<h3 id="工作队列的API函数"><a href="#工作队列的API函数" class="headerlink" title="工作队列的API函数"></a>工作队列的API函数</h3><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">参数</th>
<th align="left">作用</th>
<th align="left">返回值&#x2F;注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DECLARE_WORK(name, func)</code></strong></td>
<td align="left"><code>name</code>: <strong>struct work_struct</strong> 变量名 <code>func</code>: 要执行的下半部函数 (<strong>void (*func)(struct work_struct *work)</strong>)</td>
<td align="left"><strong>静态地</strong>声明并初始化一个工作结构体。通常在文件全局或结构体内部使用。</td>
<td align="left">宏。声明一个名为 <code>name</code> 的 work_struct。</td>
</tr>
<tr>
<td align="left"><strong><code>INIT_WORK(work, func)</code></strong></td>
<td align="left"><code>work</code>: 指向已存在的 <strong>struct work_struct</strong> 的指针 <code>func</code>: 下半部函数</td>
<td align="left"><strong>动态地</strong>初始化一个已经分配好的工作结构体（例如，在你自己定义的设备结构体中）。</td>
<td align="left">宏。通常在 <code>kmalloc</code> 或 <code>devm_kzalloc</code> 分配内存后调用。</td>
</tr>
<tr>
<td align="left"><strong><code>schedule_work(work)</code></strong></td>
<td align="left"><code>work</code>: 指向已初始化的 <strong>struct work_struct</strong> 的指针</td>
<td align="left">将工作提交到<strong>系统共享的全局工作队列（system_wq）</strong>。工作者线程会在稍后某个时间执行它。</td>
<td align="left"><strong>返回：</strong> int <code>0</code>： 工作已在队列中，未重复添加。 非 <code>0</code>： 工作已成功添加到队列等待执行。</td>
</tr>
<tr>
<td align="left"><strong><code>cancel_work_sync(work)</code></strong></td>
<td align="left"><code>work</code>: 指向要取消的 <strong>struct work_struct</strong> 的指针</td>
<td align="left"><strong>取消一个已排队但尚未开始执行的工作</strong>。如果工作已经开始执行，则函数会等待其执行完毕。<strong>防止竞争的必要措施。</strong></td>
<td align="left"><strong>注意：</strong> 必须确保在之后工作不会再被调度（例如，在模块卸载或设备断开时调用）。不能在中断上下文使用。</td>
</tr>
</tbody></table>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testwork_func_t</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度work */</span></span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化work */</span></span><br><span class="line">INIT_WORK(&amp;testwork, <span class="type">testwork_func_t</span>);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟工作队列"><a href="#延迟工作队列" class="headerlink" title="延迟工作队列"></a>延迟工作队列</h2><h3 id="api函数"><a href="#api函数" class="headerlink" title="api函数"></a>api函数</h3><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">参数</th>
<th align="left">作用</th>
<th align="left">返回值&#x2F;注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DECLARE_DELAYED_WORK(name, func)</code></strong></td>
<td align="left"><code>name</code>: <strong>struct delayed_work</strong> 变量名 <code>func</code>: 下半部函数</td>
<td align="left"><strong>静态地</strong>声明并初始化一个<strong>延迟</strong>工作结构体。</td>
<td align="left">宏。<code>struct delayed_work</code> 内部包含了一个普通的 <code>work_struct</code> 和一个定时器。</td>
</tr>
<tr>
<td align="left"><strong><code>INIT_DELAYED_WORK(work, func)</code></strong></td>
<td align="left"><code>work</code>: 指向已存在的 <strong>struct delayed_work</strong> 的指针 <code>func</code>: 下半部函数</td>
<td align="left"><strong>动态地</strong>初始化一个已经分配好的<strong>延迟</strong>工作结构体。</td>
<td align="left">宏。</td>
</tr>
<tr>
<td align="left"><strong><code>schedule_delayed_work(dwork, delay)</code></strong></td>
<td align="left"><code>dwork</code>: 指向已初始化的 <strong>struct delayed_work</strong> 的指针 <code>delay</code>: 延迟的时间，单位是 <strong>jiffies</strong></td>
<td align="left">将工作提交到系统共享的全局工作队列，并指定一个<strong>延迟</strong>。工作者线程会在 <code>delay</code> 时间之后才执行它。</td>
<td align="left"><strong>返回：</strong> int <code>0</code>： 失败（工作已在队列中）。 非 <code>0</code>： 成功。 <strong>提示：</strong> 可用 <code>msecs_to_jiffies(ms)</code> 将毫秒转换为 jiffies。</td>
</tr>
<tr>
<td align="left"><strong><code>flush_delayed_work(dwork)</code></strong></td>
<td align="left"><code>dwork</code>: 指向 <strong>struct delayed_work</strong> 的指针</td>
<td align="left"><strong>刷新</strong>延迟工作。等待一个已经排队的延迟工作执行完毕。如果延迟尚未到期，它会先取消延迟，然后立即将工作放入队列执行，并等待其完成。</td>
<td align="left"><strong>返回：</strong> bool <code>false</code>： 工作未在执行，已被刷新。 <code>true</code>： 工作正在执行，函数等待其完成。</td>
</tr>
<tr>
<td align="left"><strong><code>cancel_delayed_work_sync(dwork)</code></strong></td>
<td align="left"><code>dwork</code>: 指向要取消的 <strong>struct delayed_work</strong> 的指针</td>
<td align="left"><strong>取消一个已排队的延迟工作</strong>。如果工作已经在执行，则等待其执行完毕。<strong>防止竞争的必要措施。</strong></td>
<td align="left">与 <code>cancel_work_sync</code> 类似，但用于延迟工作。</td>
</tr>
</tbody></table>
<h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><p>本实验是在实验一的基础上进行改进的，</p>
<ol>
<li>按键消抖本质上就是一个需要延迟执行的任务</li>
<li>使用<code>delayed_work</code>可以直接替代定时器，代码更简洁</li>
<li>内核的延时工作队列机制已经优化得很好，性能足够</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span> <span class="comment">// 可以删除，但保留以防其他依赖</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">// 添加工作队列头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>				<span class="comment">/* GPIO描述符 */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span> <span class="comment">/* platform设备 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">key_work</span>;</span> <span class="comment">/* 按键消抖工作项 */</span> <span class="comment">// 替换 timer_list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description	: 工作队列处理函数，用于按键消抖</span></span><br><span class="line"><span class="comment"> * @param - work: 工作项</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(to_delayed_work(work), </span><br><span class="line">						<span class="keyword">struct</span> imx6uirq_dev, key_work);</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpiod_get_value(keydesc-&gt;gpiod); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description		: 中断服务函数，调度延迟工作队列进行按键消抖</span></span><br><span class="line"><span class="comment"> * @param - irq 	: 中断号 </span></span><br><span class="line"><span class="comment"> * @param - dev_id	: 设备结构。</span></span><br><span class="line"><span class="comment"> * @return 			: 中断执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	schedule_delayed_work(&amp;dev-&gt;key_work, msecs_to_jiffies(<span class="number">10</span>)); <span class="comment">/* 10ms后执行工作队列 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 按键IO初始化</span></span><br><span class="line"><span class="comment"> * @param - dev	: 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="keyword">struct</span> imx6uirq_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span> =</span> &amp;dev-&gt;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用devm_gpiod_get获取GPIO描述符 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod = devm_gpiod_get(pdev, <span class="string">&quot;key&quot;</span>, GPIOD_IN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod)) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用platform_get_irq获取中断号 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum = platform_get_irq(dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化key描述 */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;irqkeydesc[<span class="number">0</span>].name, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化延迟工作队列 */</span></span><br><span class="line">	INIT_DELAYED_WORK(&amp;dev-&gt;key_work, key_work_handler);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key0: gpio=%d, irqnum=%d\r\n&quot;</span>, </span><br><span class="line">	       desc_to_gpio(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod), </span><br><span class="line">	       dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	ret = devm_request_irq(pdev, dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].handler, </span><br><span class="line">	                      IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].name, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;irq %d request failed!\r\n&quot;</span>, </span><br><span class="line">		        dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> imx6uirq_dev, cdev);</span><br><span class="line">	filp-&gt;private_data = dev;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : 从设备读取数据 </span></span><br><span class="line"><span class="comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment">  * @param - buf     : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment">  * @param - cnt     : 要读取的数据长度</span></span><br><span class="line"><span class="comment">  * @param - offt    : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment">  * @return          : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span>	</span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的probe函数，驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1、分配设备结构体 */</span></span><br><span class="line">	dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6uirq_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dev-&gt;pdev = pdev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;major) &#123;</span><br><span class="line">		dev-&gt;devid = MKDEV(dev-&gt;major, <span class="number">0</span>);</span><br><span class="line">		ret = register_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;dev-&gt;devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		dev-&gt;major = MAJOR(dev-&gt;devid);</span><br><span class="line">		dev-&gt;minor = MINOR(dev-&gt;devid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_devid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、注册字符设备 */</span></span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;imx6uirq_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_cdev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;class);</span><br><span class="line">		<span class="keyword">goto</span> fail_class;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dev-&gt;device = device_create(dev-&gt;class, <span class="literal">NULL</span>, dev-&gt;devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;device);</span><br><span class="line">		<span class="keyword">goto</span> fail_device;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、初始化按键 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);</span><br><span class="line">	ret = keyio_init(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_keyinit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 7、保存设备结构体到平台设备中 */</span></span><br><span class="line">	platform_set_drvdata(pdev, dev);</span><br><span class="line">	</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;imx6uirq driver probe success\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">fail_keyinit:</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">fail_device:</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">fail_class:</span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的remove函数，移除platform驱动时此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 取消延迟工作队列 */</span></span><br><span class="line">	cancel_delayed_work_sync(&amp;dev-&gt;key_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注销字符设备 */</span></span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx6uirq_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;kevin,key&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, imx6uirq_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6uirq_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6uirq&quot;</span>,</span><br><span class="line">		.of_match_table = imx6uirq_of_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6uirq_probe,</span><br><span class="line">	.remove = imx6uirq_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(imx6uirq_init);</span><br><span class="line">module_exit(imx6uirq_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kevin&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="CMWQ工作队列"><a href="#CMWQ工作队列" class="headerlink" title="CMWQ工作队列"></a>CMWQ工作队列</h2><p><strong>Concurrency Managed Workqueue</strong>，即<strong>并发托管的工作队列</strong>。</p>
<p>CMWQ 的核心思想是<strong>将工作项的提交（生产者）与工作线程的管理（消费者）完全分离</strong>。开发者只需关心将工作项提交到哪个工作队列，而内核则负责以最优化、最高效的方式动态管理执行这些工作项所需的线程（称为 worker）及其并发度。</p>
<p><img src="image-20250903225324180.png" alt="image-20250903225324180"></p>
<p><strong>目的：</strong></p>
<ul>
<li><strong>线程浪费</strong>：每个工作队列（workqueue）都有自己的专用线程（<code>kworker</code>）。如果系统中有很多驱动都创建了自己的工作队列，就会产生大量大部分时间都在休眠的线程，浪费资源。</li>
<li><strong>并发性差</strong>：传统的每CPU工作队列，其并发度是固定的（通常是每CPU一个线程）。如果一个工作项阻塞（如工作队列小节的图片中 <code>w0</code> 睡眠），那么该CPU上该队列的所有后续工作项都会被阻塞，即使系统有其他空闲的CPU核心也无法帮忙处理。</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li><strong>线程池化（Thread Pooling）</strong><ul>
<li>内核预先创建好一组通用的工作线程（<code>kworker/uX:Y</code> 和 <code>kworker/uX:Y</code>），称为 <strong>worker_pool</strong>。</li>
<li>所有通过 CMWQ API（如 <code>schedule_work()</code> ）提交的工作项，最终都由这个共享的线程池来处理。</li>
<li><strong>好处</strong>：极大地减少了系统内核线程的数量，节省了内存和上下文切换的开销。</li>
</ul>
</li>
<li><strong>动态并发管理（Dynamic Concurrency Management）</strong><ul>
<li>这是“并发托管”中“托管”的含义。内核会<strong>自动管理</strong>执行工作项所需的线程数量。</li>
<li><strong>规则</strong>：只要有一个可运行（runnable）的工作项，内核就会尝试提供一个空闲的线程来执行它。如果没有空闲线程，内核可以根据需要<strong>动态创建新的线程</strong>。</li>
<li><strong>好处</strong>：<ul>
<li><strong>避免阻塞</strong>：如果一个工作线程在某个工作项上阻塞（比如调用了 <code>msleep</code>），内核会检测到该线程休眠，并立即唤醒或创建另一个线程来执行同一队列上的其他工作项。这直接解决了你图片中 <code>w0</code> 阻塞 <code>w1</code> 和 <code>w2</code> 的问题。</li>
<li><strong>自动扩展</strong>：在高负载下，线程池会扩大以处理更多工作；在空闲时，多余的线程会被自动回收。</li>
</ul>
</li>
</ul>
</li>
<li><strong>向后兼容的API</strong><ul>
<li>最棒的一点是，<strong>开发者几乎不需要修改现有代码</strong>。像 <code>schedule_work()</code>, <code>INIT_WORK()</code> 这样的API保持不变，但它们底层已经使用了CMWQ机制。</li>
<li>旧的函数如 <code>create_workqueue()</code> 被重写为基于CMWQ的兼容层，但建议使用新的 <code>alloc_workqueue()</code> 函数来显式创建具有特定属性（如并发度限制）的工作队列。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">旧工作队列 (Pre-CMWQ)</th>
<th align="left">CMWQ (并发托管工作队列)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">每工作队列专用线程</td>
<td align="left"><strong>共享线程池</strong></td>
</tr>
<tr>
<td align="left"><strong>线程数量</strong></td>
<td align="left">静态，与工作队列数量成正比</td>
<td align="left"><strong>动态</strong>，根据负载扩展和收缩</td>
</tr>
<tr>
<td align="left"><strong>并发管理</strong></td>
<td align="left">固定（通常每CPU一个线程）</td>
<td align="left"><strong>自动、动态</strong>管理，避免饥饿和阻塞</td>
</tr>
<tr>
<td align="left"><strong>资源效率</strong></td>
<td align="left">低效，线程可能大量空闲</td>
<td align="left"><strong>高效</strong>，线程被充分共享和利用</td>
</tr>
<tr>
<td align="left"><strong>API</strong></td>
<td align="left"><code>create_workqueue()</code>等</td>
<td align="left"><code>alloc_workqueue()</code>，<strong>兼容旧API</strong></td>
</tr>
<tr>
<td align="left"><strong>解决阻塞</strong></td>
<td align="left"><strong>无法解决</strong>，一个阻塞会阻塞整个队列</td>
<td align="left"><strong>完美解决</strong>，阻塞后自动创建新线程</td>
</tr>
</tbody></table>
<img src="deepseek_mermaid_20250903_266727.png" alt="deepseek_mermaid_20250903_266727" style="zoom:33%;">

<ol>
<li><p><strong>工作队列（workqueue）层 - 生产者接口</strong></p>
<ul>
<li>这是开发者直接交互的层面。工作队列（如 <code>system_wq</code>, <code>system_highpri_wq</code> 或用户用 <code>alloc_workqueue()</code> 创建的队列）充当工作项（<code>work_struct</code>）的容器。</li>
<li>每个工作队列可以定义自己的属性，最最重要的是 <code>max_active</code>，它限制了该工作队列<strong>每个CPU</strong>上最多可以同时执行的工作项数量。这提供了对并发度的精细控制。</li>
</ul>
</li>
<li><p><strong>worker_pool 层 - 核心资源管理</strong></p>
<ul>
<li>这是CMWQ的“大脑”。内核为每个CPU（和一些特殊场景）创建了一组 <strong>worker_pool</strong>。</li>
<li><strong>绑定到特定CPU的worker_pool</strong>： 这是最常见的类型。例如，每个CPU都有两个worker_pool：一个用于普通优先级工作（<code>kworker/uX:Y</code>），一个用于高优先级工作（<code>kworker/uX:Y</code>）。</li>
<li><strong>Unbound worker_pool</strong>： 用于那些不需要绑定特定CPU、且可能长时间运行的任务。它们的线程可以运行在任何CPU上，名字如 <code>kworker/uX:Y</code>。</li>
<li><strong>工作项最终会被派发到某个worker_pool</strong>。例如，通过 <code>schedule_work()</code> 提交的普通工作，会被派发到当前CPU的普通优先级worker_pool。</li>
</ul>
</li>
<li><p><strong>工作者线程（worker）层 - 消费者执行单元</strong></p>
<ul>
<li>这是真正执行代码的线程，即 <code>kworker</code> 线程。</li>
<li>它们由内核动态地从 <strong>worker_pool</strong> 中管理。当一个worker_pool中有工作项需要处理时：<ul>
<li>如果有空闲的worker线程，它会被唤醒去处理工作。</li>
<li>如果没有空闲worker且当前活跃worker数未达到上限，内核会创建一个新的worker线程。</li>
<li>如果一个worker线程在执行工作项时进入睡眠（阻塞），内核会立即感知到，并可能创建新的worker来处理同一worker_pool中的其他工作项（这就是解决阻塞问题的关键）。</li>
<li>当worker处理完工作后，它会保持一段时间空闲。如果一直没新工作，它会被内核自动销毁，从而释放资源。</li>
</ul>
</li>
</ul>
<img src="image-20250903224808412.png" alt="image-20250903224808412" style="zoom:50%;">

<img src="image-20250903224825722.png" alt="image-20250903224825722" style="zoom:50%;">

<p>通过图片我们可以知道：</p>
</li>
<li><p>用户通过 <code>alloc_workqueue</code> 创建<strong>工作队列</strong>时，需要指定 <code>flags</code> 参数（如 <code>WQ_UNBOUND</code>, <code>WQ_HIGHPRI</code>）。</p>
</li>
<li><p>这个 <code>flags</code> 参数决定了该工作队列中的工作项将被分配到哪种<strong>类型的线程池</strong>（前端与后端的绑定）。</p>
</li>
<li><p><strong><code>max_active</code></strong>：这是一个极其重要的参数。它限制了<strong>每个 CPU</strong> 上可以同时并发执行（处于 <code>running</code> 状态）的该工作队列的工作项数量。它实现了对并发度的精细控制。</p>
</li>
<li><p>这展示了 <strong>CMWQ 将 <code>max_active</code> 设置为大于等于工作项数量</strong>时的效果。内核线程池会提供足够的线程，使得三个工作项<strong>几乎完全并发</strong>地执行：</p>
<ul>
<li><code>w0</code> 睡眠时，<code>w1</code> 和 <code>w2</code> 立即开始运行。</li>
<li>所有工作项在 <strong>25ms</strong> 内完成，效率提升一倍！</li>
</ul>
</li>
</ol>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p><strong>中断线程化（Threaded IRQs）</strong> 是一种将中断处理程序（Interrupt Handler）的大部分工作转移到内核线程中执行的技术。它将一个中断的处理分为两部分：</p>
<ol>
<li><strong>硬中断处理程序（Hard IRQ Handler）</strong>：在<strong>中断上下文</strong>中执行，要求快速、不可休眠。它只负责最紧急的任务（如读取状态寄存器、清除中断标志），然后通知内核需要调度对应的线程。</li>
<li><strong>中断线程（Threaded IRQ Handler）</strong>：在<strong>进程上下文</strong>中执行，作为一个独立的内核线程运行。它负责处理中断大部分耗时的、可能休眠的操作。</li>
</ol>
<p>简单来说，中断线程化就是把一个中断“转换”成了一个由中断信号触发的、特殊的内核线程。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>本质</strong>：它<strong>不是传统意义上的底半部</strong>，而是一种<strong>全新的中断处理模型</strong>。它将整个中断处理过程（相当于顶半部+底半部）都放到了一个内核线程中执行。</li>
<li><strong>执行上下文</strong>：<strong>进程上下文</strong>。</li>
<li><strong>抢占与睡眠</strong>：<strong>可以睡眠&#x2F;阻塞</strong>（在线程化的handler部分）。</li>
<li><strong>并发性</strong>：每个中断线程可以有自己的调度策略和优先级。</li>
<li><strong>执行延迟</strong>：顶半部变得极短（只是一个唤醒线程的信号），真正的处理在线程中完成，延迟高于软中断&#x2F;tasklet。</li>
<li><strong>优先级</strong>：可以给中断线程设置<strong>实时优先级</strong>，从而提供<strong>确定性的响应</strong>，这对实时系统（PREEMPT_RT）至关重要。</li>
<li><strong>机制</strong>：使用 <code>request_threaded_irq()</code> 申请中断，并指定一个“线程化处理函数”。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>实时系统 (PREEMPT_RT Patch)</strong>：其主要目标就是将所有中断线程化，以减少关中断时间，提供更好的系统实时性。</li>
<li>需要为中断处理提供<strong>明确的调度优先级</strong>。</li>
<li>简化驱动设计，整个中断处理流程都可以在一个可以睡眠的上下文中完成，无需再区分顶半部和底半部。</li>
</ul>
<h3 id="api函数-1"><a href="#api函数-1" class="headerlink" title="api函数"></a>api函数</h3><p><strong>核心函数：<code>request_threaded_irq</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                        <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                        <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>irq</code></td>
<td align="left"><code>unsigned int</code></td>
<td align="left">要申请的中断号。</td>
</tr>
<tr>
<td align="left"><code>handler</code></td>
<td align="left"><code>irq_handler_t</code></td>
<td align="left"><strong>（硬中断处理函数）</strong> 在中断上下文中运行的函数。它的职责是进行最快速的处理，然后决定是否需要唤醒中断线程。</td>
</tr>
<tr>
<td align="left"><code>thread_fn</code></td>
<td align="left"><code>irq_handler_t</code></td>
<td align="left"><strong>（中断线程处理函数）</strong> 在进程上下文（内核线程）中运行的函数。负责处理中断的主要工作。</td>
</tr>
<tr>
<td align="left"><code>flags</code></td>
<td align="left"><code>unsigned long</code></td>
<td align="left">中断标志。与 <code>request_irq</code> 的标志类似，但有一些用于线程化中断的特殊标志。</td>
</tr>
<tr>
<td align="left"><code>name</code></td>
<td align="left"><code>const char *</code></td>
<td align="left">中断名称，会在 <code>/proc/interrupts</code> 中显示。同时也是中断线程名的前缀。</td>
</tr>
<tr>
<td align="left"><code>dev</code></td>
<td align="left"><code>void *</code></td>
<td align="left">传递给处理程序的设备标识符，通常是设备结构体的指针。</td>
</tr>
</tbody></table>
<p><strong><code>handler</code> 和 <code>thread_fn</code> 的返回值</strong></p>
<p>这两个函数的返回值都是 <code>irqreturn_t</code> 类型：</p>
<ul>
<li><code>IRQ_NONE</code>: 表示这不是本设备发出的中断，未处理。</li>
<li><code>IRQ_HANDLED</code>: 表示中断已处理。</li>
<li><strong><code>IRQ_WAKE_THREAD</code></strong>: <strong>这是关键</strong>。<code>handler</code> 函数如果返回此值，内核就会唤醒对应的 <code>thread_fn</code> 线程来执行。如果 <code>handler</code> 为 <code>NULL</code>，内核会默认返回 <code>IRQ_WAKE_THREAD</code>。</li>
</ul>
<h3 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h3><p><strong>伪代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="comment">// ... 其他设备数据 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬中断处理函数（可选，如果为NULL则默认唤醒线程） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_hardirq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 快速读取状态寄存器确认中断 */</span></span><br><span class="line">    <span class="comment">/* 2. 清除中断标志（非常重要！） */</span></span><br><span class="line">    <span class="comment">/* 3. 如果需要线程处理，返回 IRQ_WAKE_THREAD */</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断线程处理函数（主要工作在这里完成） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_thread_fn</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里可以处理复杂逻辑，甚至可以休眠！ */</span></span><br><span class="line">    <span class="comment">// msleep(10); // 这是允许的！</span></span><br><span class="line">    <span class="comment">// mutex_lock(&amp;my_mutex); // 这也是允许的！</span></span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Processing interrupt in thread context for device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">int</span> irq, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 设备初始化 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请线程化中断 */</span></span><br><span class="line">    ret = request_threaded_irq(irq, </span><br><span class="line">                              my_hardirq_handler,  <span class="comment">// 硬中断处理函数</span></span><br><span class="line">                              my_thread_fn,        <span class="comment">// 线程处理函数</span></span><br><span class="line">                              IRQF_ONESHOT,        <span class="comment">// 必须的标志</span></span><br><span class="line">                              <span class="string">&quot;my-threaded-irq&quot;</span>, </span><br><span class="line">                              dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to request threaded IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作流程</strong></p>
<ol>
<li><strong>硬件中断发生</strong>，CPU 跳转到对应的中断向量。</li>
<li>内核调用为该中断号注册的<strong>硬中断处理程序 (<code>handler</code>)</strong>。</li>
<li><code>handler</code> 函数执行（在中断上下文）：<ul>
<li>读取硬件状态，确认是本设备中断。</li>
<li>清除中断源（防止再次触发）。</li>
<li>返回 <code>IRQ_WAKE_THREAD</code>。</li>
</ul>
</li>
<li>内核唤醒与该中断关联的<strong>内核线程</strong>。</li>
<li>该内核线程开始执行<strong>中断线程处理程序 (<code>thread_fn</code>)</strong>（在进程上下文）：<ul>
<li>执行所有耗时操作（如处理数据、唤醒进程、访问可能休眠的硬件等）。</li>
<li>返回 <code>IRQ_HANDLED</code>。</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">软中断 (Softirq)</th>
<th align="left">Tasklet</th>
<th align="left">工作队列 (Workqueue)</th>
<th align="left">中断线程 (Threaded IRQ)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>执行上下文</strong></td>
<td align="left">软中断上下文</td>
<td align="left">软中断上下文</td>
<td align="left"><strong>进程上下文</strong></td>
<td align="left"><strong>进程上下文</strong></td>
</tr>
<tr>
<td align="left"><strong>可否睡眠</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>并发性</strong></td>
<td align="left">高，同类型可多CPU并发</td>
<td align="left">低，同类型串行执行</td>
<td align="left">可配置，默认共享</td>
<td align="left">每个中断一个线程</td>
</tr>
<tr>
<td align="left"><strong>执行延迟</strong></td>
<td align="left"><strong>极低</strong></td>
<td align="left"><strong>低</strong></td>
<td align="left">较高</td>
<td align="left">较高（但响应确定）</td>
</tr>
<tr>
<td align="left"><strong>编程复杂度</strong></td>
<td align="left"><strong>高</strong>（需处理自旋锁）</td>
<td align="left">低（无需复杂锁）</td>
<td align="left">低（可使用睡眠锁）</td>
<td align="left">低（可使用睡眠锁）</td>
</tr>
<tr>
<td align="left"><strong>机制</strong></td>
<td align="left">静态，编译时定义</td>
<td align="left">动态，基于软中断</td>
<td align="left">动态，内核线程执行</td>
<td align="left">动态，内核线程执行</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">网络、块设备、定时器</td>
<td align="left"><strong>大多数设备驱动</strong></td>
<td align="left">可睡眠的耗时任务</td>
<td align="left"><strong>实时系统</strong>，需优先级调度</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/05/10/kernel-intc-ch4/">https://leonardo272.github.io/2025/05/10/kernel-intc-ch4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux%E5%86%85%E6%A0%B8/">linux内核</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E6%96%AD/">中断</a></div><div class="post-share"><div class="social-share" data-image="/page_images/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/13/0009/" title="驱动开发-图形化编译内核与系统自带驱动的添加"><img class="cover" src="/page_images/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">驱动开发-图形化编译内核与系统自带驱动的添加</div></div><div class="info-2"><div class="info-item-1">1.配置linux自带的驱动使能1.1图形化配置要使用 Linux内核自带的 LED灯驱动首先得先配置 Linux，输入如下命令打开 Linux配置菜单： 1make menuconfig  按照如下路径打开 LED驱动配置项：  按照上述路径，选择“ LED Support for GPIO connected LEDs”，将其编译进 Linux内核，也即是在此选项上按下“ Y”键，使此选项前面变为 “&lt;*&gt;”：   在“ LED Support for GPIO connected LEDs”上按下 可以打开此选项的帮助信息，   1make -j16    1.2.config文件查看配置 好 Linux内核以后退出配置界面，打开 .config文件，会找到“ CONFIG_LEDS_GPIO&#x3D;y这一行，如图 56.1.3所示：  1.3Makefile文件LED灯驱动文件为 /drivers/leds/leds-gpio.c，大家可以打开 /drivers/leds/Makefile这个文件，  如果定义了 CONFIG_LEDS_GPIO的话就会编...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc/" title="CH1-中断子系统介绍"><img class="cover" src="/page_images/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CH1-中断子系统介绍</div></div><div class="info-2"><div class="info-item-1">中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中断控制器  GIC 是ARM 公司给Cortex-A&#x2F;R 内核提供的一个中断控制器，类似Cortex-M 内核中的NVIC。GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号报给ARM 内核，这四个信号的含义如下：  VFIQ:虚拟快速FIQ。 VIRQ:虚拟外部IRQ。 FIQ:快速中断IRQ。 IRQ:外部中断IRQ。    单核      上图中我们可以看到所有的中断都发送给了GIC控制器，它负责处理各种中断，判断优先级、屏蔽、使能等工作。在GIC控制器中有Distributor、Interface **Distributor(分发器端)：**块负责处理各...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/10/kernel-intc-ch2/" title="CH2-中断处理流程分析"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH2-中断处理流程分析</div></div><div class="info-2"><div class="info-item-1">linux中断处理的流程linux-5.10.4版本：interrupt.h   linux系统启动的流程irq_domainirq_domain 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。 你可以把它想象成一个翻译官或接线总机：  硬件中断号 (HW IRQ)：是中断控制器自己识别的编号。例如，对于 ARM GIC，SGIs 是 0-15，PPIs 是 16-31，SPIs 从 32 开始。这是硬件固定的，不同控制器完全不同。 虚拟中断号 (VIRQ)：是 Linux 内核内部使用的、统一的软件中断编号。驱动开发者请求和使用的就是这个号。  它的作用：  抽象硬件差异 世界上有无数种中断控制器（GIC, APIC, IO-APIC, GPIO 控制器等），每种都有自己的编号方案和编程模型。内核无法为每种控制器都写一套独立的中断处理流程。irq_domain 提供了一个统一的抽象接口，让内核核心代码只需与 irq_domain...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc-ch3/" title="CH3-中断程序的编写"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH3-中断程序的编写</div></div><div class="info-2"><div class="info-item-1">linux中断程序编写中断的API函数request_irq1int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)  **irq：**要申请中断的中断号。 **handler：**中断处理函数，当中断发生以后就会执行此中断处理函数。 **flags：**中断标志，可以在文件include/linux/interrupt.h 里面查看所有的中断标志    标志 描述    IRQF_SHARED 多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话，request_irq 函数的dev参数就是唯一区分他们的标志。   IRQF_ONESHOT 单次中断，中断执行一次就结束。   IRQF_TRIGGER_NONE 无触发。   IRQF_TRIGGER_RISING 上升沿触发。   IRQF_TRIGGER_FALLING 下降沿触发。   IRQF_TRIGGER_HIGH 高电平触发。   IRQF_T...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc/" title="CH1-中断子系统介绍"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH1-中断子系统介绍</div></div><div class="info-2"><div class="info-item-1">中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中断控制器  GIC 是ARM 公司给Cortex-A&#x2F;R 内核提供的一个中断控制器，类似Cortex-M 内核中的NVIC。GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号报给ARM 内核，这四个信号的含义如下：  VFIQ:虚拟快速FIQ。 VIRQ:虚拟外部IRQ。 FIQ:快速中断IRQ。 IRQ:外部中断IRQ。    单核      上图中我们可以看到所有的中断都发送给了GIC控制器，它负责处理各种中断，判断优先级、屏蔽、使能等工作。在GIC控制器中有Distributor、Interface **Distributor(分发器端)：**块负责处理各...</div></div></div></a><a class="pagination-related" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">kernel-sysfs文件系统介绍</div></div><div class="info-2"><div class="info-item-1">sysfs文件系统 sysfs 文件系统的目录  定义：sysfs是一个基于内存的虚拟文件系统（Virtual Filesystem）。它被挂载在 /sys 目录下，是Linux内核中内核对象（kobject）、属性（attribute）和关系（relationship） 的直观体现。 核心作用：sysfs的主要作用是在用户空间（Userspace） 和内核空间（Kernelspace） 之间搭建一座桥梁，提供一个标准化的接口，使得用户空间的程序能够安全、方便地查看和配置内核的运行参数、硬件设备信息、驱动程序状态、电源管理选项等。 具体作用包括：  展示设备层次结构：以目录树的形式清晰地展示系统中总线（bus）、设备（device）、驱动（driver）、类（class）等内核对象的层次关系。 导出对象属性：将内核对象的属性（通常是变量或状态）以普通文件的形式暴露出来。用户可以通过cat命令读取属性，通过echo命令修改属性（如果该属性可写）。 支持用户空间事件：通过poll或select系统调用，用户空间程序可以监听内核发出的事件通知（例如，设备的插拔）。  特点：  层次化结...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%8A%E5%8D%8A%E9%83%A8%E4%B8%8E%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-number">1.</span> <span class="toc-text">中断的上半部与下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%ADAPI%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">软中断API函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">实验三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tasklet"><span class="toc-number">1.2.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">API函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B"><span class="toc-number">1.2.2.</span> <span class="toc-text">实验四</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">工作队列的运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">工作队列的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">工作队列的API函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">延迟工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">api函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94"><span class="toc-number">1.4.2.</span> <span class="toc-text">实验五</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMWQ%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.5.</span> <span class="toc-text">CMWQ工作队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">中断线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">api函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD"><span class="toc-number">1.6.2.</span> <span class="toc-text">实验六</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高危工作环境中人员安全装备佩戴检测系统"/></a><div class="content"><a class="title" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统">高危工作环境中人员安全装备佩戴检测系统</a><time datetime="2025-07-20T14:33:00.000Z" title="发表于 2025-07-20 22:33:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍"><img src="/page_images/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kernel-sysfs文件系统介绍"/></a><div class="content"><a class="title" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍">kernel-sysfs文件系统介绍</a><time datetime="2025-06-15T13:12:00.000Z" title="发表于 2025-06-15 21:12:00">2025-06-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>