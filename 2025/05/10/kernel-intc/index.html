<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kernel-intc | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel-intc">
<meta property="og:url" content="https://leonardo272.github.io/2025/05/10/kernel-intc/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/7.jpg">
<meta property="article:published_time" content="2025-05-10T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-03T15:07:25.624Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "kernel-intc",
  "url": "https://leonardo272.github.io/2025/05/10/kernel-intc/",
  "image": "https://leonardo272.github.io/page_images/7.jpg",
  "datePublished": "2025-05-10T13:12:00.000Z",
  "dateModified": "2025-09-03T15:07:25.624Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/05/10/kernel-intc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kernel-intc',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">kernel-intc</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">kernel-intc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T13:12:00.000Z" title="发表于 2025-05-10 21:12:00">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-03T15:07:25.624Z" title="更新于 2025-09-03 23:07:25">2025-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/">内核学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="中断子系统"><a href="#中断子系统" class="headerlink" title="中断子系统"></a>中断子系统</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。</p>
<h2 id="中断子系统框架"><a href="#中断子系统框架" class="headerlink" title="中断子系统框架"></a>中断子系统框架</h2><p><img src="image-20250901101222885.png" alt="image-20250901101222885"></p>
<ul>
<li><p>CPU</p>
</li>
<li><p>中断控制器</p>
</li>
<li><p>外设</p>
</li>
<li><p>中断向量表</p>
</li>
<li><p>中断号</p>
</li>
<li><p>Linux内核中断子系统</p>
</li>
<li><p>中断编程接口（<code>request_irq</code>接口函数）</p>
</li>
<li><p>具体的外设驱动</p>
</li>
</ul>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><img src="image-20250901102414888.png" alt="image-20250901102414888" style="zoom:50%;">

<p>GIC 是ARM 公司给Cortex-A&#x2F;R 内核提供的一个中断控制器，类似Cortex-M 内核中的NVIC。GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号报给ARM 内核，这四个信号的含义如下：</p>
<ul>
<li>VFIQ:虚拟快速FIQ。</li>
<li>VIRQ:虚拟外部IRQ。</li>
<li>FIQ:快速中断IRQ。</li>
<li>IRQ:外部中断IRQ。</li>
</ul>
<img src="image-20250901102917824.png" alt="image-20250901102917824" style="zoom:50%;">

<center>单核</center>

<img src="image-20250901103251800.png" alt="image-20250901103251800" style="zoom:33%;">

<img src="image-20250901103345111.png" alt="image-20250901103345111" style="zoom:50%;">

<p>上图中我们可以看到所有的中断都发送给了GIC控制器，它负责处理各种中断，判断优先级、屏蔽、使能等工作。在GIC控制器中有Distributor、Interface</p>
<p>**Distributor(分发器端)：**块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个CPU Interface 上去.分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到CPU 接口端</p>
<ul>
<li><p>全局中断使能控制。</p>
</li>
<li><p>控制每一个中断的使能或者关闭。</p>
</li>
<li><p>设置每个中断的优先级。</p>
</li>
<li><p>设置每个中断的目标处理器列表。</p>
</li>
<li><p>设置每个外部中断的触发模式：电平触发或边沿触发。</p>
</li>
<li><p>设置每个中断属于组0 还是组1。</p>
</li>
</ul>
<p>**CPU Interface(CPU 接口端)：**每个CPU Core 都可以在GIC 中找到一个与之对应的CPU Interface,CPU 接口端就是分发器和CPU Core 之间的桥梁</p>
<ul>
<li><p>使能或者关闭发送到CPU Core 的中断请求信号。</p>
</li>
<li><p>应答中断。</p>
</li>
<li><p>通知中断处理完成。</p>
</li>
<li><p>设置优先级掩码，通过掩码来设置哪些中断不需要上报给CPU Core。</p>
</li>
<li><p>定义抢占策略。</p>
</li>
<li><p>当多个中断到来的时候，选择优先级最高的中断通知给CPU Core。</p>
</li>
</ul>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p><img src="image-20250509154927955.png" alt="image-20250509154927955"></p>
<center>GICV2</center>

<p>中断的种类可以分为：</p>
<ul>
<li><code>SPI(Shared Peripheral Interrupt)</code>,<strong>共享外设中断</strong>，顾名思义，<strong>所有的核Core共享的中断</strong>，这个是最常见的，那些外部中断都属于SPI 中断(注意！不是SPI 总线那个中断) 。比如按键中断、串口中断等等，这些中断所有的Core 都可以处理，不限定特定Core</li>
<li><code>PPI(Private Peripheral Interrupt)</code>，<strong>私有外设中断</strong>，我们说了GIC 是支持多核的，<strong>每个核肯定有自己独有的中断</strong>。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。</li>
<li><code>SGI(Software-generated Interrupt)</code>，<strong>软件中断</strong>，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用SGI 中断来完成<strong>多核之间的通信</strong></li>
</ul>
<h4 id="ID-Hardware-Interrupt-ID-硬件中断号"><a href="#ID-Hardware-Interrupt-ID-硬件中断号" class="headerlink" title="ID (Hardware Interrupt ID) - 硬件中断号"></a><strong>ID (Hardware Interrupt ID) - 硬件中断号</strong></h4><p>中断源有很多，每一个CPU 最多支持<code>1020</code> 个中断ID，中断ID 号为<code>ID0~ID1019</code>。这<code>1020</code> 个ID 包含了<code>PPI</code>、<code>SPI</code> 和<code>SGI</code>。</p>
<ul>
<li><p><code>ID0~ID15</code>：这16 个ID 分配给SGI。</p>
</li>
<li><p><code>ID16~ID31</code>：这16 个ID 分配给PPI。</p>
</li>
<li><p><code>ID32~ID1019</code>：这988 个ID 分配给SPI，像GPIO 中断、串口中断等这些外部中断。I.MX6U 的总共使用了128 个中断ID，加上前面属于PPI 和SGI 的32 个ID，I.MX6U 的中断源共有128+32&#x3D;160个。</p>
</li>
</ul>
<p>《I.MX6ULL 参考手册》的3.2 小节可以查看I.MX6U 完整的中断源</p>
<p><img src="image-20250509155510610.png" alt="image-20250509155510610"></p>
<h4 id="IRQ-Linux-Virtual-Interrupt-Number-Linux-虚拟中断号"><a href="#IRQ-Linux-Virtual-Interrupt-Number-Linux-虚拟中断号" class="headerlink" title="IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号"></a>IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号</h4><p> <strong>Linux 内核软件视角下的逻辑编号</strong>。它是一个由 Linux 内核分配和管理的软件概念，是驱动开发者请求和使用的“虚拟中断号”。当驱动调用 <code>request_irq(irq, handler, ...)</code> 来注册一个中断处理函数时，它使用的就是这个 <code>irq</code> 号。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">IRQ (虚拟中断号)</th>
<th align="left">ID (硬件中断号)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>视角</strong></td>
<td align="left">Linux 内核软件视角</td>
<td align="left">中断控制器硬件视角</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">驱动开发者使用</td>
<td align="left">硬件工程师、底层配置使用</td>
</tr>
<tr>
<td align="left"><strong>稳定性</strong></td>
<td align="left">相对稳定，但可能随配置变化</td>
<td align="left">绝对固定，由芯片决定</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left">通过 <code>irq_domain</code> 映射到 <code>ID</code></td>
<td align="left">通过 <code>irq_domain</code> 被映射到 <code>IRQ</code></td>
</tr>
</tbody></table>
<h3 id="中断控制器处理中断的流程"><a href="#中断控制器处理中断的流程" class="headerlink" title="中断控制器处理中断的流程"></a>中断控制器处理中断的流程</h3><img src="image-20250901105220714.png" alt="image-20250901105220714" style="zoom:33%;">

<center>多核GIC</center>

<p>GRC控制器结构:分为<strong>仲裁器</strong>和<strong>CPU接口</strong>两部分</p>
<p><strong>中断的状态</strong>可以分为Inactive、Pending、Active、Active and Pending四种状态：</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Inactive</strong></td>
<td align="left">中断未发生，或已被处理完成。</td>
</tr>
<tr>
<td align="left"><strong>Pending</strong></td>
<td align="left">中断已发生，但尚未被 CPU 处理。</td>
</tr>
<tr>
<td align="left"><strong>Active</strong></td>
<td align="left">CPU 正在处理该中断。</td>
</tr>
<tr>
<td align="left"><strong>Active and Pending</strong></td>
<td align="left">CPU 正在处理该中断，但同一中断源又发出了新的中断。</td>
</tr>
</tbody></table>
<img src="image-20250901105005072.png" alt="image-20250901105005072" style="zoom: 33%;">

<ol>
<li><p>中断发生（Inactive → Pending）</p>
<ul>
<li>设备发出中断信号。</li>
<li>仲裁器将该中断状态设置为 <strong>Pending</strong>。</li>
</ul>
</li>
<li><p>仲裁器选择中断（Pending → 发送给 CPU Interface）</p>
<ul>
<li>仲裁器在所有 Pending 状态的中断中选择<strong>优先级最高</strong>的一个。</li>
<li>将其发送给目标 CPU 的 CPU Interface。</li>
</ul>
</li>
<li><p>CPU Interface 判断是否转发给 CPU</p>
<ul>
<li>CPU Interface 会检查：<ul>
<li>该中断的优先级是否高于当前 CPU 的屏蔽优先级（如优先级掩码寄存器）。</li>
<li>或者是否是 CPU 正在处理的中断（用于支持中断嵌套或抢占）。</li>
</ul>
</li>
<li>如果条件满足，则向 CPU 发出中断信号（如 IRQ 或 FIQ）。</li>
</ul>
</li>
<li><p>CPU 响应中断（Pending → Active）</p>
<ul>
<li>CPU 检测到中断信号后，跳转到中断处理程序。</li>
<li>CPU 通过读取<strong>中断应答寄存器</strong>（如 <code>GICC_IAR</code>）获取中断号。</li>
<li>读取后，该中断状态由 <strong>Pending</strong> 变为 <strong>Active</strong>。</li>
</ul>
</li>
<li><p>中断处理中（Active）</p>
<ul>
<li>CPU 执行该中断对应的处理函数（ISR, Interrupt Service Routine）。</li>
</ul>
</li>
<li><p>中断完成（Active → Inactive）</p>
<ul>
<li>CPU 处理完成后，写入<strong>中断结束寄存器</strong>（如 <code>GICC_EOIR</code>），通知控制器中断已完成。</li>
<li>控制器将该中断状态改为 <strong>Inactive</strong>。</li>
</ul>
</li>
</ol>
<h2 id="Cortex-A"><a href="#Cortex-A" class="headerlink" title="Cortex-A"></a>Cortex-A</h2><h3 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h3><p><img src="image-20250901214642570.png" alt="image-20250901214642570"></p>
<p>除了User(USR)用户模式以外，其<strong>它8 种运行模式都是特权模式</strong>，这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。</p>
<h3 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h3><p>ARM 架构提供了<strong>16 个32位的通用寄存器(R0<del>R15)**供软件使用，前15 个(R0</del>R14)可以用作通用的数据存储，<code>R15</code> 是**程序计数器PC</strong>，用来<strong>保存将要执行的指令</strong>。</p>
<p>ARM 还提供了一个当<strong>前程序状态寄存器</strong><code>CPSR</code> 和一个<strong>备份程序状态寄存器</strong><code>SPSR</code>，<code>SPSR</code> 寄存器就是<code>CPSR</code> 寄存器的备份。</p>
<p><img src="image-20250901212343818.png" alt="image-20250901212343818"></p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>R0~R15 就是通用寄存器，通用寄存器可以分为以下三类：</p>
<ul>
<li><strong>未备份寄存器</strong>，即R0~R7。</li>
<li><strong>备份寄存器</strong>，即R8~R14。</li>
<li><strong>程序计数器PC</strong>，即R15。</li>
</ul>
<ol>
<li><p><strong>未备份寄存器</strong></p>
<p>所有的处理器模式下这8 个寄存器都是同一个物理寄存器，在不同的模式下，这8 个寄存器中的数据就会被破坏。所以这8 个寄存器并没有被用作特殊用途。</p>
</li>
<li><p><strong>备份寄存器</strong></p>
<ul>
<li><p><code>R8~R12</code> 这5个寄存器有两种物理寄存器</p>
<ul>
<li><strong>快速中断模式下</strong>(FIQ)它们对应着Rx_irq(x&#x3D;8<del>12) 物理寄存器，因为FIQ 模式下的&#96;R8</del>R12&#96;是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</li>
<li><strong>其他模式下</strong>对应着Rx(8~12)物理寄存器。</li>
</ul>
</li>
<li><p><strong>备份寄存器R13</strong></p>
<p>R13也叫做<strong>SP</strong>，用来做为<strong>栈指针</strong>。其中一个是用户模式(User)和系统模式(Sys)共用的，剩下的7 个分别对应7种不同的模式。基本上每种模式都有一个自己的R13物理寄存器，应用程序会初始化R13，使其指向该模式专用的栈地址，这就是常说的初始化SP指针。</p>
</li>
<li><p><strong>备份寄存器R14</strong></p>
<p>R14 也称为<strong>连接寄存器(LR)</strong>，LR 寄存器在ARM 中主要用作如下两种用途：</p>
<ul>
<li><p><strong>每种</strong>处理器<strong>模式</strong>使用R14(LR)来<strong>存放当前子程序的返回地址</strong>如果使用BL或者BLX<br>来调用子函数的话，R14(LR)被设置成该子函数的返回地址，<strong>在子函数中，将R14(LR)中的值赋给R15(PC)即可完成子函数返回</strong>，比如在子程序中可以使用如下代码</p>
<ul>
<li><pre><code>MOV PC, LR @寄存器LR 中的值赋值给PC，实现跳转
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  PUSH &#123;LR&#125; @将LR 寄存器压栈----子函数的入口</span><br><span class="line">  POP &#123;PC&#125; @将上面压栈的LR 寄存器数据出栈给PC 寄存器，严格意义上来讲应该是将@LR-4 赋给PC-----子函数的最后面</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>异常模式</strong>对应的R14 寄存器被设置成该异常模式将要返回的地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序计数器R15</strong></p>
<p>程序计数器R15也叫做<strong>PC</strong></p>
<p>R15保存着<strong>当前执行的指令地址值加8个字节</strong>，原因是：<strong>ARM 处理器3 级流水线：取指-&gt;译码-&gt;执行</strong>，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在R15(PC)中。</p>
<p><strong>R15(PC)总是指向当前正在执行的指令地址再加上2条指令的地址</strong>。对于32 的ARM 处理器，每条指令是4个字节，所以:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R15 (PC)值 = 当前执行的程序位置 + 8 个字节。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h4><p><strong>所有的处理器模式都共用一个CPSR 物理寄存器</strong>，<strong>CPSR 是当前程序状态寄存器</strong>，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。</p>
<p>除了User和Sys这两个模式以外，其他7个模式每个都配备了一个专用的物理状态寄存器，叫做<strong>SPSR(备份程序状态寄存器)</strong>，<strong>当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用SPSR中保存的值来恢复CPSR。</strong></p>
<p><img src="image-20250901214235189.png" alt="image-20250901214235189"></p>
<center>CPSR 寄存器</center>

<h5 id="1-条件码标志位-Condition-Code-Flags"><a href="#1-条件码标志位-Condition-Code-Flags" class="headerlink" title="1. 条件码标志位 (Condition Code Flags)"></a>1. 条件码标志位 (Condition Code Flags)</h5><p>这些位由 ARM 指令（通常带有 <code>S</code> 后缀，如 <code>ADDS</code>）自动设置，用于决定条件指令（如 <code>BGE</code>, <code>CMP</code>）是否执行。</p>
<ul>
<li><strong>N (Negative &#x2F; Less Than) [31]</strong>: 结果为负时置 1。</li>
<li><strong>Z (Zero) [30]</strong>: 结果为零时置 1。</li>
<li><strong>C (Carry &#x2F; Borrow &#x2F; Extend) [29]</strong>: 对于加法，无符号溢出时置 1；对于减法，无符号借位时置 0。</li>
<li><strong>V (oVerflow) [28]</strong>: 有符号溢出时置 1。</li>
</ul>
<h5 id="2-控制位-Control-Bits"><a href="#2-控制位-Control-Bits" class="headerlink" title="2. 控制位 (Control Bits)"></a>2. 控制位 (Control Bits)</h5><p>这些位用于控制 CPU 的核心行为。</p>
<ul>
<li><p><strong>I (IRQ disable) [7]</strong>: <strong>置 1 表示禁用 IRQ 中断</strong>。这是中断处理中的关键位！</p>
</li>
<li><p><strong>F (FIQ disable) [6]</strong>: <strong>置 1 表示禁用 FIQ 中断</strong>。</p>
</li>
<li><p><strong>T (Thumb) [5]</strong>: 置 1 表示 CPU 处于 Thumb 状态，执行 Thumb 指令；置 0 表示处于 ARM 状态。</p>
</li>
<li><p><strong>M[4:0] (Mode bits)</strong>: 这 5 位<strong>决定了 CPU 当前处于哪种工作模式</strong>，这是理解特权级和中断的又一关键！</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">M[4:0]</th>
<th align="left">用途</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>User</strong></td>
<td align="left">10000</td>
<td align="left"><strong>用户模式</strong>，运行普通应用程序</td>
<td align="left">非特权模式，资源受限</td>
</tr>
<tr>
<td align="left"><strong>FIQ</strong></td>
<td align="left">10001</td>
<td align="left"><strong>快速中断模式</strong>，用于处理高速数据传输、DMA 等</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>IRQ</strong></td>
<td align="left">10010</td>
<td align="left"><strong>普通中断模式</strong>，用于处理普通硬件中断</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Supervisor</strong></td>
<td align="left">10011</td>
<td align="left"><strong>监管模式</strong>，上电或软件中断 (<code>swi</code>) 指令进入，Linux <strong>内核态</strong></td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Abort</strong></td>
<td align="left">10111</td>
<td align="left"><strong>中止模式</strong>，在内存访问失败时进入</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Undef</strong></td>
<td align="left">11011</td>
<td align="left"><strong>未定义模式</strong>，在遇到未知指令时进入</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>System</strong></td>
<td align="left">11111</td>
<td align="left"><strong>系统模式</strong>，一种特权级的用户模式，用于运行特权操作系统任务</td>
<td align="left">特权模式</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="CPSR-在中断处理流程中的关键作用"><a href="#CPSR-在中断处理流程中的关键作用" class="headerlink" title="CPSR 在中断处理流程中的关键作用"></a>CPSR 在中断处理流程中的关键作用</h2><ol>
<li><strong>中断发生前 (CPU 在 User 模式)</strong><ul>
<li><code>CPSR.M[4:0] = 10000</code> (User 模式)</li>
<li><code>CPSR.I = 0</code> (IRQ 中断是使能的)</li>
</ul>
</li>
<li><strong>硬件自动响应中断</strong><ul>
<li>当一个 IRQ 中断被 CPU Interface 发送给 CPU 核心后，CPU 硬件会<strong>自动</strong>执行以下操作：<ul>
<li><strong>保存现场</strong>：将当前的 <code>CPSR</code> 保存到 <code>SPSR_irq</code>（IRQ 模式下的备份程序状态寄存器）中。</li>
<li><strong>模式切换</strong>：修改 <code>CPSR.M[4:0] = 10010</code>，让 CPU <strong>立即切换到 IRQ 模式</strong>。</li>
<li><strong>禁用中断</strong>：<strong>自动置 <code>CPSR.I = 1</code></strong>，<strong>禁用新的 IRQ 中断</strong>，防止中断嵌套（除非编写代码手动开启）。</li>
<li><strong>切换执行流</strong>：将返回地址保存到 <code>LR_irq</code>，并跳转到中断异常向量表指定的 IRQ 处理函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>中断处理中 (CPU 在 IRQ 模式)</strong><ul>
<li>此时，CPU 运行在特权模式下，可以访问所有系统资源。</li>
<li><code>CPSR.I = 1</code>，所以在此期间发生的普通 IRQ 中断会被屏蔽，但 FIQ 通常不会被屏蔽，以实现高速处理。</li>
</ul>
</li>
<li><strong>中断处理完成，恢复现场</strong><ul>
<li>中断服务程序执行完毕后，需要返回到被中断的任务。</li>
<li>执行一条特殊的返回指令（如 <code>subs pc, lr, #4</code>），这条指令会：<ul>
<li>将之前保存在 <code>SPSR_irq</code> 中的值<strong>自动写回 <code>CPSR</code></strong>。</li>
<li>这条指令同时将 <code>pc</code> 指向被中断的指令地址，从而恢复执行。</li>
</ul>
</li>
<li><strong>这一操作是原子性的</strong>，CPU 模式、中断屏蔽位（<code>I</code>&#x2F;<code>F</code>）、条件标志位等所有状态都瞬间恢复到了中断前的样子。</li>
</ul>
</li>
</ol>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// ===== 伪代码表示 ARM 中断处理流程 =====</span><br><span class="line"></span><br><span class="line">// 1. 中断发生前 (CPU 在 User 模式)</span><br><span class="line">CPSR = 0x00000010;        // M[4:0] = 10000 (User 模式), I=0 (IRQ 使能)</span><br><span class="line">PC = normal_execution;    // 正常执行用户程序</span><br><span class="line"></span><br><span class="line">// 2. 硬件自动响应中断 (当 IRQ 信号到达时，硬件自动执行以下操作)</span><br><span class="line">//    注意：这些操作是原子性的，由硬件自动完成，不是软件指令</span><br><span class="line">SPSR_irq = CPSR;          // 保存当前 CPSR 到 SPSR_irq</span><br><span class="line">CPSR.M = 0b10010;         // 切换到 IRQ 模式 (M[4:0] = 10010)</span><br><span class="line">CPSR.I = 1;               // 禁用 IRQ 中断 (I=1)</span><br><span class="line">LR_irq = PC + 4;          // 保存返回地址 (由于流水线，实际是下一条指令地址)</span><br><span class="line">PC = 0x00000018;          // 跳转到 IRQ 异常向量地址</span><br><span class="line"></span><br><span class="line">// 3. 软件异常向量处理 (在 0x00000018 处)</span><br><span class="line">//    这是软件预先设置的处理程序</span><br><span class="line">vector_irq:</span><br><span class="line">    // 矫正返回地址 (由于 ARM 流水线架构)</span><br><span class="line">    LR_irq = LR_irq - 4;</span><br><span class="line">    </span><br><span class="line">    // 保存关键寄存器到 IRQ 栈</span><br><span class="line">    SP_irq = SP_irq - 8;          // 调整栈指针</span><br><span class="line">    [SP_irq] = R0;                // 保存 R0</span><br><span class="line">    [SP_irq+4] = LR_irq;          // 保存返回地址</span><br><span class="line">    </span><br><span class="line">    // 保存之前的 CPSR (来自 SPSR_irq)</span><br><span class="line">    temp = SPSR_irq;</span><br><span class="line">    [SP_irq+8] = temp;</span><br><span class="line">    </span><br><span class="line">    // 准备切换到 SVC 模式</span><br><span class="line">    temp = CPSR;</span><br><span class="line">    temp.M = 0b10011;             // SVC 模式</span><br><span class="line">    SPSR_svc = temp;              // 设置 SPSR_svc 为 SVC 模式</span><br><span class="line">    </span><br><span class="line">    // 根据中断前的模式分发处理</span><br><span class="line">    previous_mode = SPSR_irq.M;   // 获取中断前的模式</span><br><span class="line">    if (previous_mode == 0b10000) // User 模式</span><br><span class="line">        PC = __irq_usr;</span><br><span class="line">    else if (previous_mode == 0b10011) // SVC 模式</span><br><span class="line">        PC = __irq_svc;</span><br><span class="line">    else</span><br><span class="line">        PC = __irq_invalid;       // 其他模式不支持</span><br><span class="line"></span><br><span class="line">// 4. 高级中断处理 (例如 __irq_usr)</span><br><span class="line">__irq_usr:</span><br><span class="line">    // 保存所有用户寄存器到栈</span><br><span class="line">    push &#123;r0-r12, lr&#125;</span><br><span class="line">    </span><br><span class="line">    // 调用通用中断处理程序</span><br><span class="line">    irq_number = get_irq_number();    // 从中断控制器获取中断号</span><br><span class="line">    handle_irq(irq_number);           // 通用中断处理</span><br><span class="line">    </span><br><span class="line">    // 恢复寄存器</span><br><span class="line">    pop &#123;r0-r12, lr&#125;</span><br><span class="line">    </span><br><span class="line">    // 返回到用户模式</span><br><span class="line">    movs pc, lr;                    // 特殊返回指令，同时恢复 CPSR</span><br><span class="line"></span><br><span class="line">// 5. 中断处理完成，恢复现场</span><br><span class="line">//    当执行 movs pc, lr 或 subs pc, lr, #4 时：</span><br><span class="line">//    - 将 SPSR_irq 的值写回 CPSR (自动完成)</span><br><span class="line">//    - 将 LR_irq 的值赋给 PC</span><br><span class="line">//    这一条指令原子性地完成了模式切换和程序流程恢复</span><br><span class="line"></span><br><span class="line">// 最终状态：CPU 回到 User 模式，继续执行被中断的指令</span><br><span class="line">CPSR = 0x00000010;        // M[4:0] = 10000 (User 模式), I=0 (IRQ 使能)</span><br><span class="line">PC = normal_execution;    // 继续执行被中断的程序</span><br></pre></td></tr></table></figure>

<h2 id="linux中断处理的流程"><a href="#linux中断处理的流程" class="headerlink" title="linux中断处理的流程"></a>linux中断处理的流程</h2><p><strong>linux-5.10.4版本：</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h">interrupt.h</a></p>
<img src="deepseek_mermaid_20250903_446fba-17568834327623.png" alt="deepseek_mermaid_20250903_446fba" style="zoom:200%;">

<h3 id="linux系统启动的流程"><a href="#linux系统启动的流程" class="headerlink" title="linux系统启动的流程"></a>linux系统启动的流程</h3><h4 id="irq-domain"><a href="#irq-domain" class="headerlink" title="irq_domain"></a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/irqdomain.h#L162">irq_domain</a></h4><p><strong><code>irq_domain</code> 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。</strong></p>
<p>你可以把它想象成一个<strong>翻译官</strong>或<strong>接线总机</strong>：</p>
<ul>
<li><strong>硬件中断号 (HW IRQ)</strong>：是中断控制器自己识别的编号。例如，对于 ARM GIC，SGIs 是 0-15，PPIs 是 16-31，SPIs 从 32 开始。这是硬件固定的，不同控制器完全不同。</li>
<li><strong>虚拟中断号 (VIRQ)</strong>：是 Linux 内核内部使用的、统一的软件中断编号。驱动开发者请求和使用的就是这个号。</li>
</ul>
<p><strong>它的作用：</strong></p>
<ul>
<li><p>抽象硬件差异</p>
<p>世界上有无数种中断控制器（GIC, APIC, IO-APIC, GPIO 控制器等），每种都有自己的编号方案和编程模型。内核无法为每种控制器都写一套独立的中断处理流程。<code>irq_domain</code> 提供了一个统一的抽象接口，让内核核心代码只需与 <code>irq_domain</code> 交互，而由各中断控制器驱动去实现具体的操作。</p>
</li>
<li><p>管理中断号映射</p>
<p>这是最核心的功能。当设备树（Device Tree）中描述一个设备的中断时，它只写硬件信息，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">0</span> <span class="number">58</span> <span class="number">4</span>&gt;; <span class="comment">// 代表这个设备连接到GIC的SPI，硬件中断号是58</span></span><br></pre></td></tr></table></figure>

<p>内核需要为这个“硬件中断号 58”分配一个“虚拟中断号”（比如 126）。<code>irq_domain</code> 就负责创建并维护这个映射关系。当驱动调用 <code>request_irq(126, ...)</code> 时，内核通过 <code>irq_domain</code> 知道，最终要去配置 GIC 控制器上编号为 58 的中断源。</p>
</li>
<li><p>提供控制器特定的操作函数集</p>
<p>每个 <code>irq_domain</code> 都关联着一个 <code>irq_domain_ops</code> 结构体，里面包含了一系列函数指针，用于执行该控制器特有的操作：</p>
<ul>
<li><code>.map()</code>: <strong>中断映射</strong>。在设备树解析到设备中断时，调用此函数来建立硬件中断号到虚拟中断号的映射，并配置该中断线的处理方式（设置 <code>-&gt;handle_irq</code> 函数）。<strong><code>gic_irq_domain_map</code> 函数，就是这个操作的具体实现！</strong></li>
<li><code>.alloc()</code>: 另一种分配中断号的方式。</li>
<li><code>.translate()</code>: 从设备树信息中翻译出硬件中断号。</li>
<li><code>.xclate()</code>: 转换中断说明符。</li>
</ul>
</li>
<li><p>支持中断控制器的级联</p>
<p>一个系统可能有多个中断控制器（例如，一个主 GIC 和一个作为中断源的 GPIO 控制器级联到 GIC 上）。每个控制器都需要自己的 <code>irq_domain</code>。子控制器的 <code>irq_domain</code> 会将它的虚拟中断号映射到父控制器的硬件中断号上，从而形成一个层次结构，内核可以无缝地处理这种级联关系。</p>
</li>
</ul>
<h4 id="系统启动的流程分析"><a href="#系统启动的流程分析" class="headerlink" title="系统启动的流程分析"></a>系统启动的流程分析</h4><ol>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/init/main.c#L848"><strong>start_kernel函数</strong></a></p>
<p>内核的启动函数，通过调用众多的子函数来完成 Linux 启动之前的一些初始化工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">	-&gt; local_irq_disable()<span class="comment">//关闭当前 CPU 的中断响应。通常通过设置 ARM CPSR 寄存器的 I 							//bit (对于 IRQ) 和 F bit (对于 FIQ) 来实现。   </span></span><br><span class="line">    -&gt; sort_main_extable()<span class="comment">//对内核的异常表（Exception Table）进行排序  </span></span><br><span class="line">    -&gt; trap_init()<span class="comment">//初始化系统陷阱（Trap）或异常向量表           </span></span><br><span class="line">    -&gt; ... </span><br><span class="line">    -&gt; init_IRQ()<span class="comment">//架构相关的中断初始化。                 </span></span><br><span class="line">    -&gt; softirq_init()<span class="comment">//初始化软中断（SoftIRQ）机制。      </span></span><br><span class="line">    -&gt; local_irq_enable()<span class="comment">//开启当前 CPU 的中断响应 </span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">调用阶段</th>
<th align="left">核心作用</th>
<th align="left">详细解释</th>
<th align="left">与中断的关系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>local_irq_disable()</code></strong></td>
<td align="left">最早阶段</td>
<td align="left"><strong>关闭CPU中断响应</strong></td>
<td align="left">在一切初始化之前，创造一个安全的、不被中断打断的原子环境，防止未初始化时中断导致系统崩溃。</td>
<td align="left"><strong>奠基与防护</strong>：为后续初始化提供安全环境，是中断系统启动的<strong>前提</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>sort_main_extable()</code></strong></td>
<td align="left">早期准备</td>
<td align="left"><strong>排序异常表</strong></td>
<td align="left">对内核的异常修复表（<code>__ex_table</code>）进行排序，以便在发生页面错误等异常时能快速查找并使用二分法定位修复地址。</td>
<td align="left"><strong>增强鲁棒性</strong>：不直接处理中断，但为异常处理（中断的一种）提供<strong>错误恢复机制</strong>，提升稳定性。</td>
</tr>
<tr>
<td align="left"><strong><code>trap_init()</code></strong></td>
<td align="left">基础设施搭建</td>
<td align="left"><strong>初始化异常向量表</strong></td>
<td align="left">设置CPU的异常向量基地址寄存器（如ARM的VBAR），填充异常&#x2F;中断的通用处理入口，是CPU响应异常和中断的<strong>硬件跳转表</strong>。</td>
<td align="left"><strong>硬件基石</strong>：建立了中断&#x2F;异常发生后CPU的<strong>第一跳转目的地</strong>，是中断能够被处理的<strong>绝对基础</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>init_IRQ()</code></strong></td>
<td align="left">软件框架搭建</td>
<td align="left"><strong>架构相关中断初始化</strong></td>
<td align="left">初始化架构相关的中断通用代码，通常负责分配和初始化核心数据结构 <code>irq_desc</code> 数组（中断描述符），为每个中断号建立管理单元。</td>
<td align="left"><strong>软件框架</strong>：搭建了内核管理所有中断的<strong>核心框架</strong>（<code>irq_desc</code>），是连接通用中断子系统与具体硬件的架构桥梁。</td>
</tr>
<tr>
<td align="left"><strong><code>softirq_init()</code></strong></td>
<td align="left">下半部机制初始化</td>
<td align="left"><strong>初始化软中断机制</strong></td>
<td align="left">初始化 <code>tasklet</code> 和软中断（SoftIRQ）机制，为中断的<strong>下半部</strong>（Bottom Half）处理提供延迟执行的框架。</td>
<td align="left"><strong>完善处理流程</strong>：完成了中断处理“上半部+下半部”的完整框架，允许中断处理函数将非紧急任务推迟执行。</td>
</tr>
<tr>
<td align="left"><strong><code>local_irq_enable()</code></strong></td>
<td align="left">最终开启</td>
<td align="left"><strong>开启CPU中断响应</strong></td>
<td align="left">在所有中断基础设施（向量表、控制器、框架、下半部）都已初始化完毕后，正式打开CPU的中断响应开关，系统开始正常处理中断。</td>
<td align="left"><strong>正式启用</strong>：标志着中断系统<strong>全面启动完成</strong>，内核从静态初始化阶段进入动态运行阶段。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>中断初始化</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/irq.c#L78">init_IRQ</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; !machine_desc-&gt;init_irq)</span><br><span class="line">		irqchip_init();<span class="comment">//初始化中断控制器</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		machine_desc-&gt;init_irq();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; IS_ENABLED(CONFIG_CACHE_L2X0) &amp;&amp;</span><br><span class="line">	    (machine_desc-&gt;l2c_aux_mask || machine_desc-&gt;l2c_aux_val)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!outer_cache.write_sec)</span><br><span class="line">			outer_cache.write_sec = machine_desc-&gt;l2c_write_sec;</span><br><span class="line">		ret = l2x0_of_init(machine_desc-&gt;l2c_aux_val,</span><br><span class="line">				   machine_desc-&gt;l2c_aux_mask);</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; ret != -ENODEV)</span><br><span class="line">			pr_err(<span class="string">&quot;L2C: failed to init: %d\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uniphier_cache_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数名</th>
<th>调用阶段</th>
<th>核心作用</th>
<th>详细解释</th>
<th>与中断的关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>irqchip_init()</code></strong></td>
<td>硬件控制器初始化</td>
<td><strong>初始化中断控制器</strong></td>
<td>解析设备树，识别系统中的应用中断控制器（如GIC），映射其寄存器，禁用所有中断源，设置默认路由，并向内核注册控制器（创建<code>irq_domain</code>）。</td>
<td><strong>驱动硬件</strong>：是<strong>驱动中断控制器硬件</strong>的关键步骤，使内核能够具体地配置、使能和接收来自硬件设备的中断信号。</td>
</tr>
</tbody></table>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/irqchip_init">irqchip_init</a>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">irqchip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	of_irq_init(__irqchip_of_table);</span><br><span class="line">	acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>of_irq_init(__irqchip_of_table);</code> <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/of/irq.c#L472">of_irq_init</a><strong>遍历设备树，找到所有已注册的中断控制器节点，并调用它们各自的初始化函数。</strong></p>
<ol>
<li><p><strong>入参</strong>：接收一个列表 <code>__irqchip_of_table</code>，这个列表包含了所有在内核编译时注册的、支持的中断控制器信息（兼容字符串和初始化函数指针）。当中断控制器驱动（如 GIC 驱动）使用 <code>IRQCHIP_DECLARE</code> 宏声明时，它的兼容性字符串和初始化函数指针就会被添加到这个段中。</p>
<p>例如：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1510">IRQCHIP_DECLARE</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扫描设备树</strong>：遍历整个设备树（Device Tree），查找所有 <code>interrupt-controller</code> 属性，并获取它们的 <code>compatible</code> 属性。</p>
</li>
<li><p><strong>匹配驱动</strong>：将设备树中每个中断控制器节点的 <code>compatible</code> 属性与 <code>__irqchip_of_table</code> 列表中的项进行匹配。</p>
</li>
<li><p><strong>初始化调用</strong>：一旦匹配成功，就调用该中断控制器在 <code>__irqchip_of_table</code> 中注册的初始化函数（例如，对于 <code>&quot;arm,gic-400&quot;</code>，就会调用 <code>gic_of_init</code>）。</p>
</li>
<li><p><strong>处理级联</strong>：它会正确处理中断控制器的级联关系（例如，一个主 GIC 连接一个 GPIO 中断控制器），确保父控制器在子控制器之前被初始化。</p>
</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1464">gic_of_init</a>函数会</p>
<ul>
<li>映射硬件寄存器。</li>
<li>初始化私有数据 <code>struct gic_chip_data</code>。</li>
<li><strong>调用 <code>gic_init_bases()</code></strong>。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1135">gic_init_bases</a>函数中注册**<code>irq_domain</code>** </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (handle) &#123;		<span class="comment">/* DT/ACPI */</span><span class="comment">//这是一个指针，通常指向设备树（DT）或ACPI中描述这个GIC控制器的节点。如果它存在，说明内核是通过现代的设备树或ACPI机制来获取硬件信息的。</span></span><br><span class="line">	gic-&gt;domain = irq_domain_create_linear(handle, gic_irqs,</span><br><span class="line">					       &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">					       gic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;		<span class="comment">/* Legacy support */</span><span class="comment">//为了兼容那些没有使用设备树的旧平台。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For primary GICs, skip over SGIs.</span></span><br><span class="line"><span class="comment">	 * No secondary GIC support whatsoever.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> irq_base;</span><br><span class="line"></span><br><span class="line">	gic_irqs -= <span class="number">16</span>; <span class="comment">/* calculate # of irqs to allocate */</span></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">16</span>, <span class="number">16</span>, gic_irqs, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;Cannot allocate irq_descs @ IRQ16, assuming pre-allocated\n&quot;</span>);</span><br><span class="line">		irq_base = <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gic-&gt;domain = irq_domain_add_legacy(<span class="literal">NULL</span>, gic_irqs, irq_base,</span><br><span class="line">						<span class="number">16</span>, &amp;gic_irq_domain_ops, gic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;gic_irq_domain_hierarchy_ops</code>参数 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/irq_domain_ops">irq_domain_ops</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gic_irq_domain_hierarchy_ops</span> =</span> &#123;</span><br><span class="line">	.translate = gic_irq_domain_translate,</span><br><span class="line">	.alloc = gic_irq_domain_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = irq_domain_free_irqs_top,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> arg;</span><br><span class="line"></span><br><span class="line">	ret = gic_irq_domain_translate(domain, fwspec, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++) &#123;</span><br><span class="line">		ret = gic_irq_domain_map(domain, virq + i, hwirq + i);<span class="comment">//映射</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>6中代码的<code>gic_irq_domain_map</code>函数为<strong>中断域的映射</strong>，发生在系统启动时，中断控制器被初始化之后，任何驱动申请中断之前。作用为<strong>负责为每个硬件中断号配置对应的Linux虚拟中断号的处理方式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> d-&gt;host_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irqd</span> =</span> irq_desc_get_irq_data(irq_to_desc(irq));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (hw) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> ... <span class="number">15</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_fasteoi_ipi,</span><br><span class="line">				    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">16</span> ... <span class="number">31</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		irq_set_probe(irq);</span><br><span class="line">		irqd_set_single_target(irqd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevents SW retriggers which mess up the ACK/EOI ordering */</span></span><br><span class="line">	irqd_set_handle_enforce_irqctx(irqd);<span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>irq_domain</code>：是内核用于管理中断控制器和硬件中断号的一个抽象层。每个中断控制器都有一个自己的 <code>irq_domain</code>。</li>
<li><code>irq</code>：Linux 内核的<strong>虚拟中断号</strong>。这是一个软件概念，驱动开发者请求和使用的就是这个号。</li>
<li><code>hw</code>：<strong>硬件中断号</strong>。这是 GIC 控制器自己识别的中断编号（如 SPI 从 32 开始，PPI 从 16 开始）</li>
</ul>
<p><code>switch (hw) &#123;...&#125;</code> 根据硬件中断号进行配置</p>
<p>这是整个函数的核心，根据硬件中断号的不同范围，将中断分为三类进行处理：</p>
<ul>
<li><p><strong>1. Case 0 … 15: Software Generated Interrupt (SGIs)</strong> <strong>核间中断</strong>，一个CPU核心可以用它来中断另一个CPU核心。</p>
</li>
<li><p><strong>2. Case 16 … 31: Private Peripheral Interrupt (PPIs)</strong> 每个CPU核心私有的外设中断</p>
</li>
<li><p><strong>3. Default (通常为 32+): Shared Peripheral Interrupt (SPIs)</strong> 共享外设中断，所有CPU核心都可以看到的中断</p>
</li>
<li><pre><code class="language-c">irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,handle_fasteoi_irq, NULL, NULL);

/****************    1    *****************/
//kernel/irq/irqdomain.c
void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
             irq_hw_number_t hwirq, struct irq_chip *chip,
             void *chip_data, irq_flow_handler_t handler,
             void *handler_data, const char *handler_name)
&#123;
    irq_set_chip_and_handler_name(virq, chip, handler, handler_name);
    irq_set_chip_data(virq, chip_data);
    irq_set_handler_data(virq, handler_data);
&#125;

/****************    2    *****************/
///kernel/irq/chip.c
void
irq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
                  irq_flow_handler_t handle, const char *name)
&#123;
    irq_set_chip(irq, chip);
    __irq_set_handler(irq, handle, 0, name);
&#125;
/****************    3    *****************/
//kernel/irq/chip.c
void
__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
          const char *name)
&#123;
    unsigned long flags;
    struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, 0);

    if (!desc)
        return;

    __irq_do_set_handler(desc, handle, is_chained, name);//最终函数
    irq_put_desc_busunlock(desc, flags);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">     - `d`: 所属的 `irq_domain`</span><br><span class="line">     </span><br><span class="line">     - `irq`: Linux 虚拟中断号</span><br><span class="line">     </span><br><span class="line">     - `hw`: 硬件中断号</span><br><span class="line">     </span><br><span class="line">     - `&amp;gic-&gt;chip`: 指向中断控制器芯片的底层操作集（`struct irq_chip *`），包含像 `.irq_mask`, `.irq_unmask`, `.irq_eoi` 这样的硬件操作函数。</span><br><span class="line">     </span><br><span class="line">     - `handle_percpu_devid_fasteoi_ipi` 等：这是**最关键**的参数，它设置了 `irq_desc-&gt;handle_irq` 字段，即**中断的流处理函数**。</span><br><span class="line"></span><br><span class="line">8. `__irq_do_set_handler` - 设置流处理函数[__irq_do_set_handler](https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/chip.c#L1000)</span><br><span class="line"></span><br><span class="line">   这个函数是第一部分中 `irq_domain_set_info` 等函数在底层**最终会调用的函数**。它的工作非常简单直接：</span><br><span class="line"></span><br><span class="line">   1. **安全地将流处理函数安装到中断描述符中**</span><br><span class="line">      - `desc-&gt;handle_irq = handle;`</span><br><span class="line">      - 它将中断描述符（`struct irq_desc *desc`）的 `handle_irq` 成员设置为指定的流处理函数（如 `handle_fasteoi_irq`，这个函数在内核**编译时**就已确定并存放在内核镜像中）。</span><br><span class="line">   2. 处理各种边界情况，特别是层级中断域和链式中断</span><br><span class="line">   3. 确保中断状态的正确性</span><br><span class="line">   4. 处理中断的卸载情况</span><br><span class="line">   </span><br><span class="line">   **这个函数完成了从“配置”到“执行”的最后一步挂钩操作。**</span><br><span class="line"></span><br><span class="line">### CPU部分流程</span><br><span class="line"></span><br><span class="line">**特点：**</span><br><span class="line"></span><br><span class="line">1. **硬件自动发起**：最初的跳转和状态保存由CPU硬件逻辑完成，无法干预。</span><br><span class="line">2. **汇编语言处理**：后续的现场保存、模式切换、分发都由高度优化的汇编代码完成。</span><br><span class="line">3. **关键目标**：</span><br><span class="line">   - **保护现场**：完整保存被中断任务的执行状态（寄存器）。</span><br><span class="line">   - **模式切换**：从IRQ模式切换到更通用的SVC模式。</span><br><span class="line">   - **获取中断源**：获取硬件中断号（hwirq）。</span><br><span class="line">   - **传递上下文**：将硬件中断号和保存的寄存器结构（`pt_regs`）传递给C处理函数。</span><br><span class="line">4. **关中断**：在整个CPU处理阶段，IRQ中断始终是关闭的（`CPSR.I=1`），直到C代码中的某些阶段才可能被打开。</span><br><span class="line"></span><br><span class="line">当外设触发中断，中断控制器（如GIC）仲裁后会将中断信号发送给CPU核心。CPU核心会**自动**执行以下操作：</span><br><span class="line"></span><br><span class="line">![deepseek_mermaid_20250903_b988d0](%E4%B8%AD%E6%96%AD.assets/deepseek_mermaid_20250903_b988d0.png)</span><br><span class="line"></span><br><span class="line">#### 硬件部分自动完成</span><br><span class="line"></span><br><span class="line">如同我们在之前CPSR小节学习到的知识，当外设触发中断，中断控制器（如GIC）仲裁后会将中断信号发送给CPU核心。CPU核心会**自动**执行以下操作：</span><br><span class="line"></span><br><span class="line">- **保存状态**：将当前程序的状态寄存器 `CPSR` 保存到 `SPSR_irq`（IRQ模式下的备份程序状态寄存器）。</span><br><span class="line">- **模式切换**：修改 `CPSR` 的低5位，让CPU**立即切换到IRQ模式**。</span><br><span class="line">- **关闭中断**：**自动将 `CPSR` 中的 `I` bit 置1**，**禁用新的IRQ中断**，防止中断嵌套。这是关键一步。</span><br><span class="line">- **保存返回地址**：将**下一条即将要执行的指令地址**（即返回地址）保存到 `LR_irq` 寄存器。**注意**：对于ARM架构，这个地址需要矫正（`LR - 4`）才能正确返回，流程图中 `vector_stub irq, IRQ_MODE, 4` 的 `4` 就是这个矫正值。</span><br><span class="line">- **跳转到异常向量表**：CPU自动跳转到**异常向量表**的固定地址 `0x00000018`（对于IRQ）执行。</span><br><span class="line"></span><br><span class="line">&gt; **小结**：至此，CPU在完全由硬件控制的情况下，保存了现场，并跳转到了软件指定的入口。这是任何中断处理的起点。</span><br><span class="line"></span><br><span class="line">**伪代码：**</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">; === CPU 硬件自动完成的操作（非实际指令，而是硬件行为） ===</span><br><span class="line"></span><br><span class="line">; 1. 保存状态：将当前 CPSR 保存到 SPSR_irq</span><br><span class="line">SPSR_irq = CPSR</span><br><span class="line"></span><br><span class="line">; 2. 模式切换：修改 CPSR 的低5位，切换到 IRQ 模式</span><br><span class="line">CPSR[4:0] = 0b10010   ; 设置模式为 IRQ</span><br><span class="line"></span><br><span class="line">; 3. 关闭中断：禁用 IRQ</span><br><span class="line">CPSR[7] = 1           ; 设置 I-bit，禁用 IRQ 中断</span><br><span class="line"></span><br><span class="line">; 4. 保存返回地址：将下一条指令的地址保存到 LR_irq</span><br><span class="line">;    注意：由于 ARM 流水线架构，PC 值通常比当前指令超前 2 条指令（8 字节）</span><br><span class="line">;    因此需要矫正，返回地址实际应为 PC - 4（即下一条指令）</span><br><span class="line">LR_irq = PC - 4       ; 对于 ARM 状态，返回地址是当前指令 + 4</span><br><span class="line"></span><br><span class="line">; 5. 跳转到异常向量表：强制将 PC 设置为 IRQ 异常向量的地址</span><br><span class="line">PC = 0x00000018       ; 跳转到 IRQ 异常向量入口</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="CPU部分其余流程"><a href="#CPU部分其余流程" class="headerlink" title="CPU部分其余流程"></a>CPU部分其余流程</h4><ol>
<li><p><strong>异常向量表 (软件定义的第一跳)</strong></p>
<p>异常向量表是软件预先设置好的一块内存区域，通常由汇编代码定义（如 <code>arch/arm/kernel/entry-armv.S</code>）。CPU只是机械地跳转到这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L__vectors_start:</span><br><span class="line"> W(b) vector_rst    @ 0x00 Reset</span><br><span class="line"> W(b) vector_und    @ 0x04 Undefined Instruction</span><br><span class="line">...</span><br><span class="line"> W(b) vector_irq    @ 0x18 IRQ Interrupt  &lt;-- CPU跳到这里</span><br><span class="line"> W(b) vector_fiq    @ 0x1C FIQ Interrupt</span><br></pre></td></tr></table></figure>

<p><code>vector_irq</code> 是一条跳转指令，跳转到 <code>vector_stub</code> 宏展开的代码。这是软件处理中断的开始。</p>
</li>
<li><p><strong>汇编入口处理 (<code>vector_stub</code> 宏)</strong></p>
<p><code>vector_stub</code> 是一个宏，它负责进行<strong>更精细的现场保存和模式准备</strong>。它的主要工作是：</p>
<ul>
<li><p><strong>地址矫正</strong>：修正 <code>LR</code> 寄存器中的返回地址。</p>
</li>
<li><p><strong>保存寄存器</strong>：将 <code>r0</code> 和 <code>lr</code>（返回地址）暂时压入IRQ模式的栈。</p>
</li>
<li><p><strong>保存原始状态</strong>：将 <code>SPSR_irq</code>（即中断发生时的 <code>CPSR</code>）也保存到栈上。</p>
</li>
<li><p><strong>准备切换到SVC模式</strong>：修改 <code>SPSR</code> 的值，为接下来切换到<strong>SVC模式</strong>做准备。<strong>之所以要切换到SVC模式，是因为SVC模式有更丰富的资源（如栈），方便执行更复杂的C代码。</strong></p>
</li>
<li><p><strong>根据中断发生前的模式进行分发</strong>：根据保存的原始 <code>CPSR</code>，判断中断发生前CPU是处于用户模式（USR）还是内核模式（SVC），从而跳转到不同的处理路径（<code>__irq_usr</code> 或 <code>__irq_svc</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; === arch/arm/kernel/entry-armv.S 中的 vector_stub 宏 ===</span><br><span class="line"></span><br><span class="line">.macro vector_stub, name, mode, correction=0</span><br><span class="line">.align 5</span><br><span class="line">vector_\name:</span><br><span class="line">    .if \correction</span><br><span class="line">        sub lr, lr, #\correction   @ 矫正返回地址！这里 correction=4</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">    @ 保存 r0 和 lr (用户模式的 PC) 到 IRQ 栈</span><br><span class="line">    stmia sp, &#123;r0, lr&#125;</span><br><span class="line">    mrs lr, spsr                   @ 获取保存的 CPSR (SPSR_irq)</span><br><span class="line">    str lr, [sp, #8]               @ 将 SPSR 也保存到栈上</span><br><span class="line"></span><br><span class="line">    @ 准备切换到 SVC 模式，但 IRQ 仍然保持禁用</span><br><span class="line">    mrs r0, cpsr</span><br><span class="line">    eor r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">    msr spsr_cxsf, r0              @ 设置 SPSR 为 SVC 模式</span><br><span class="line"></span><br><span class="line">    @ 根据中断发生前的模式（保存在 SPSR 中），跳转到不同的处理程序</span><br><span class="line">    and lr, lr, #0x0f              @ 获取之前的模式</span><br><span class="line">    mov r0, sp</span><br><span class="line">    ldr lr, [pc, lr, lsl #2]       @ 根据模式加载跳转地址</span><br><span class="line">    movs pc, lr                    @ 跳转到处理程序，并恢复 CPSR</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">; 使用宏创建 IRQ 向量 stub，并指定矫正值为 4</span><br><span class="line">vector_stub irq, IRQ_MODE, 4</span><br><span class="line"></span><br><span class="line">    .long __irq_usr            @ 0 (USR_26 / USR_32) - 从用户模式中断</span><br><span class="line">    .long __irq_invalid        @ 1 (FIQ_26 / FIQ_32)</span><br><span class="line">    .long __irq_invalid        @ 2 (IRQ_26 / IRQ_32)</span><br><span class="line">    .long __irq_svc            @ 3 (SVC_26 / SVC_32) - 从内核模式中断</span><br><span class="line">    @ ... 其他模式</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中断处理分发 (<code>__irq_usr</code> &#x2F; <code>__irq_svc</code>)</strong></p>
<p>以 <code>__irq_usr</code>（在用户空间被中断）为例：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/entry-armv.S#L426">IRQ_USR</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__irq_usr:</span><br><span class="line">	usr_entry</span><br><span class="line">	kuser_cmpxchg_check</span><br><span class="line">	irq_handler</span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	mov	why, #0</span><br><span class="line">	b	ret_to_user_from_irq</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>usr_entry</code>：继续保存被中断的用户进程的上下文（所有通用寄存器），形成一个完整的 <code>pt_regs</code> 结构体，保存在栈上。这是后续能够恢复现场的关键。</p>
</li>
<li><p><code>irq_handler</code>：这是<strong>最关键的一步</strong>，它负责获取中断号并跳转到高级别的C语言中断处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.macro	irq_handler</span><br><span class="line">#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER</span><br><span class="line">	ldr	r1, =handle_arch_irq</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	badr	lr, 9997f</span><br><span class="line">	ldr	pc, [r1]</span><br><span class="line">#else</span><br><span class="line">	arch_irq_handler_default</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ul>
<li>它最终会调用一个架构相关的函数（如 <code>arch_irq_handler_default</code>）来获取<strong>硬件中断号（hwirq）</strong>。</li>
<li>然后调用 <code>asm_do_IRQ(hwirq, pt_regs)</code> 或 <code>__handle_domain_irq(...)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/include/asm/entry-macro-multi.S#L7">arch_irq_handler_default</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.macro	arch_irq_handler_default</span><br><span class="line">	get_irqnr_preamble r6, lr</span><br><span class="line">1:	get_irqnr_and_base r0, r2, r6, lr@r0= 中断编号（如果待处理）。r2= 中断状态寄存器。</span><br><span class="line">	movne	r1, sp</span><br><span class="line">	@</span><br><span class="line">	@ routine called with r0 = irq number, r1 = struct pt_regs *</span><br><span class="line">	@</span><br><span class="line">	badrne	lr, 1b</span><br><span class="line">	bne	asm_do_IRQ@如果中断挂起，则分支到 （C 处理程序）。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通用中断处理入口!!!!!</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/irq.c#L73">asm_do_IRQ</a>在arch&#x2F;arm&#x2F;kernel&#x2F;irq.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************    1    *********************************/</span></span><br><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line">asmlinkage <span class="type">void</span> __exception_irq_entry</span><br><span class="line"><span class="title function_">asm_do_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	handle_IRQ(irq, regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    2    *********************************/</span></span><br><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	__handle_domain_irq(<span class="literal">NULL</span>, irq, <span class="literal">false</span>, regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    3    *********************************/</span></span><br><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,</span><br><span class="line">			<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = hwirq;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	irq_enter();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_DOMAIN</span></span><br><span class="line">	<span class="keyword">if</span> (lookup)</span><br><span class="line">		irq = irq_find_mapping(domain, hwirq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some hardware gives randomly wrong interrupts.  Rather</span></span><br><span class="line"><span class="comment">	 * than crashing, do something sensible.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!irq || irq &gt;= nr_irqs)) &#123;</span><br><span class="line">		ack_bad_irq(irq);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		generic_handle_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_exit();</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************    4    *********************************/</span></span><br><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);<span class="comment">//irq变成结构体desc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	data = irq_desc_get_irq_data(desc);</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!in_irq() &amp;&amp; handle_enforce_irqctx(data)))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	generic_handle_irq_desc(desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    5    *********************************/</span></span><br><span class="line"><span class="comment">//include/linux/irqdesc.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generic_handle_irq_desc</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>同过上述的流程我们可以发现，CPU部分最终linux调用的<code>desc-&gt;handle_irq(desc);</code>，它的作用是<strong>执行与该中断类型相匹配的、预设的通用流处理（flow handling）逻辑。<strong>它调用的不是一个具体设备驱动注册的函数，而是一个</strong>架构或中断控制器相关的通用处理函数</strong>。这个函数负责处理特定类型中断的通用流程，例如：</p>
<ul>
<li><strong>处理中断控制器交互</strong>：如确认（ACK）、屏蔽（mask）、结束中断（EOI）等操作。</li>
<li><strong>管理中断状态</strong>：处理边缘触发（edge-triggered）或电平触发（level-triggered）中断的特定逻辑。</li>
<li><strong>调用设备驱动</strong>：在适当的时机，调用由设备驱动通过 <code>request_irq()</code> 注册的具体的中断服务程序。</li>
</ul>
<p>常见的 <code>handle_irq</code> 函数指针指向的处理函数有：</p>
<ul>
<li><strong><code>handle_fasteoi_irq</code>: 用于支持“End Of Interrupt”的中断控制器（如 ARM GIC），先处理中断，最后再发送 EOI。</strong></li>
<li><code>handle_level_irq</code>: 用于电平触发中断的处理。在处理前先屏蔽中断，处理完后再打开，防止中断嵌套导致的电平持续触发问题。</li>
<li><code>handle_edge_irq</code>: 用于边缘触发中断的处理。</li>
<li><code>handle_percpu_irq</code>: 用于每个 CPU 独有的中断。</li>
<li><code>handle_simple_irq</code>: 最简单的处理，没有硬件交互，假设所有硬件操作都由驱动自己完成。</li>
</ul>
<p>这个函数指针是在<strong>linux系统启动过程中的中断映射阶段</strong>（例如，在 <code>gic_irq_domain_map</code> 函数中通过 <code>irq_domain_set_info</code> 设置）被初始化的，它根据中断的硬件特性（是电平触发还是边缘触发，是共享的还是 per-CPU 的等）来选择最合适的处理函数。</p>
<blockquote>
<p><strong>小结</strong>：至此，CPU已经完成了从硬件自动响应到汇编保存现场，再到获取中断号并准备调用C处理函数的所有准备工作。中断处理的重心从汇编代码彻底移交给了C代码。</p>
</blockquote>
<h3 id="具体的设备驱动注册过程"><a href="#具体的设备驱动注册过程" class="headerlink" title="具体的设备驱动注册过程"></a>具体的设备驱动注册过程</h3><h4 id="irq-desc结构体"><a href="#irq-desc结构体" class="headerlink" title="irq_desc结构体"></a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/irqdesc.h#L55">irq_desc结构体</a></h4><ul>
<li>在系统启动早期，内核会调用 <code>early_irq_init()</code> 函数（位于 <code>kernel/irq/irqdesc.c</code>）。这个函数的主要职责就是<strong>预分配（或静态初始化）整个 <code>irq_desc</code> 数组</strong>。</li>
</ul>
<p>Linux 内核为每一个<strong>虚拟中断号（VIRQ）</strong> 都维护了一个核心数据结构 <code>struct irq_desc</code>。你可以把它想象成一个中断的“档案袋”或“管理员”，里面记录了这个中断的所有信息。最关键的两个成员是：</p>
<ol>
<li><code>-&gt;handle_irq</code>：指向一个<strong>流处理函数</strong>（例如 <code>handle_fasteoi_irq</code>, <code>handle_level_irq</code>）。这个函数是中断处理框架的“舞台经理”，负责处理中断的通用流程（如确认、屏蔽、EOI等）。</li>
<li><code>-&gt;action</code>：指向一个 <code>struct irqaction</code> 的链表。<strong>你通过 <code>request_irq</code> 注册的信息就封装在这里面</strong>，包括你的中断服务函数 <code>name1irqreturn</code>。</li>
</ol>
<h4 id="驱动注册流程分析"><a href="#驱动注册流程分析" class="headerlink" title="驱动注册流程分析"></a>驱动注册流程分析</h4><ol>
<li><p>当我们使用**<code>request_irq(unsigned int irq, ...)</code>**注册调用函数。传入虚拟中断号 <code>irq</code> 和中断处理函数（例如 <code>name1_irq_return_handle</code>）。<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L157">request_irq</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>request_threaded_irq()</code></strong>: <code>request_irq</code> 会调用这个函数。它创建一个 <code>struct irqaction</code> 结构体，并将 <code>name1_irq_return_handle</code> 函数指针赋值给 <code>action-&gt;handler</code>。<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/manage.c#L2002">request_threaded_irq()</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">    </span><br><span class="line">    desc = irq_to_desc(irq)<span class="comment">//获取中断描述符 (struct irq_desc)</span></span><br><span class="line">    action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);<span class="comment">//中断动作结构体初始化</span></span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line">    </span><br><span class="line">    retval = __setup_irq(irq, desc, action);<span class="comment">//核心中断设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>__setup_irq()</code></strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/manage.c#L1359">setup_irq</a>: 这是中断设置的最终函数。它会将上一步创建好的 <code>irqaction</code> 结构体，<strong>添加到 <code>irq_desc[irq]-&gt;action</code> 链表的末尾</strong>。</p>
<p>如果这个中断号被<strong>多个设备驱动共享</strong>（即多个驱动都对同一个 <code>virq</code> 调用了 <code>request_irq(irq, handler, IRQF_SHARED, ...)</code>），那么这个 <code>-&gt;action</code> 链表上就会有<strong>多个 <code>struct irqaction</code> 节点</strong>。每个节点都保存着一个设备驱动的中断服务函数。</p>
<p><strong>中断触发时</strong>：当一个<strong>特定的硬件中断</strong>发生，经过 <code>irq_domain</code> 翻译后，得到对应的<strong>一个虚拟中断号 <code>virqX</code></strong>。</p>
<ul>
<li>内核会找到 <code>irq_desc[virqX]</code>。</li>
<li>然后遍历 <strong><code>irq_desc[virqX]-&gt;action</code></strong> 这个链表。</li>
<li>调用这个链表上<strong>每一个</strong> <code>action-&gt;handler</code>。</li>
</ul>
</li>
</ol>
<h2 id="linux中断程序编写"><a href="#linux中断程序编写" class="headerlink" title="linux中断程序编写"></a>linux中断程序编写</h2><h3 id="中断的API函数"><a href="#中断的API函数" class="headerlink" title="中断的API函数"></a>中断的API函数</h3><h4 id="request-irq"><a href="#request-irq" class="headerlink" title="request_irq"></a>request_irq</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">irq_handler_t</span> handler,<span class="type">unsigned</span> <span class="type">long</span> flags,<span class="type">const</span> <span class="type">char</span> *name,<span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>**irq：**要申请中断的中断号。</p>
<p>**handler：**中断处理函数，当中断发生以后就会执行此中断处理函数。</p>
<p>**flags：**中断标志，可以在文件<code>include/linux/interrupt.h</code> 里面查看所有的中断标志</p>
<table>
<thead>
<tr>
<th align="left">标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IRQF_SHARED</td>
<td align="left">多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话，request_irq 函数的dev参数就是唯一区分他们的标志。</td>
</tr>
<tr>
<td align="left">IRQF_ONESHOT</td>
<td align="left">单次中断，中断执行一次就结束。</td>
</tr>
<tr>
<td align="left">IRQF_TRIGGER_NONE</td>
<td align="left">无触发。</td>
</tr>
<tr>
<td align="left">IRQF_TRIGGER_RISING</td>
<td align="left">上升沿触发。</td>
</tr>
<tr>
<td align="left">IRQF_TRIGGER_FALLING</td>
<td align="left">下降沿触发。</td>
</tr>
<tr>
<td align="left">IRQF_TRIGGER_HIGH</td>
<td align="left">高电平触发。</td>
</tr>
<tr>
<td align="left">IRQF_TRIGGER_LOW</td>
<td align="left">低电平触发。</td>
</tr>
</tbody></table>
<p>**name：**中断名字，设置以后可以在<code>/proc/interrupts</code> 文件中看到对应的中断名字。</p>
<p>**dev：**如果将flags设置为<code>IRQF_SHARED</code>的话，dev用来区分不同的中断，一般情况下将dev设置为设备结构体，dev会传递给中断处理函数<code>irq_handler_t</code>的第二个参数。</p>
<p>**返回值：**0中断申请成功，其他负值中断申请失败，如果返回<code>-EBUSY</code>的话表示中断已经被申请了。</p>
<h4 id="free-irq"><a href="#free-irq" class="headerlink" title="free_irq"></a>free_irq</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>

<p>**irq：**要释放的中断。</p>
<p>**dev：**如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉</p>
<p>**返回值：**无。</p>
<h4 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> (*<span class="type">irq_handler_t</span>) (<span class="type">int</span>, <span class="type">void</span> *)</span><br></pre></td></tr></table></figure>

<p><strong>第一个参数</strong>：是要中断处理函数要相应的中断号。</p>
<p>**第二个参数：**是一个指向void 的指针，也就是个通用指针，需要与request_irq 函数的dev 参数保持一致。</p>
<p>**返回值：**中断处理函数的返回值为irqreturn_t 类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line"> IRQ_NONE = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line"> IRQ_HANDLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line"> IRQ_WAKE_THREAD = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> <span class="title">irqreturn_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>一般使用：<strong>return IRQ_RETVAL(IRQ_HANDLED)</strong></p>
<h4 id="中断使能函数"><a href="#中断使能函数" class="headerlink" title="中断使能函数"></a>中断使能函数</h4><ol>
<li><p>控制<strong>当前 CPU</strong> 的全局中断状态（修改 CPSR 寄存器）：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>关键实现</th>
</tr>
</thead>
<tbody><tr>
<td><code>local_irq_enable()</code></td>
<td>使能当前 CPU 的 IRQ 中断（全局）</td>
<td><code>asm volatile(&quot;cpsie i&quot; ::: &quot;memory&quot;, &quot;cc&quot;)</code></td>
</tr>
<tr>
<td><code>local_irq_disable()</code></td>
<td><strong>禁止</strong>当前 CPU 的 IRQ 中断（全局）</td>
<td><code>asm volatile(&quot;cpsid i&quot; ::: &quot;memory&quot;, &quot;cc&quot;)</code></td>
</tr>
<tr>
<td><code>local_fiq_enable()</code></td>
<td>使能当前 CPU 的 FIQ 中断（全局）</td>
<td><code>asm volatile(&quot;cpsie f&quot; ::: &quot;memory&quot;, &quot;cc&quot;)</code></td>
</tr>
<tr>
<td><code>local_fiq_disable()</code></td>
<td><strong>禁止</strong>当前 CPU 的 FIQ 中断（全局）</td>
<td>‘asm volatile<code>asm volatile(&quot;cpsid f&quot; ::: &quot;memory&quot;, &quot;cc&quot;)</code></td>
</tr>
<tr>
<td><code>local_irq_save(flags)</code></td>
<td><strong>保存当前中断状态</strong>到 ，并<code>flags</code><strong>禁止</strong>IRQ 中断</td>
<td><code>mrs %0, cpsr</code>+<code>cpsid i</code>（保存 CPSR 后关中断）</td>
</tr>
<tr>
<td><code>local_irq_restore(flags)</code></td>
<td><strong>恢复</strong>之前保存的中断状态（通过 ）<code>flags</code></td>
<td><code>msr cpsr_c, %0</code>（恢复 CPSR 原始值）</td>
</tr>
<tr>
<td>‘本地<code>local_save_flags(flags)</code></td>
<td><strong>仅保存</strong>当前中断状态到 （中断状态）<code>flags</code><strong>不改变</strong></td>
<td><code>mrs %0, cpsr</code>（仅读取 CPSR）</td>
</tr>
</tbody></table>
</li>
<li><p><strong>特定 IRQ 线控制函数（中断控制器级）</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>关键实现</th>
</tr>
</thead>
<tbody><tr>
<td><code>enable_irq(unsigned int irq)</code></td>
<td><strong>使能</strong>指定中断线（全局生效）</td>
<td>调用中断控制器驱动使能该 IRQ;若之前被 禁止，会重新触发挂起中断<code>disable_irq</code></td>
</tr>
<tr>
<td><code>disable_irq(unsigned int irq)</code></td>
<td><strong>禁止</strong>指定中断线（全局生效），<strong>并等待</strong>中断处理完成（同步）</td>
<td>禁止 IRQ + 等待处理完成（可能睡眠）<code>synchronize_irq()</code></td>
</tr>
<tr>
<td><code>disable_irq_nosync(unsigned int irq)</code></td>
<td><strong>禁止</strong>指定中断线（全局生效），<strong>不等待</strong>中断处理完成（异步）</td>
<td>仅禁止 IRQ，不等待处理完成（<strong>不可在中断上下文调用</strong>）</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>Linux 内核通过读取设备树中的中断属性信息来配置中断，参考文档：<code>Documentation/devicetree/bindings/arm/gic.txt</code> imx6ull.dtsi文件找到</p>
<p><strong>顶层中断控制器intc–gic</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;<span class="comment">/*compatible 属性用于平台设备驱动的匹配*/</span></span><br><span class="line">		<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;<span class="comment">/*指定它的“子”中断控制器用几个cells 来描述一个中断，</span></span></span><br><span class="line"><span class="comment"><span class="meta">								 可理解为用几个参数来描述一个中断信息*/</span></span></span><br><span class="line">		interrupt-controller;<span class="comment">/*声明该设备树节点是一个中断控制器*/</span></span><br><span class="line">		reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,<span class="comment">/*reg 指定中断控制器相关寄存器的地址及大小*/</span></span><br><span class="line">		      &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第三行：#interrupt-cells 和#address-cells、#size-cells 一样。，#interrupt-cells 描述了interrupts 属性的cells 大小，也就是一条信息有几个cells。每个cells都是32位整形值，对于ARM处理的&#x3D;&#x3D;GIC 来说，一共有3 个cells&#x3D;&#x3D;，这三个cells 的含义如下：</p>
<ul>
<li>第一个cells：中断类型，0表示SPI中断，1表示PPI中断。</li>
<li>第二个cells：中断号，对于SPI中断来说中断号的范围为0<del>987，对于PPI中断来说中断号的范围为 0</del>15。</li>
<li>第三个cells：标志，bit[3:0]表示中断触发类型，为1的时候表示上升沿触发，为2的时候表示下降沿触发，为4的时候表示高电平触发，为8的时候表示低电平触发。bit[15:8]为PPI 中断的CPU掩码。</li>
</ul>
<p>第五行：表示当前节点是中断控制器。</p>
<p><strong>一级子中断控制器</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gpc: gpc@<span class="number">020</span>dc000 &#123;</span><br><span class="line">				compatible = <span class="string">&quot;fsl,imx6ul-gpc&quot;</span>, <span class="string">&quot;fsl,imx6q-gpc&quot;</span>;</span><br><span class="line">				reg = &lt;<span class="number">0x020dc000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">				interrupt-controller;<span class="comment">/*声明该设备树节点是一个中断控制器*/</span></span><br><span class="line">				<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;<span class="comment">/*使用三个参数来描述子控制器的信息*/</span></span></span><br><span class="line">				interrupts = &lt;GIC_SPI <span class="number">89</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    			<span class="comment">/*具体的中断描述信息</span></span><br><span class="line"><span class="comment">    			在该节点的中断控制器的“父”中断控制器intc中规定了使用三个cells来描述子控制器的信息</span></span><br><span class="line"><span class="comment">    			第一个参数用于指定中断类型：SPI 共享中断、PPI 私有中断、SGI 软件中断</span></span><br><span class="line"><span class="comment">    			第二个参数用于设定中断编号</span></span><br><span class="line"><span class="comment">    			第三个参数指定中断触发方式，</span></span><br><span class="line"><span class="comment">    			*/</span></span><br><span class="line">				interrupt-parent = &lt;&amp;intc&gt;;<span class="comment">/*指定该中断控制器的“父”中断控制器为intc,</span></span><br><span class="line"><span class="comment">											且除了“顶层中断控制器”其他中断控制器都要声明“父”中断控制器*/</span></span><br><span class="line">				fsl,mf-mix-wakeup-irq = &lt;<span class="number">0xfc00000</span> <span class="number">0x7d00</span> <span class="number">0x0</span> <span class="number">0x1400640</span>&gt;;</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>次级中断控制器–gpio控制器</strong></p>
<p>GPIO控制器作为<strong>次级中断控制器</strong>，其中断源是<strong>GPIO引脚</strong>。每个引脚的中断配置只需：</p>
<ul>
<li><strong>引脚号</strong>：标识具体的GPIO引脚（例如引脚9）。</li>
<li><strong>触发类型</strong>：定义中断的触发方式（如边沿、电平）。</li>
</ul>
<p>因此，不需要像GIC（主中断控制器）那样需要3个单元格（类型、全局中断号、标志），而是简化为 2 个单元格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">soc&#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpc&gt;;</span><br><span class="line">	ranges;</span><br><span class="line">	</span><br><span class="line">    gpio5: gpio@<span class="number">020</span>ac000 &#123;</span><br><span class="line">                    compatible = <span class="string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">                    reg = &lt;<span class="number">0x020ac000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                    interrupts = &lt;GIC_SPI <span class="number">74</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">75</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                    gpio-controller;</span><br><span class="line">                    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">                    interrupt-controller;</span><br><span class="line">                    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第4 行，interrupts 描述中断源信息，对于gpio5 来说一共有两条信息，中断类型都是SPI，触发电平都是<code>IRQ_TYPE_LEVEL_HIGH</code>。GPIO5一共用了2个中断号，一个是74，一个是75。其中74 对应<code>GPIO5_IO00~GPIO5_IO15</code> 这低16个IO，75 对<code>GPIO5_IO16~GPIOI5_IO31</code> 这高16 位IO。</p>
<p><strong>GPIO 引脚与 GIC 中断的映射</strong>：</p>
<ul>
<li>GPIO5 的引脚范围被分为两组：<ul>
<li>引脚 0~15 映射到 GIC 的 SPI 中断 74。</li>
<li>引脚 16~31 映射到 GIC 的 SPI 中断 75。</li>
</ul>
</li>
<li>当 GPIO5 的某个引脚触发中断时，硬件会将对应组的 GIC 中断（74 或 75）上报。</li>
</ul>
<p><img src="image-20250509205227708.png" alt="image-20250509205227708"></p>
<p>第8 行，interrupt-controller 表明了gpio5 节点也是个中断控制器，用于控制gpio5 所有IO的中断。</p>
<p>第9 行，将#interrupt-cells 修改为2。</p>
<p><strong>子中断控制器</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gt9147:gt9147@<span class="number">14</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;goodix,gt9147&quot;</span>, <span class="string">&quot;goodix,gt9xx&quot;</span>,<span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x14</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_tsc&gt;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio1&gt;;<span class="comment">//指定该设备的中断信号连接到哪个中断控制器。</span></span><br><span class="line">	interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;<span class="comment">//定义中断信号的引脚和触发方式。</span></span><br><span class="line">	reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	interrupt-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键参数详解</strong></p>
<p><strong><code>interrupt-parent = &lt;&amp;gpio1&gt;;</code></strong></p>
<ul>
<li><strong>作用</strong>：指定该设备的中断信号连接到哪个中断控制器。</li>
<li><strong>参数</strong>：<code>gpio1</code> 表示此设备的中断信号由 GPIO 控制器 1 管理。</li>
<li><strong>背景</strong>：在 SoC 中，GPIO 控制器通常也承担中断控制器的角色，负责将 GPIO 引脚的中断信号转发给主中断控制器（如 GIC）。</li>
</ul>
<p><strong><code>interrupts = &lt;9 0&gt;;</code></strong></p>
<ul>
<li><strong>作用</strong>：定义中断信号的引脚和触发方式。</li>
<li><strong>参数</strong>：<ul>
<li><strong>第一个参数（9）</strong>：在 <code>interrupt-parent</code> 指定的控制器（GPIO1）中，使用 <strong>第9号引脚</strong> 作为中断信号线。</li>
<li><strong>第二个参数（0）</strong>：中断触发类型，此处 <code>0</code> 表示 <strong>低电平触发</strong>（<code>IRQ_TYPE_LEVEL_LOW</code>）。<br><em>其他常见值：</em><ul>
<li><code>1</code>：上升沿触发（<code>IRQ_TYPE_EDGE_RISING</code>）</li>
<li><code>2</code>：下降沿触发（<code>IRQ_TYPE_EDGE_FALLING</code>）</li>
<li><code>3</code>：双边沿触发（<code>IRQ_TYPE_EDGE_BOTH</code>）</li>
<li><code>4</code>：高电平触发（<code>IRQ_TYPE_LEVEL_HIGH</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>interrupt-gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</code></strong></p>
<ul>
<li><strong>作用</strong>：指定中断引脚的具体 GPIO 控制器、引脚号和电平极性。</li>
<li><strong>参数</strong>：<ul>
<li><code>&amp;gpio1</code>：GPIO 控制器 1。</li>
<li><code>9</code>：GPIO1 的 9 号引脚。</li>
<li><code>GPIO_ACTIVE_LOW</code>：低电平有效（即引脚变为低电平时触发中断）</li>
</ul>
</li>
</ul>
<p>中断有关的设备树属性信息：</p>
<ul>
<li><p>#interrupt-cells，指定中断源的信息cells 个数。</p>
</li>
<li><p>interrupt-controller，表示当前节点为中断控制器。</p>
</li>
<li><p>interrupts，指定中断号，触发方式等。</p>
</li>
<li><p>interrupt-parent，指定父中断，也就是中断控制器。</p>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>GT9147（GPIO中断）</strong></th>
<th align="left"><strong>gpc（GIC中断）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>中断控制器</strong></td>
<td align="left">GPIO控制器（如 <code>gpio1</code>）</td>
<td align="left">GIC（通用中断控制器）</td>
</tr>
<tr>
<td align="left"><strong>中断号来源</strong></td>
<td align="left">GPIO引脚号（如 <code>9</code>）</td>
<td align="left">GIC分配的硬件中断号（如 <code>42</code>）</td>
</tr>
<tr>
<td align="left"><strong>触发类型编码</strong></td>
<td align="left">数字编码（<code>0</code>表示上升沿）</td>
<td align="left">直接使用宏（如 <code>IRQ_TYPE_EDGE_RISING</code>）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">外部设备通过GPIO引脚触发中断（如触摸屏）</td>
<td align="left">片内外设直接连接到GIC（如DMA、USB）</td>
</tr>
</tbody></table>
<ul>
<li><strong>GT9147节点</strong>：使用GPIO引脚作为中断源，硬件中断号是GPIO引脚号（需通过SoC文档或DTSI文件映射到GIC中断号）。</li>
<li><strong>gpc节点</strong>：直接使用GIC分配的硬件中断号，无需二次映射。</li>
</ul>
<h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>本次实验我们只使用按键中断，并通过驱动注册一个按键的<strong>中断服务函数</strong></p>
<p><strong>设备树添加节点：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key&#123;</span><br><span class="line">	compatible = <span class="string">&quot;kevin,key&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">	key-gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>驱动代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>				<span class="comment">/* GPIO描述符 */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span> <span class="comment">/* platform设备 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description		: 中断服务函数，开启定时器，延时10ms，</span></span><br><span class="line"><span class="comment"> *				  	  定时器用于按键消抖。</span></span><br><span class="line"><span class="comment"> * @param - irq 	: 中断号 </span></span><br><span class="line"><span class="comment"> * @param - dev_id	: 设备结构。</span></span><br><span class="line"><span class="comment"> * @return 			: 中断执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description	: 定时器服务函数，用于按键消抖，定时器到了以后</span></span><br><span class="line"><span class="comment"> *				  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span></span><br><span class="line"><span class="comment"> * @param - arg	: 设备结构变量</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpiod_get_value(keydesc-&gt;gpiod); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 按键IO初始化</span></span><br><span class="line"><span class="comment"> * @param - dev	: 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="keyword">struct</span> imx6uirq_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span> =</span> &amp;dev-&gt;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用devm_gpiod_get获取GPIO描述符 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod = devm_gpiod_get(pdev, <span class="string">&quot;key&quot;</span>, GPIOD_IN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod)) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用platform_get_irq获取中断号 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum = platform_get_irq(dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化key描述 */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;irqkeydesc[<span class="number">0</span>].name, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key0: gpio=%d, irqnum=%d\r\n&quot;</span>, </span><br><span class="line">	       desc_to_gpio(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod), </span><br><span class="line">	       dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	ret = devm_request_irq(pdev, dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].handler, </span><br><span class="line">	                      IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].name, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;irq %d request failed!\r\n&quot;</span>, </span><br><span class="line">		        dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建定时器 */</span></span><br><span class="line">	init_timer(&amp;dev-&gt;timer);</span><br><span class="line">	dev-&gt;timer.function = timer_function;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> imx6uirq_dev, cdev);</span><br><span class="line">	filp-&gt;private_data = dev;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : 从设备读取数据 </span></span><br><span class="line"><span class="comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment">  * @param - buf     : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment">  * @param - cnt     : 要读取的数据长度</span></span><br><span class="line"><span class="comment">  * @param - offt    : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment">  * @return          : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span>	</span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的probe函数，驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1、分配设备结构体 */</span></span><br><span class="line">	dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6uirq_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dev-&gt;pdev = pdev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;major) &#123;</span><br><span class="line">		dev-&gt;devid = MKDEV(dev-&gt;major, <span class="number">0</span>);</span><br><span class="line">		ret = register_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;dev-&gt;devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		dev-&gt;major = MAJOR(dev-&gt;devid);</span><br><span class="line">		dev-&gt;minor = MINOR(dev-&gt;devid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_devid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、注册字符设备 */</span></span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;imx6uirq_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_cdev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;class);</span><br><span class="line">		<span class="keyword">goto</span> fail_class;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dev-&gt;device = device_create(dev-&gt;class, <span class="literal">NULL</span>, dev-&gt;devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;device);</span><br><span class="line">		<span class="keyword">goto</span> fail_device;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、初始化按键 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);</span><br><span class="line">	ret = keyio_init(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_keyinit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 7、保存设备结构体到平台设备中 */</span></span><br><span class="line">	platform_set_drvdata(pdev, dev);</span><br><span class="line">	</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;imx6uirq driver probe success\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">fail_keyinit:</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">fail_device:</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">fail_class:</span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的remove函数，移除platform驱动时此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 删除定时器 */</span></span><br><span class="line">	del_timer_sync(&amp;dev-&gt;timer);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注销字符设备 */</span></span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx6uirq_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;kevin,key&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, imx6uirq_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6uirq_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6uirq&quot;</span>,</span><br><span class="line">		.of_match_table = imx6uirq_of_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6uirq_probe,</span><br><span class="line">	.remove = imx6uirq_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(imx6uirq_init);</span><br><span class="line">module_exit(imx6uirq_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kevin&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p><strong>共享中断实验</strong>，本次实验进一步来了解共享中断，我们首先来学习理论知识：</p>
<ul>
<li><p><strong>理论知识：</strong></p>
<p>当在 <code>request_irq</code> 函数中设置 <code>IRQF_SHARED</code> 标志时，表示我们希望<strong>共享中断线</strong>，即多个设备可以使用同一个硬件中断号。在这种情况下，<code>dev</code> 参数变得至关重要。</p>
</li>
<li><p><code>dev</code> 参数必须满足以下要求：</p>
<ol>
<li><strong>必须是唯一的</strong>：每个共享同一中断线的设备必须提供不同的 <code>dev</code> 值</li>
<li><strong>不能为 NULL</strong>：必须指向一个设备特定的数据结构</li>
<li><strong>用于标识中断源</strong>：当中断发生时，内核会使用这个值来确定是哪个设备触发了中断</li>
</ol>
</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_IRQ_NUM 17  <span class="comment">// 假设我们要共享的中断号是17</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个设备的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_one_data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 其他设备特定数据...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个设备的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_two_data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 其他设备特定数据...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备实例</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_one_data</span> <span class="title">dev1_data</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;device_one&quot;</span>,</span><br><span class="line">    .id = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_two_data</span> <span class="title">dev2_data</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;device_two&quot;</span>,</span><br><span class="line">    .id = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数 - 设备1</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">device_one_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_one_data</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> device_one_data *)dev_id;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handled by %s (ID: %d)\n&quot;</span>, </span><br><span class="line">           data-&gt;name, data-&gt;id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否真的是这个设备产生的中断</span></span><br><span class="line">    <span class="comment">// if (!is_device_one_interrupt())</span></span><br><span class="line">    <span class="comment">//     return IRQ_NONE;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理设备1的中断</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数 - 设备2</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">device_two_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_two_data</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> device_two_data *)dev_id;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handled by %s (ID: %d)\n&quot;</span>, </span><br><span class="line">           data-&gt;name, data-&gt;id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否真的是这个设备产生的中断</span></span><br><span class="line">    <span class="comment">// if (!is_device_two_interrupt())</span></span><br><span class="line">    <span class="comment">//     return IRQ_NONE;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理设备2的中断</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Registering shared interrupts\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册第一个设备的中断处理程序</span></span><br><span class="line">    ret = request_irq(SHARED_IRQ_NUM, device_one_interrupt, </span><br><span class="line">                     IRQF_SHARED, <span class="string">&quot;my_device_one&quot;</span>, &amp;dev1_data);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ for device one: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册第二个设备的中断处理程序</span></span><br><span class="line">    ret = request_irq(SHARED_IRQ_NUM, device_two_interrupt, </span><br><span class="line">                     IRQF_SHARED, <span class="string">&quot;my_device_two&quot;</span>, &amp;dev2_data);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ for device two: %d\n&quot;</span>, ret);</span><br><span class="line">        free_irq(SHARED_IRQ_NUM, &amp;dev1_data); <span class="comment">// 清理第一个设备</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Unregistering shared interrupts\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须使用与注册时相同的dev参数来释放中断</span></span><br><span class="line">    free_irq(SHARED_IRQ_NUM, &amp;dev1_data);</span><br><span class="line">    free_irq(SHARED_IRQ_NUM, &amp;dev2_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;KEVIN&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Example of shared interrupt handling&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="中断的上半部与下半部"><a href="#中断的上半部与下半部" class="headerlink" title="中断的上半部与下半部"></a>中断的上半部与下半部</h2><p>Linux内核将中断分为上半部和下半部的主要目的就是<strong>实现中断处理函数的快进快出</strong>，我们在使用<strong>request_irq</strong>申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。</p>
<p><strong>上半部：<strong>上半部就是中断处理函数，那些</strong>处理过程比较快</strong>，<strong>不会占用很长时间</strong>的处理就可以放在上半部完成。</p>
<p><strong>下半部：<strong>如果中断</strong>处理过程比较耗时</strong>，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</p>
<p><strong>可以参考：</strong></p>
<ul>
<li>如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li>
<li>如果要处理的任务对时间敏感，可以放到上半部。</li>
<li>如果要处理的任务与硬件有关，可以放到上半部</li>
<li>除了上述三点以外的其他任务，优先考虑放到下半部</li>
</ul>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>Linux 内核使用<strong>结构体softirq_action 表示软中断</strong>， softirq_action结构体定义在文include&#x2F;linux&#x2F;interrupt.h中<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L555">softirq_action</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span>	(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在&#x2F;include&#x2F;linux&#x2F;interrupt.h 文件中一共定义了10 个软中断，如下所示：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L528">interrupt.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组softirq_vec 有10 个元素。softirq_action结构体中的action成员变量就是软中断的服务函数，数组softirq_vec是个全局数组，因此所有的CPU(对于SMP系统而言)都可以访问到，每个CPU都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个CPU所执行的软中断服务函数确是相同的，都是数组softirq_vec 中定义的action函数。</p>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>执行上下文</strong>：<strong>软中断上下文</strong>。处于中断退出阶段，不属于任何进程。</p>
</li>
<li><p><strong>抢占与睡眠</strong>：<strong>不能睡眠&#x2F;阻塞</strong>（因为不属于进程，没有任务结构体去调度）。执行时<strong>开中断</strong>，可以被新的硬件中断打断，但不能被自身嵌套（同一个CPU上同类型软中断不会重入）。</p>
</li>
<li><p><strong>并发性</strong>：<strong>所有CPU上都可以同时运行</strong>，即使是同一种类型的软中断。这意味着开发者必须自己处理复杂的<strong>锁机制</strong>（如自旋锁）来保护共享数据，编程难度高。</p>
</li>
<li><p><strong>执行延迟</strong>：<strong>延迟极低</strong>。一旦中断退出，会立刻检查并执行pending的软中断，响应非常快。</p>
</li>
<li><p><strong>静态分配</strong>：内核编译时静态定义（如 <code>HI_SOFTIRQ</code>, <code>TIMER_SOFTIRQ</code>, <code>NET_TX_SOFTIRQ</code>, <code>NET_RX_SOFTIRQ</code>），数量有限，不能动态注册。</p>
</li>
<li><p><strong>机制</strong>：通过 <code>raise_softirq()</code> 触发，在 <code>irq_exit()</code> 中检查并执行。</p>
</li>
<li><p>对<strong>性能要求极高</strong>、<strong>执行频率非常高</strong>的场景。</p>
</li>
<li><p>典型代表：<strong>网络子系统</strong>（收发数据包）、<strong>块设备子系统</strong>（IO调度）。</p>
</li>
<li><p>内核定时器的底半部 (<code>TIMER_SOFTIRQ</code>) 也使用它。</p>
</li>
</ul>
<h4 id="软中断API函数"><a href="#软中断API函数" class="headerlink" title="软中断API函数"></a>软中断API函数</h4><p><strong>注册软中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>nr</code>：软中断号（0-9），例如：<code>TASKLET_SOFTIRQ</code>、<code>HI_SOFTIRQ</code>等</li>
<li><code>action</code>：软中断处理函数指针</li>
</ul>
</li>
<li><strong>说明</strong>：注册一个软中断类型及其处理函数</li>
</ul>
<p><strong>触发软中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>nr</code>：要触发的软中断号</li>
</ul>
</li>
<li><strong>说明</strong>：在适当的时候（通常是中断返回时），内核会检查并执行已触发的软中断</li>
</ul>
<h4 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h4><p>伪代码：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义软中断号 (需要在已定义的软中断之后)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_SOFTIRQ 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_device</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">// 其他设备相关数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *softirq_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软中断共享的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">softirq_data</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> jiffies;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">my_device</span> my_dev;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">softirq_data</span> *local_data = data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在软中断上下文中处理数据</span></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;My softirq handler running on CPU %d, count: %u, jiffies: %lu\n&quot;</span>,</span><br><span class="line">           <span class="built_in">smp_processor_id</span>(), local_data-&gt;count, local_data-&gt;jiffies);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟一些处理工作</span></span><br><span class="line">    local_data-&gt;count++;</span><br><span class="line">    local_data-&gt;jiffies = jiffies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断处理函数（顶半部）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">my_device</span> *dev = (<span class="keyword">struct</span> my_device *)dev_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速处理紧急任务</span></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;IRQ handler running on CPU %d\n&quot;</span>, <span class="built_in">smp_processor_id</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新要传递给软中断的数据</span></span><br><span class="line">    data-&gt;count = <span class="number">1</span>;</span><br><span class="line">    data-&gt;jiffies = jiffies;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发软中断</span></span><br><span class="line">    <span class="built_in">raise_softirq</span>(MY_SOFTIRQ);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">my_softirq_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Initializing my softirq module\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配软中断数据结构</span></span><br><span class="line">    data = <span class="built_in">kmalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> softirq_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;Failed to allocate softirq data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化设备结构</span></span><br><span class="line">    my_dev.name = <span class="string">&quot;my_softirq_device&quot;</span>;</span><br><span class="line">    my_dev.softirq_data = data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册软中断</span></span><br><span class="line">    <span class="built_in">open_softirq</span>(MY_SOFTIRQ, my_softirq_handler);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Registered softirq %d\n&quot;</span>, MY_SOFTIRQ);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在实际驱动中，这里会请求硬件IRQ</span></span><br><span class="line">    <span class="comment">// 为了示例，我们假设IRQ号为10</span></span><br><span class="line">    ret = <span class="built_in">request_irq</span>(<span class="number">10</span>, my_irq_handler, IRQF_SHARED, </span><br><span class="line">                     <span class="string">&quot;my_softirq_device&quot;</span>, &amp;my_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;Failed to request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="built_in">kfree</span>(data);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">my_softirq_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Exiting my softirq module\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放IRQ</span></span><br><span class="line">    <span class="built_in">free_irq</span>(<span class="number">10</span>, &amp;my_dev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(my_softirq_init);</span><br><span class="line"><span class="built_in">module_exit</span>(my_softirq_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;kevin&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_DESCRIPTION</span>(<span class="string">&quot;Example of using softirq in a driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h3><p>Tasklet 是一种<strong>软中断（SoftIRQ）</strong> 机制，用于处理中断下半部（bottom half）的任务。它运行在<strong>中断上下文</strong>（但不在硬中断处理函数中），具有以下特点：</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>执行上下文</strong>：<strong>软中断上下文</strong>（基于 <code>HI_SOFTIRQ</code> 和 <code>TASKLET_SOFTIRQ</code> 两种软中断实现）。</li>
<li><strong>抢占与睡眠</strong>：<strong>不能睡眠&#x2F;阻塞</strong>，原因同软中断。</li>
<li><strong>并发性</strong>：这是与软中断的<strong>关键区别</strong>。<strong>同一种类的tasklet在多个CPU上是串行执行的</strong>。一个tasklet一旦在某CPU上被调度执行，其他CPU不会同时执行同一种类的tasklet。这大大<strong>降低了并发编程的复杂度</strong>，通常不需要考虑复杂的锁。</li>
<li><strong>执行延迟</strong>：延迟低，与软中断类似，机制相同。</li>
<li><strong>动态分配</strong>：可以动态创建和初始化，使用灵活。</li>
<li><strong>机制</strong>：通过 <code>tasklet_schedule()</code> 调度。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要延后执行、<strong>频率较高</strong>但<strong>不需要复杂并发控制</strong>的设备驱动程序。</li>
<li>是<strong>大多数设备驱动程序首选的底半部机制</strong>（除非性能要求极高到必须用软中断）。</li>
<li>典型例子：<strong>按键中断</strong>、<strong>鼠标中断</strong>等。将读取数据等操作放在顶半部，将数据处理和报告事件的工作放在tasklet中。</li>
</ul>
<img src="image-20250903221103956.png" alt="image-20250903221103956" style="zoom: 67%;">

<h4 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h4><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DECLARE_TASKLET(name, _callback)</code></td>
<td align="left">声明并初始化一个 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data)</code></td>
<td align="left">动态初始化一个 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_schedule(struct tasklet_struct *t)</code></td>
<td align="left">调度一个普通优先级的 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_hi_schedule(struct tasklet_struct *t)</code></td>
<td align="left">调度一个高优先级的 tasklet</td>
</tr>
<tr>
<td align="left"><code>void tasklet_kill(struct tasklet_struct *t)</code></td>
<td align="left">杀死（取消）一个 tasklet</td>
</tr>
</tbody></table>
<h4 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h4><p>本次实验是基于实验一中的代码进行编写，我们首先分析需要将哪部分的代码放在中断的下半部分，按键消抖和状态检测不需要在中断上半部立即执行，因为它们<strong>非紧急处理</strong>。</p>
<p><strong>主要的代码分析：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;&#125;</span><br><span class="line">tasklet_init(&amp;dev-&gt;tasklet, key_tasklet_func, (<span class="type">unsigned</span> <span class="type">long</span>)dev);<span class="comment">//初始化</span></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;tasklet);<span class="comment">//中断服务函数的最后调用</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span>  <span class="comment">/* 新增：软中断相关头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>				<span class="comment">/* GPIO描述符 */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span> <span class="comment">/* platform设备 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span> <span class="comment">/* 新增：tasklet软中断结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新增：软中断处理函数，替代原来的定时器函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)data;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 延时一小段时间进行消抖 */</span></span><br><span class="line">	udelay(<span class="number">10000</span>);  <span class="comment">/* 10ms延时 */</span></span><br><span class="line">	</span><br><span class="line">	value = gpiod_get_value(keydesc-&gt;gpiod); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description		: 中断服务函数，触发软中断处理</span></span><br><span class="line"><span class="comment"> * @param - irq 	: 中断号 </span></span><br><span class="line"><span class="comment"> * @param - dev_id	: 设备结构。</span></span><br><span class="line"><span class="comment"> * @return 			: 中断执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 触发软中断，替代原来的定时器 */</span></span><br><span class="line">	tasklet_schedule(&amp;dev-&gt;tasklet);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 按键IO初始化</span></span><br><span class="line"><span class="comment"> * @param - dev	: 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="keyword">struct</span> imx6uirq_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span> =</span> &amp;dev-&gt;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用devm_gpiod_get获取GPIO描述符 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod = devm_gpiod_get(pdev, <span class="string">&quot;key&quot;</span>, GPIOD_IN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod)) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用platform_get_irq获取中断号 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum = platform_get_irq(dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化key描述 */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;irqkeydesc[<span class="number">0</span>].name, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key0: gpio=%d, irqnum=%d\r\n&quot;</span>, </span><br><span class="line">	       desc_to_gpio(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod), </span><br><span class="line">	       dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	ret = devm_request_irq(pdev, dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].handler, </span><br><span class="line">	                      IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].name, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;irq %d request failed!\r\n&quot;</span>, </span><br><span class="line">		        dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化tasklet软中断，替代原来的定时器初始化 */</span></span><br><span class="line">	tasklet_init(&amp;dev-&gt;tasklet, key_tasklet_func, (<span class="type">unsigned</span> <span class="type">long</span>)dev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> imx6uirq_dev, cdev);</span><br><span class="line">	filp-&gt;private_data = dev;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : 从设备读取数据 </span></span><br><span class="line"><span class="comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment">  * @param - buf     : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment">  * @param - cnt     : 要读取的数据长度</span></span><br><span class="line"><span class="comment">  * @param - offt    : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment">  * @return          : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span>	</span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的probe函数，驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1、分配设备结构体 */</span></span><br><span class="line">	dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6uirq_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dev-&gt;pdev = pdev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;major) &#123;</span><br><span class="line">		dev-&gt;devid = MKDEV(dev-&gt;major, <span class="number">0</span>);</span><br><span class="line">		ret = register_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;dev-&gt;devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		dev-&gt;major = MAJOR(dev-&gt;devid);</span><br><span class="line">		dev-&gt;minor = MINOR(dev-&gt;devid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_devid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、注册字符设备 */</span></span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;imx6uirq_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_cdev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;class);</span><br><span class="line">		<span class="keyword">goto</span> fail_class;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dev-&gt;device = device_create(dev-&gt;class, <span class="literal">NULL</span>, dev-&gt;devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;device);</span><br><span class="line">		<span class="keyword">goto</span> fail_device;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、初始化按键 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);</span><br><span class="line">	ret = keyio_init(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_keyinit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 7、保存设备结构体到平台设备中 */</span></span><br><span class="line">	platform_set_drvdata(pdev, dev);</span><br><span class="line">	</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;imx6uirq driver probe success\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">fail_keyinit:</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">fail_device:</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">fail_class:</span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的remove函数，移除platform驱动时此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 销毁tasklet软中断，替代原来的删除定时器 */</span></span><br><span class="line">	tasklet_kill(&amp;dev-&gt;tasklet);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注销字符设备 */</span></span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx6uirq_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;kevin,key&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, imx6uirq_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6uirq_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6uirq&quot;</span>,</span><br><span class="line">		.of_match_table = imx6uirq_of_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6uirq_probe,</span><br><span class="line">	.remove = imx6uirq_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(imx6uirq_init);</span><br><span class="line">module_exit(imx6uirq_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kevin&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p><strong>工作队列（Workqueue）</strong> 就是一种非常常用的将工作推后到<strong>进程上下文</strong>中执行的方法。</p>
<p>它的核心思想是：</p>
<ol>
<li><p>你把一个想要推后执行的任务（函数）包装成一个<strong>工作（work）</strong>。</p>
</li>
<li><p>将这个工作提交到一个<strong>队列（queue）</strong> 中。</p>
</li>
<li><p>内核会有一个或多个专用的内核线程（称为<strong>工作者线程，worker thread</strong>）被创建来处理这个队列。</p>
</li>
<li><p>当线程被调度时，它会从队列中取出工作并执行其中指定的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的工作 (work) ---&gt; 被加入 ---&gt; 工作队列 (workqueue) ---&gt; 由 ---&gt; 工作者线程 (worker thread) 处理</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>执行上下文</strong>：<strong>进程上下文</strong>。由专门的内核线程(<code>kworker</code>)来执行其工作函数。</li>
<li><strong>抢占与睡眠</strong>：<strong>可以睡眠&#x2F;阻塞</strong>！这是它与前两者最根本的区别。因为它运行在进程上下文，可以被调度器抢占，也可以调用<code>schedule()</code>主动让出CPU，或者等待信号量、分配内存时阻塞。</li>
<li><strong>并发性</strong>：默认情况下，工作项（work）会被排入一个全局队列，由某个<code>kworker</code>线程执行，并发性由锁控制。也有并发工作队列（<code>CMWQ</code>）等更先进的机制来精细控制并发度。</li>
<li><strong>执行延迟</strong>：<strong>延迟相对较高</strong>。因为它需要唤醒一个内核线程，然后由调度器来分配CPU时间片，这比直接在中退出路径上执行的软中断&#x2F; tasklet 要慢。</li>
<li><strong>动态分配</strong>：可以动态创建。可以创建自己的专用工作队列线程，也可以使用内核共享的默认工作队列。</li>
<li><strong>机制</strong>：通过 <code>schedule_work()</code> 调度到默认队列，或 <code>queue_work()</code> 到自定义队列。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要<strong>睡眠</strong>的任务。这是选择工作队列的<strong>最决定性因素</strong>。</li>
<li>需要<strong>执行大量、耗时操作</strong>的任务（如大数据块IO、文件系统操作）。</li>
<li>典型例子：驱动需要与用户空间交互（这可能需要等待）、需要分配可能阻塞的内存（<code>GFP_KERNEL</code>）、需要等待磁盘IO完成。</li>
</ul>
<h4 id="工作队列的运行模式"><a href="#工作队列的运行模式" class="headerlink" title="工作队列的运行模式"></a>工作队列的运行模式</h4><ul>
<li><p><strong>单线程式 (Single-threaded)</strong>：所有提交到某个工作队列的工作都由<strong>同一个</strong>内核线程处理。这意味着工作是串行执行的，一个接一个。</p>
<p><img src="image-20250903222052475.png" alt="image-20250903222052475"></p>
</li>
<li><p><strong>多线程式 (Multi-threaded)</strong>：工作可以由<strong>多个</strong>内核线程处理（例如，每个CPU一个线程，或者为不同类型的任务创建不同优先级的线程池）。这允许工作在多个CPU上<strong>并发</strong>执行，提高了吞吐量。</p>
<p><img src="image-20250903222104650.png" alt="image-20250903222104650"></p>
</li>
</ul>
<h4 id="工作队列的弊端"><a href="#工作队列的弊端" class="headerlink" title="工作队列的弊端"></a>工作队列的弊端</h4><p><strong>工作项（work item）的延迟执行和阻塞</strong>。</p>
<img src="image-20250903222213819.png" alt="image-20250903222213819" style="zoom:50%;">

<p><strong>场景分析：</strong></p>
<ul>
<li>有三个工作项 <code>w0</code>, <code>w1</code>, <code>w2</code> 被加入到<strong>同一个</strong>工作队列（绑定到同一个CPU）。</li>
<li><code>w0</code> 先执行：<ul>
<li><code>0-5ms</code>: 占用CPU（执行计算）。</li>
<li><code>5-15ms</code>: <strong>睡眠（sleep）</strong>。这是关键！因为它运行在<strong>同一个</strong>工作者线程中，所以当 <code>w0</code> 睡眠时，整个线程都被挂起了。</li>
<li><code>15-20ms</code>: 醒来继续占用CPU直到结束。</li>
</ul>
</li>
<li><code>w0</code> 在 <code>20ms</code> 结束后，线程才开始处理 <code>w1</code>。</li>
<li>同理，<code>w1</code> 的睡眠又阻塞了 <code>w2</code> 的执行</li>
</ul>
<p><strong>结论：<strong>因为 <code>w0</code>, <code>w1</code>, <code>w2</code> 共享同一个执行线程，所以任何一个工作的</strong>睡眠或长时间操作</strong>都会<strong>阻塞</strong>后续所有工作的执行。这会导致其他工作的处理产生不可预测的<strong>延迟（latency）</strong>。</p>
<h4 id="工作队列的API函数"><a href="#工作队列的API函数" class="headerlink" title="工作队列的API函数"></a>工作队列的API函数</h4><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">参数</th>
<th align="left">作用</th>
<th align="left">返回值&#x2F;注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DECLARE_WORK(name, func)</code></strong></td>
<td align="left"><code>name</code>: <strong>struct work_struct</strong> 变量名 <code>func</code>: 要执行的下半部函数 (<strong>void (*func)(struct work_struct *work)</strong>)</td>
<td align="left"><strong>静态地</strong>声明并初始化一个工作结构体。通常在文件全局或结构体内部使用。</td>
<td align="left">宏。声明一个名为 <code>name</code> 的 work_struct。</td>
</tr>
<tr>
<td align="left"><strong><code>INIT_WORK(work, func)</code></strong></td>
<td align="left"><code>work</code>: 指向已存在的 <strong>struct work_struct</strong> 的指针 <code>func</code>: 下半部函数</td>
<td align="left"><strong>动态地</strong>初始化一个已经分配好的工作结构体（例如，在你自己定义的设备结构体中）。</td>
<td align="left">宏。通常在 <code>kmalloc</code> 或 <code>devm_kzalloc</code> 分配内存后调用。</td>
</tr>
<tr>
<td align="left"><strong><code>schedule_work(work)</code></strong></td>
<td align="left"><code>work</code>: 指向已初始化的 <strong>struct work_struct</strong> 的指针</td>
<td align="left">将工作提交到<strong>系统共享的全局工作队列（system_wq）</strong>。工作者线程会在稍后某个时间执行它。</td>
<td align="left"><strong>返回：</strong> int <code>0</code>： 工作已在队列中，未重复添加。 非 <code>0</code>： 工作已成功添加到队列等待执行。</td>
</tr>
<tr>
<td align="left"><strong><code>cancel_work_sync(work)</code></strong></td>
<td align="left"><code>work</code>: 指向要取消的 <strong>struct work_struct</strong> 的指针</td>
<td align="left"><strong>取消一个已排队但尚未开始执行的工作</strong>。如果工作已经开始执行，则函数会等待其执行完毕。<strong>防止竞争的必要措施。</strong></td>
<td align="left"><strong>注意：</strong> 必须确保在之后工作不会再被调度（例如，在模块卸载或设备断开时调用）。不能在中断上下文使用。</td>
</tr>
</tbody></table>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testwork_func_t</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度work */</span></span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化work */</span></span><br><span class="line">INIT_WORK(&amp;testwork, <span class="type">testwork_func_t</span>);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="延迟工作队列"><a href="#延迟工作队列" class="headerlink" title="延迟工作队列"></a>延迟工作队列</h4><h5 id="api函数"><a href="#api函数" class="headerlink" title="api函数"></a>api函数</h5><table>
<thead>
<tr>
<th align="left">函数&#x2F;宏</th>
<th align="left">参数</th>
<th align="left">作用</th>
<th align="left">返回值&#x2F;注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DECLARE_DELAYED_WORK(name, func)</code></strong></td>
<td align="left"><code>name</code>: <strong>struct delayed_work</strong> 变量名 <code>func</code>: 下半部函数</td>
<td align="left"><strong>静态地</strong>声明并初始化一个<strong>延迟</strong>工作结构体。</td>
<td align="left">宏。<code>struct delayed_work</code> 内部包含了一个普通的 <code>work_struct</code> 和一个定时器。</td>
</tr>
<tr>
<td align="left"><strong><code>INIT_DELAYED_WORK(work, func)</code></strong></td>
<td align="left"><code>work</code>: 指向已存在的 <strong>struct delayed_work</strong> 的指针 <code>func</code>: 下半部函数</td>
<td align="left"><strong>动态地</strong>初始化一个已经分配好的<strong>延迟</strong>工作结构体。</td>
<td align="left">宏。</td>
</tr>
<tr>
<td align="left"><strong><code>schedule_delayed_work(dwork, delay)</code></strong></td>
<td align="left"><code>dwork</code>: 指向已初始化的 <strong>struct delayed_work</strong> 的指针 <code>delay</code>: 延迟的时间，单位是 <strong>jiffies</strong></td>
<td align="left">将工作提交到系统共享的全局工作队列，并指定一个<strong>延迟</strong>。工作者线程会在 <code>delay</code> 时间之后才执行它。</td>
<td align="left"><strong>返回：</strong> int <code>0</code>： 失败（工作已在队列中）。 非 <code>0</code>： 成功。 <strong>提示：</strong> 可用 <code>msecs_to_jiffies(ms)</code> 将毫秒转换为 jiffies。</td>
</tr>
<tr>
<td align="left"><strong><code>flush_delayed_work(dwork)</code></strong></td>
<td align="left"><code>dwork</code>: 指向 <strong>struct delayed_work</strong> 的指针</td>
<td align="left"><strong>刷新</strong>延迟工作。等待一个已经排队的延迟工作执行完毕。如果延迟尚未到期，它会先取消延迟，然后立即将工作放入队列执行，并等待其完成。</td>
<td align="left"><strong>返回：</strong> bool <code>false</code>： 工作未在执行，已被刷新。 <code>true</code>： 工作正在执行，函数等待其完成。</td>
</tr>
<tr>
<td align="left"><strong><code>cancel_delayed_work_sync(dwork)</code></strong></td>
<td align="left"><code>dwork</code>: 指向要取消的 <strong>struct delayed_work</strong> 的指针</td>
<td align="left"><strong>取消一个已排队的延迟工作</strong>。如果工作已经在执行，则等待其执行完毕。<strong>防止竞争的必要措施。</strong></td>
<td align="left">与 <code>cancel_work_sync</code> 类似，但用于延迟工作。</td>
</tr>
</tbody></table>
<h5 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h5><p>本实验是在实验一的基础上进行改进的，</p>
<ol>
<li>按键消抖本质上就是一个需要延迟执行的任务</li>
<li>使用<code>delayed_work</code>可以直接替代定时器，代码更简洁</li>
<li>内核的延时工作队列机制已经优化得很好，性能足够</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span> <span class="comment">// 可以删除，但保留以防其他依赖</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">// 添加工作队列头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>				<span class="comment">/* GPIO描述符 */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span> <span class="comment">/* platform设备 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">key_work</span>;</span> <span class="comment">/* 按键消抖工作项 */</span> <span class="comment">// 替换 timer_list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description	: 工作队列处理函数，用于按键消抖</span></span><br><span class="line"><span class="comment"> * @param - work: 工作项</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(to_delayed_work(work), </span><br><span class="line">						<span class="keyword">struct</span> imx6uirq_dev, key_work);</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpiod_get_value(keydesc-&gt;gpiod); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @description		: 中断服务函数，调度延迟工作队列进行按键消抖</span></span><br><span class="line"><span class="comment"> * @param - irq 	: 中断号 </span></span><br><span class="line"><span class="comment"> * @param - dev_id	: 设备结构。</span></span><br><span class="line"><span class="comment"> * @return 			: 中断执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	schedule_delayed_work(&amp;dev-&gt;key_work, msecs_to_jiffies(<span class="number">10</span>)); <span class="comment">/* 10ms后执行工作队列 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 按键IO初始化</span></span><br><span class="line"><span class="comment"> * @param - dev	: 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="keyword">struct</span> imx6uirq_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span> =</span> &amp;dev-&gt;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用devm_gpiod_get获取GPIO描述符 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod = devm_gpiod_get(pdev, <span class="string">&quot;key&quot;</span>, GPIOD_IN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod)) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用platform_get_irq获取中断号 */</span></span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum = platform_get_irq(dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;can&#x27;t get key irq number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化key描述 */</span></span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;irqkeydesc[<span class="number">0</span>].name, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	dev-&gt;irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化延迟工作队列 */</span></span><br><span class="line">	INIT_DELAYED_WORK(&amp;dev-&gt;key_work, key_work_handler);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key0: gpio=%d, irqnum=%d\r\n&quot;</span>, </span><br><span class="line">	       desc_to_gpio(dev-&gt;irqkeydesc[<span class="number">0</span>].gpiod), </span><br><span class="line">	       dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	ret = devm_request_irq(pdev, dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].handler, </span><br><span class="line">	                      IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, </span><br><span class="line">	                      dev-&gt;irqkeydesc[<span class="number">0</span>].name, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pdev, <span class="string">&quot;irq %d request failed!\r\n&quot;</span>, </span><br><span class="line">		        dev-&gt;irqkeydesc[<span class="number">0</span>].irqnum);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode 	: 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp 	: 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> * 					  一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> imx6uirq_dev, cdev);</span><br><span class="line">	filp-&gt;private_data = dev;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     : 从设备读取数据 </span></span><br><span class="line"><span class="comment">  * @param - filp    : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment">  * @param - buf     : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment">  * @param - cnt     : 要读取的数据长度</span></span><br><span class="line"><span class="comment">  * @param - offt    : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment">  * @return          : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span>	</span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的probe函数，驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1、分配设备结构体 */</span></span><br><span class="line">	dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6uirq_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dev-&gt;pdev = pdev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、构建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;major) &#123;</span><br><span class="line">		dev-&gt;devid = MKDEV(dev-&gt;major, <span class="number">0</span>);</span><br><span class="line">		ret = register_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;dev-&gt;devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		dev-&gt;major = MAJOR(dev-&gt;devid);</span><br><span class="line">		dev-&gt;minor = MINOR(dev-&gt;devid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_devid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、注册字符设备 */</span></span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;imx6uirq_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">	ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_cdev;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;class);</span><br><span class="line">		<span class="keyword">goto</span> fail_class;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dev-&gt;device = device_create(dev-&gt;class, <span class="literal">NULL</span>, dev-&gt;devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;device);</span><br><span class="line">		<span class="keyword">goto</span> fail_device;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、初始化按键 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);</span><br><span class="line">	ret = keyio_init(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail_keyinit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 7、保存设备结构体到平台设备中 */</span></span><br><span class="line">	platform_set_drvdata(pdev, dev);</span><br><span class="line">	</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;imx6uirq driver probe success\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">fail_keyinit:</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">fail_device:</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">fail_class:</span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: platform驱动的remove函数，移除platform驱动时此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - pdev: platform设备</span></span><br><span class="line"><span class="comment"> * @return 		: 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 取消延迟工作队列 */</span></span><br><span class="line">	cancel_delayed_work_sync(&amp;dev-&gt;key_work);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 注销字符设备 */</span></span><br><span class="line">	cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">	unregister_chrdev_region(dev-&gt;devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(dev-&gt;class, dev-&gt;devid);</span><br><span class="line">	class_destroy(dev-&gt;class);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx6uirq_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;kevin,key&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, imx6uirq_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx6uirq_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;imx6uirq&quot;</span>,</span><br><span class="line">		.of_match_table = imx6uirq_of_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = imx6uirq_probe,</span><br><span class="line">	.remove = imx6uirq_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;imx6uirq_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(imx6uirq_init);</span><br><span class="line">module_exit(imx6uirq_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kevin&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="CMWQ工作队列"><a href="#CMWQ工作队列" class="headerlink" title="CMWQ工作队列"></a>CMWQ工作队列</h4><p><strong>Concurrency Managed Workqueue</strong>，即<strong>并发托管的工作队列</strong>。</p>
<p>CMWQ 的核心思想是<strong>将工作项的提交（生产者）与工作线程的管理（消费者）完全分离</strong>。开发者只需关心将工作项提交到哪个工作队列，而内核则负责以最优化、最高效的方式动态管理执行这些工作项所需的线程（称为 worker）及其并发度。</p>
<p><img src="image-20250903225324180.png" alt="image-20250903225324180"></p>
<p><strong>目的：</strong></p>
<ul>
<li><strong>线程浪费</strong>：每个工作队列（workqueue）都有自己的专用线程（<code>kworker</code>）。如果系统中有很多驱动都创建了自己的工作队列，就会产生大量大部分时间都在休眠的线程，浪费资源。</li>
<li><strong>并发性差</strong>：传统的每CPU工作队列，其并发度是固定的（通常是每CPU一个线程）。如果一个工作项阻塞（如工作队列小节的图片中 <code>w0</code> 睡眠），那么该CPU上该队列的所有后续工作项都会被阻塞，即使系统有其他空闲的CPU核心也无法帮忙处理。</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li><strong>线程池化（Thread Pooling）</strong><ul>
<li>内核预先创建好一组通用的工作线程（<code>kworker/uX:Y</code> 和 <code>kworker/uX:Y</code>），称为 <strong>worker_pool</strong>。</li>
<li>所有通过 CMWQ API（如 <code>schedule_work()</code> ）提交的工作项，最终都由这个共享的线程池来处理。</li>
<li><strong>好处</strong>：极大地减少了系统内核线程的数量，节省了内存和上下文切换的开销。</li>
</ul>
</li>
<li><strong>动态并发管理（Dynamic Concurrency Management）</strong><ul>
<li>这是“并发托管”中“托管”的含义。内核会<strong>自动管理</strong>执行工作项所需的线程数量。</li>
<li><strong>规则</strong>：只要有一个可运行（runnable）的工作项，内核就会尝试提供一个空闲的线程来执行它。如果没有空闲线程，内核可以根据需要<strong>动态创建新的线程</strong>。</li>
<li><strong>好处</strong>：<ul>
<li><strong>避免阻塞</strong>：如果一个工作线程在某个工作项上阻塞（比如调用了 <code>msleep</code>），内核会检测到该线程休眠，并立即唤醒或创建另一个线程来执行同一队列上的其他工作项。这直接解决了你图片中 <code>w0</code> 阻塞 <code>w1</code> 和 <code>w2</code> 的问题。</li>
<li><strong>自动扩展</strong>：在高负载下，线程池会扩大以处理更多工作；在空闲时，多余的线程会被自动回收。</li>
</ul>
</li>
</ul>
</li>
<li><strong>向后兼容的API</strong><ul>
<li>最棒的一点是，<strong>开发者几乎不需要修改现有代码</strong>。像 <code>schedule_work()</code>, <code>INIT_WORK()</code> 这样的API保持不变，但它们底层已经使用了CMWQ机制。</li>
<li>旧的函数如 <code>create_workqueue()</code> 被重写为基于CMWQ的兼容层，但建议使用新的 <code>alloc_workqueue()</code> 函数来显式创建具有特定属性（如并发度限制）的工作队列。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">旧工作队列 (Pre-CMWQ)</th>
<th align="left">CMWQ (并发托管工作队列)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">每工作队列专用线程</td>
<td align="left"><strong>共享线程池</strong></td>
</tr>
<tr>
<td align="left"><strong>线程数量</strong></td>
<td align="left">静态，与工作队列数量成正比</td>
<td align="left"><strong>动态</strong>，根据负载扩展和收缩</td>
</tr>
<tr>
<td align="left"><strong>并发管理</strong></td>
<td align="left">固定（通常每CPU一个线程）</td>
<td align="left"><strong>自动、动态</strong>管理，避免饥饿和阻塞</td>
</tr>
<tr>
<td align="left"><strong>资源效率</strong></td>
<td align="left">低效，线程可能大量空闲</td>
<td align="left"><strong>高效</strong>，线程被充分共享和利用</td>
</tr>
<tr>
<td align="left"><strong>API</strong></td>
<td align="left"><code>create_workqueue()</code>等</td>
<td align="left"><code>alloc_workqueue()</code>，<strong>兼容旧API</strong></td>
</tr>
<tr>
<td align="left"><strong>解决阻塞</strong></td>
<td align="left"><strong>无法解决</strong>，一个阻塞会阻塞整个队列</td>
<td align="left"><strong>完美解决</strong>，阻塞后自动创建新线程</td>
</tr>
</tbody></table>
<img src="deepseek_mermaid_20250903_266727.png" alt="deepseek_mermaid_20250903_266727" style="zoom:33%;">

<ol>
<li><p><strong>工作队列（workqueue）层 - 生产者接口</strong></p>
<ul>
<li>这是开发者直接交互的层面。工作队列（如 <code>system_wq</code>, <code>system_highpri_wq</code> 或用户用 <code>alloc_workqueue()</code> 创建的队列）充当工作项（<code>work_struct</code>）的容器。</li>
<li>每个工作队列可以定义自己的属性，最最重要的是 <code>max_active</code>，它限制了该工作队列<strong>每个CPU</strong>上最多可以同时执行的工作项数量。这提供了对并发度的精细控制。</li>
</ul>
</li>
<li><p><strong>worker_pool 层 - 核心资源管理</strong></p>
<ul>
<li>这是CMWQ的“大脑”。内核为每个CPU（和一些特殊场景）创建了一组 <strong>worker_pool</strong>。</li>
<li><strong>绑定到特定CPU的worker_pool</strong>： 这是最常见的类型。例如，每个CPU都有两个worker_pool：一个用于普通优先级工作（<code>kworker/uX:Y</code>），一个用于高优先级工作（<code>kworker/uX:Y</code>）。</li>
<li><strong>Unbound worker_pool</strong>： 用于那些不需要绑定特定CPU、且可能长时间运行的任务。它们的线程可以运行在任何CPU上，名字如 <code>kworker/uX:Y</code>。</li>
<li><strong>工作项最终会被派发到某个worker_pool</strong>。例如，通过 <code>schedule_work()</code> 提交的普通工作，会被派发到当前CPU的普通优先级worker_pool。</li>
</ul>
</li>
<li><p><strong>工作者线程（worker）层 - 消费者执行单元</strong></p>
<ul>
<li>这是真正执行代码的线程，即 <code>kworker</code> 线程。</li>
<li>它们由内核动态地从 <strong>worker_pool</strong> 中管理。当一个worker_pool中有工作项需要处理时：<ul>
<li>如果有空闲的worker线程，它会被唤醒去处理工作。</li>
<li>如果没有空闲worker且当前活跃worker数未达到上限，内核会创建一个新的worker线程。</li>
<li>如果一个worker线程在执行工作项时进入睡眠（阻塞），内核会立即感知到，并可能创建新的worker来处理同一worker_pool中的其他工作项（这就是解决阻塞问题的关键）。</li>
<li>当worker处理完工作后，它会保持一段时间空闲。如果一直没新工作，它会被内核自动销毁，从而释放资源。</li>
</ul>
</li>
</ul>
<img src="image-20250903224808412.png" alt="image-20250903224808412" style="zoom:50%;">

<img src="image-20250903224825722.png" alt="image-20250903224825722" style="zoom:50%;">

<p>通过图片我们可以知道：</p>
</li>
<li><p>用户通过 <code>alloc_workqueue</code> 创建<strong>工作队列</strong>时，需要指定 <code>flags</code> 参数（如 <code>WQ_UNBOUND</code>, <code>WQ_HIGHPRI</code>）。</p>
</li>
<li><p>这个 <code>flags</code> 参数决定了该工作队列中的工作项将被分配到哪种<strong>类型的线程池</strong>（前端与后端的绑定）。</p>
</li>
<li><p><strong><code>max_active</code></strong>：这是一个极其重要的参数。它限制了<strong>每个 CPU</strong> 上可以同时并发执行（处于 <code>running</code> 状态）的该工作队列的工作项数量。它实现了对并发度的精细控制。</p>
</li>
<li><p>这展示了 <strong>CMWQ 将 <code>max_active</code> 设置为大于等于工作项数量</strong>时的效果。内核线程池会提供足够的线程，使得三个工作项<strong>几乎完全并发</strong>地执行：</p>
<ul>
<li><code>w0</code> 睡眠时，<code>w1</code> 和 <code>w2</code> 立即开始运行。</li>
<li>所有工作项在 <strong>25ms</strong> 内完成，效率提升一倍！</li>
</ul>
</li>
</ol>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p><strong>中断线程化（Threaded IRQs）</strong> 是一种将中断处理程序（Interrupt Handler）的大部分工作转移到内核线程中执行的技术。它将一个中断的处理分为两部分：</p>
<ol>
<li><strong>硬中断处理程序（Hard IRQ Handler）</strong>：在<strong>中断上下文</strong>中执行，要求快速、不可休眠。它只负责最紧急的任务（如读取状态寄存器、清除中断标志），然后通知内核需要调度对应的线程。</li>
<li><strong>中断线程（Threaded IRQ Handler）</strong>：在<strong>进程上下文</strong>中执行，作为一个独立的内核线程运行。它负责处理中断大部分耗时的、可能休眠的操作。</li>
</ol>
<p>简单来说，中断线程化就是把一个中断“转换”成了一个由中断信号触发的、特殊的内核线程。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>本质</strong>：它<strong>不是传统意义上的底半部</strong>，而是一种<strong>全新的中断处理模型</strong>。它将整个中断处理过程（相当于顶半部+底半部）都放到了一个内核线程中执行。</li>
<li><strong>执行上下文</strong>：<strong>进程上下文</strong>。</li>
<li><strong>抢占与睡眠</strong>：<strong>可以睡眠&#x2F;阻塞</strong>（在线程化的handler部分）。</li>
<li><strong>并发性</strong>：每个中断线程可以有自己的调度策略和优先级。</li>
<li><strong>执行延迟</strong>：顶半部变得极短（只是一个唤醒线程的信号），真正的处理在线程中完成，延迟高于软中断&#x2F;tasklet。</li>
<li><strong>优先级</strong>：可以给中断线程设置<strong>实时优先级</strong>，从而提供<strong>确定性的响应</strong>，这对实时系统（PREEMPT_RT）至关重要。</li>
<li><strong>机制</strong>：使用 <code>request_threaded_irq()</code> 申请中断，并指定一个“线程化处理函数”。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>实时系统 (PREEMPT_RT Patch)</strong>：其主要目标就是将所有中断线程化，以减少关中断时间，提供更好的系统实时性。</li>
<li>需要为中断处理提供<strong>明确的调度优先级</strong>。</li>
<li>简化驱动设计，整个中断处理流程都可以在一个可以睡眠的上下文中完成，无需再区分顶半部和底半部。</li>
</ul>
<h4 id="api函数-1"><a href="#api函数-1" class="headerlink" title="api函数"></a>api函数</h4><p><strong>核心函数：<code>request_threaded_irq</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                        <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                        <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>irq</code></td>
<td align="left"><code>unsigned int</code></td>
<td align="left">要申请的中断号。</td>
</tr>
<tr>
<td align="left"><code>handler</code></td>
<td align="left"><code>irq_handler_t</code></td>
<td align="left"><strong>（硬中断处理函数）</strong> 在中断上下文中运行的函数。它的职责是进行最快速的处理，然后决定是否需要唤醒中断线程。</td>
</tr>
<tr>
<td align="left"><code>thread_fn</code></td>
<td align="left"><code>irq_handler_t</code></td>
<td align="left"><strong>（中断线程处理函数）</strong> 在进程上下文（内核线程）中运行的函数。负责处理中断的主要工作。</td>
</tr>
<tr>
<td align="left"><code>flags</code></td>
<td align="left"><code>unsigned long</code></td>
<td align="left">中断标志。与 <code>request_irq</code> 的标志类似，但有一些用于线程化中断的特殊标志。</td>
</tr>
<tr>
<td align="left"><code>name</code></td>
<td align="left"><code>const char *</code></td>
<td align="left">中断名称，会在 <code>/proc/interrupts</code> 中显示。同时也是中断线程名的前缀。</td>
</tr>
<tr>
<td align="left"><code>dev</code></td>
<td align="left"><code>void *</code></td>
<td align="left">传递给处理程序的设备标识符，通常是设备结构体的指针。</td>
</tr>
</tbody></table>
<p><strong><code>handler</code> 和 <code>thread_fn</code> 的返回值</strong></p>
<p>这两个函数的返回值都是 <code>irqreturn_t</code> 类型：</p>
<ul>
<li><code>IRQ_NONE</code>: 表示这不是本设备发出的中断，未处理。</li>
<li><code>IRQ_HANDLED</code>: 表示中断已处理。</li>
<li><strong><code>IRQ_WAKE_THREAD</code></strong>: <strong>这是关键</strong>。<code>handler</code> 函数如果返回此值，内核就会唤醒对应的 <code>thread_fn</code> 线程来执行。如果 <code>handler</code> 为 <code>NULL</code>，内核会默认返回 <code>IRQ_WAKE_THREAD</code>。</li>
</ul>
<h4 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h4><p><strong>伪代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="comment">// ... 其他设备数据 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬中断处理函数（可选，如果为NULL则默认唤醒线程） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_hardirq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 快速读取状态寄存器确认中断 */</span></span><br><span class="line">    <span class="comment">/* 2. 清除中断标志（非常重要！） */</span></span><br><span class="line">    <span class="comment">/* 3. 如果需要线程处理，返回 IRQ_WAKE_THREAD */</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断线程处理函数（主要工作在这里完成） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_thread_fn</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里可以处理复杂逻辑，甚至可以休眠！ */</span></span><br><span class="line">    <span class="comment">// msleep(10); // 这是允许的！</span></span><br><span class="line">    <span class="comment">// mutex_lock(&amp;my_mutex); // 这也是允许的！</span></span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Processing interrupt in thread context for device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">int</span> irq, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 设备初始化 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请线程化中断 */</span></span><br><span class="line">    ret = request_threaded_irq(irq, </span><br><span class="line">                              my_hardirq_handler,  <span class="comment">// 硬中断处理函数</span></span><br><span class="line">                              my_thread_fn,        <span class="comment">// 线程处理函数</span></span><br><span class="line">                              IRQF_ONESHOT,        <span class="comment">// 必须的标志</span></span><br><span class="line">                              <span class="string">&quot;my-threaded-irq&quot;</span>, </span><br><span class="line">                              dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to request threaded IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作流程</strong></p>
<ol>
<li><strong>硬件中断发生</strong>，CPU 跳转到对应的中断向量。</li>
<li>内核调用为该中断号注册的<strong>硬中断处理程序 (<code>handler</code>)</strong>。</li>
<li><code>handler</code> 函数执行（在中断上下文）：<ul>
<li>读取硬件状态，确认是本设备中断。</li>
<li>清除中断源（防止再次触发）。</li>
<li>返回 <code>IRQ_WAKE_THREAD</code>。</li>
</ul>
</li>
<li>内核唤醒与该中断关联的<strong>内核线程</strong>。</li>
<li>该内核线程开始执行<strong>中断线程处理程序 (<code>thread_fn</code>)</strong>（在进程上下文）：<ul>
<li>执行所有耗时操作（如处理数据、唤醒进程、访问可能休眠的硬件等）。</li>
<li>返回 <code>IRQ_HANDLED</code>。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">软中断 (Softirq)</th>
<th align="left">Tasklet</th>
<th align="left">工作队列 (Workqueue)</th>
<th align="left">中断线程 (Threaded IRQ)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>执行上下文</strong></td>
<td align="left">软中断上下文</td>
<td align="left">软中断上下文</td>
<td align="left"><strong>进程上下文</strong></td>
<td align="left"><strong>进程上下文</strong></td>
</tr>
<tr>
<td align="left"><strong>可否睡眠</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>并发性</strong></td>
<td align="left">高，同类型可多CPU并发</td>
<td align="left">低，同类型串行执行</td>
<td align="left">可配置，默认共享</td>
<td align="left">每个中断一个线程</td>
</tr>
<tr>
<td align="left"><strong>执行延迟</strong></td>
<td align="left"><strong>极低</strong></td>
<td align="left"><strong>低</strong></td>
<td align="left">较高</td>
<td align="left">较高（但响应确定）</td>
</tr>
<tr>
<td align="left"><strong>编程复杂度</strong></td>
<td align="left"><strong>高</strong>（需处理自旋锁）</td>
<td align="left">低（无需复杂锁）</td>
<td align="left">低（可使用睡眠锁）</td>
<td align="left">低（可使用睡眠锁）</td>
</tr>
<tr>
<td align="left"><strong>机制</strong></td>
<td align="left">静态，编译时定义</td>
<td align="left">动态，基于软中断</td>
<td align="left">动态，内核线程执行</td>
<td align="left">动态，内核线程执行</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">网络、块设备、定时器</td>
<td align="left"><strong>大多数设备驱动</strong></td>
<td align="left">可睡眠的耗时任务</td>
<td align="left"><strong>实时系统</strong>，需优先级调度</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/05/10/kernel-intc/">https://leonardo272.github.io/2025/05/10/kernel-intc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux%E5%86%85%E6%A0%B8/">linux内核</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E6%96%AD/">中断</a></div><div class="post-share"><div class="social-share" data-image="/page_images/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/13/0009/" title="驱动开发-图形化编译内核与系统自带驱动的添加"><img class="cover" src="/page_images/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">驱动开发-图形化编译内核与系统自带驱动的添加</div></div><div class="info-2"><div class="info-item-1">1.配置linux自带的驱动使能1.1图形化配置要使用 Linux内核自带的 LED灯驱动首先得先配置 Linux，输入如下命令打开 Linux配置菜单： 1make menuconfig  按照如下路径打开 LED驱动配置项：  按照上述路径，选择“ LED Support for GPIO connected LEDs”，将其编译进 Linux内核，也即是在此选项上按下“ Y”键，使此选项前面变为 “&lt;*&gt;”：   在“ LED Support for GPIO connected LEDs”上按下 可以打开此选项的帮助信息，   1make -j16    1.2.config文件查看配置 好 Linux内核以后退出配置界面，打开 .config文件，会找到“ CONFIG_LEDS_GPIO&#x3D;y这一行，如图 56.1.3所示：  1.3Makefile文件LED灯驱动文件为 /drivers/leds/leds-gpio.c，大家可以打开 /drivers/leds/Makefile这个文件，  如果定义了 CONFIG_LEDS_GPIO的话就会编...</div></div></div></a><a class="pagination-related" href="/2025/04/20/MMS-CH4/" title="CH4-内核虚拟空间学习与I.MX6ULL嵌入式驱动开发实践"><img class="cover" src="/page_images/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CH4-内核虚拟空间学习与I.MX6ULL嵌入式驱动开发实践</div></div><div class="info-2"><div class="info-item-1">虚拟内存内核空间    &#x3D;&#x3D;内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。&#x3D;&#x3D; 线性映射区 lowmem在总共大小1G的内核虚拟内存空间中，位于最前边有一块896M大小的区域，我们称之为直接映射区或者线性映射区，地址范围为3G—–3G+896m。 之所以这块896M大小的区域称为直接映射区或者线性映射区，是因为这块连续的虚拟内存地址会映射到0-896M这块连续的物理内存上。 也就是说3G-3G+896m这块896M大小的虚拟内存会直接映射到0-896M这块896M大小的物理内存上，这块区域中的虚拟内存地址直接减去0xC0000000(3G)就得到了物理内存地址。所以我们称这块区域为直接映射区。直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变。   原理线性映射区（Direct Mapping Area）是内核虚拟地址空间中一段固定偏移映射的区域，其核心原理是通过简单的数学关系建立虚拟地址与物理地址的直接对应：  经典通常是： 1虚拟地址 = 物理地址 + PAGE_OFFSET   P...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/01/02/1001/" title="文件系统-01初识文件系统"><img class="cover" src="/page_images/3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="info-item-2">文件系统-01初识文件系统</div></div><div class="info-2"><div class="info-item-1">文件系统磁盘的格式化与挂载简化的Linux文件系统磁盘布局结构图如下：   虚拟机操作实验 首先我们通过添加一个磁盘文件   选择添加硬盘  选择SCSI(S)类型的磁盘  选择创建新的虚拟磁盘  设定磁盘大小为4MB，并且将虚拟磁盘存储为单个文件  点击完成   我们打开虚拟机终端，切换到管理员模式 1su  查看系统有哪些磁盘 1fdisk -l    我们可以看到我们添加的新磁盘为 /dev/sdb，接下来我们开始格式化添加的磁盘，我们将磁盘格式化为minix格式 1mkfs.minix /dev/sdb    根据上图我们可以看出格式化之后文件系统创建了  创建了 1376 个 inode（索引节点） 创建了 1376 个 inode（索引节点）。 inode数量 ≈ 磁盘大小 / 预期平均文件大小此处 4MB / 1376 ≈ 3KB/文件，适合存储大量小文件。   文件系统被划分为 4096 个数据块 块大小：根据后续参数计算为 1024 字节（1KB）（见下方推导）。 总磁盘空间：4096 块 × 1024 字节/块 = 4,194,304 字节 = 4MB，符合设...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">中断子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">中断子系统框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">中断控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ID-Hardware-Interrupt-ID-%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">ID (Hardware Interrupt ID) - 硬件中断号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IRQ-Linux-Virtual-Interrupt-Number-Linux-%E8%99%9A%E6%8B%9F%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">中断控制器处理中断的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cortex-A"><span class="toc-number">1.4.</span> <span class="toc-text">Cortex-A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">处理器运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">状态寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9D%A1%E4%BB%B6%E7%A0%81%E6%A0%87%E5%BF%97%E4%BD%8D-Condition-Code-Flags"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">1. 条件码标志位 (Condition Code Flags)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E4%BD%8D-Control-Bits"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">2. 控制位 (Control Bits)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPSR-%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">CPSR 在中断处理流程中的关键作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">linux中断处理的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">linux系统启动的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#irq-domain"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">irq_domain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">系统启动的流程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E9%83%A8%E5%88%86%E5%85%B6%E4%BD%99%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">CPU部分其余流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">具体的设备驱动注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#irq-desc%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">irq_desc结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">驱动注册流程分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">1.7.</span> <span class="toc-text">linux中断程序编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">中断的API函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request-irq"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">request_irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-irq"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">free_irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">中断服务函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">中断使能函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-number">1.7.2.</span> <span class="toc-text">设备树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">两者区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80"><span class="toc-number">1.8.1.</span> <span class="toc-text">实验一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="toc-number">1.8.2.</span> <span class="toc-text">实验二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%8A%E5%8D%8A%E9%83%A8%E4%B8%8E%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-number">1.9.</span> <span class="toc-text">中断的上半部与下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.1.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%ADAPI%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">软中断API函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">实验三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet"><span class="toc-number">1.9.2.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">API函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">实验四</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.9.3.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">工作队列的运行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">工作队列的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">工作队列的API函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">延迟工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#api%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.3.4.1.</span> <span class="toc-text">api函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94"><span class="toc-number">1.9.3.4.2.</span> <span class="toc-text">实验五</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMWQ%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">CMWQ工作队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">中断线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#api%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">api函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">实验六</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/00008/" title="驱动开发-pinctrl与gpio子系统"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-pinctrl与gpio子系统"/></a><div class="content"><a class="title" href="/2025/06/05/00008/" title="驱动开发-pinctrl与gpio子系统">驱动开发-pinctrl与gpio子系统</a><time datetime="2025-06-05T13:12:00.000Z" title="发表于 2025-06-05 21:12:00">2025-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/0001/" title="驱动开发-PWM"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-PWM"/></a><div class="content"><a class="title" href="/2025/06/05/0001/" title="驱动开发-PWM">驱动开发-PWM</a><time datetime="2025-06-05T13:12:00.000Z" title="发表于 2025-06-05 21:12:00">2025-06-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>