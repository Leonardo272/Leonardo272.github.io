<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CH1-中断子系统介绍 | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中">
<meta property="og:type" content="article">
<meta property="og:title" content="CH1-中断子系统介绍">
<meta property="og:url" content="https://leonardo272.github.io/2025/05/10/kernel-intc/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/7.jpg">
<meta property="article:published_time" content="2025-05-10T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-10T14:33:11.231Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CH1-中断子系统介绍",
  "url": "https://leonardo272.github.io/2025/05/10/kernel-intc/",
  "image": "https://leonardo272.github.io/page_images/7.jpg",
  "datePublished": "2025-05-10T13:12:00.000Z",
  "dateModified": "2025-09-10T14:33:11.231Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/05/10/kernel-intc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CH1-中断子系统介绍',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">CH1-中断子系统介绍</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CH1-中断子系统介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T13:12:00.000Z" title="发表于 2025-05-10 21:12:00">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-10T14:33:11.231Z" title="更新于 2025-09-10 22:33:11">2025-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/">中断子系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="中断子系统"><a href="#中断子系统" class="headerlink" title="中断子系统"></a>中断子系统</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。</p>
<h2 id="中断子系统框架"><a href="#中断子系统框架" class="headerlink" title="中断子系统框架"></a>中断子系统框架</h2><p><img src="image-20250901101222885.png" alt="image-20250901101222885"></p>
<ul>
<li><p>CPU</p>
</li>
<li><p>中断控制器</p>
</li>
<li><p>外设</p>
</li>
<li><p>中断向量表</p>
</li>
<li><p>中断号</p>
</li>
<li><p>Linux内核中断子系统</p>
</li>
<li><p>中断编程接口（<code>request_irq</code>接口函数）</p>
</li>
<li><p>具体的外设驱动</p>
</li>
</ul>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><img src="image-20250901102414888.png" alt="image-20250901102414888" style="zoom:50%;">

<p>GIC 是ARM 公司给Cortex-A&#x2F;R 内核提供的一个中断控制器，类似Cortex-M 内核中的NVIC。GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号报给ARM 内核，这四个信号的含义如下：</p>
<ul>
<li>VFIQ:虚拟快速FIQ。</li>
<li>VIRQ:虚拟外部IRQ。</li>
<li>FIQ:快速中断IRQ。</li>
<li>IRQ:外部中断IRQ。</li>
</ul>
<img src="image-20250901102917824.png" alt="image-20250901102917824" style="zoom:50%;">

<center>单核</center>

<img src="image-20250901103251800.png" alt="image-20250901103251800" style="zoom:33%;">

<img src="image-20250901103345111.png" alt="image-20250901103345111" style="zoom:50%;">

<p>上图中我们可以看到所有的中断都发送给了GIC控制器，它负责处理各种中断，判断优先级、屏蔽、使能等工作。在GIC控制器中有Distributor、Interface</p>
<p>**Distributor(分发器端)：**块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个CPU Interface 上去.分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到CPU 接口端</p>
<ul>
<li><p>全局中断使能控制。</p>
</li>
<li><p>控制每一个中断的使能或者关闭。</p>
</li>
<li><p>设置每个中断的优先级。</p>
</li>
<li><p>设置每个中断的目标处理器列表。</p>
</li>
<li><p>设置每个外部中断的触发模式：电平触发或边沿触发。</p>
</li>
<li><p>设置每个中断属于组0 还是组1。</p>
</li>
</ul>
<p>**CPU Interface(CPU 接口端)：**每个CPU Core 都可以在GIC 中找到一个与之对应的CPU Interface,CPU 接口端就是分发器和CPU Core 之间的桥梁</p>
<ul>
<li><p>使能或者关闭发送到CPU Core 的中断请求信号。</p>
</li>
<li><p>应答中断。</p>
</li>
<li><p>通知中断处理完成。</p>
</li>
<li><p>设置优先级掩码，通过掩码来设置哪些中断不需要上报给CPU Core。</p>
</li>
<li><p>定义抢占策略。</p>
</li>
<li><p>当多个中断到来的时候，选择优先级最高的中断通知给CPU Core。</p>
</li>
</ul>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p><img src="image-20250509154927955.png" alt="image-20250509154927955"></p>
<center>GICV2</center>

<p>中断的种类可以分为：</p>
<ul>
<li><code>SPI(Shared Peripheral Interrupt)</code>,<strong>共享外设中断</strong>，顾名思义，<strong>所有的核Core共享的中断</strong>，这个是最常见的，那些外部中断都属于SPI 中断(注意！不是SPI 总线那个中断) 。比如按键中断、串口中断等等，这些中断所有的Core 都可以处理，不限定特定Core</li>
<li><code>PPI(Private Peripheral Interrupt)</code>，<strong>私有外设中断</strong>，我们说了GIC 是支持多核的，<strong>每个核肯定有自己独有的中断</strong>。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。</li>
<li><code>SGI(Software-generated Interrupt)</code>，<strong>软件中断</strong>，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用SGI 中断来完成<strong>多核之间的通信</strong></li>
</ul>
<h4 id="ID-Hardware-Interrupt-ID-硬件中断号"><a href="#ID-Hardware-Interrupt-ID-硬件中断号" class="headerlink" title="ID (Hardware Interrupt ID) - 硬件中断号"></a><strong>ID (Hardware Interrupt ID) - 硬件中断号</strong></h4><p>中断源有很多，每一个CPU 最多支持<code>1020</code> 个中断ID，中断ID 号为<code>ID0~ID1019</code>。这<code>1020</code> 个ID 包含了<code>PPI</code>、<code>SPI</code> 和<code>SGI</code>。</p>
<ul>
<li><p><code>ID0~ID15</code>：这16 个ID 分配给SGI。</p>
</li>
<li><p><code>ID16~ID31</code>：这16 个ID 分配给PPI。</p>
</li>
<li><p><code>ID32~ID1019</code>：这988 个ID 分配给SPI，像GPIO 中断、串口中断等这些外部中断。I.MX6U 的总共使用了128 个中断ID，加上前面属于PPI 和SGI 的32 个ID，I.MX6U 的中断源共有128+32&#x3D;160个。</p>
</li>
</ul>
<p>《I.MX6ULL 参考手册》的3.2 小节可以查看I.MX6U 完整的中断源</p>
<p><img src="image-20250509155510610.png" alt="image-20250509155510610"></p>
<h4 id="IRQ-Linux-Virtual-Interrupt-Number-Linux-虚拟中断号"><a href="#IRQ-Linux-Virtual-Interrupt-Number-Linux-虚拟中断号" class="headerlink" title="IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号"></a>IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号</h4><p> <strong>Linux 内核软件视角下的逻辑编号</strong>。它是一个由 Linux 内核分配和管理的软件概念，是驱动开发者请求和使用的“虚拟中断号”。当驱动调用 <code>request_irq(irq, handler, ...)</code> 来注册一个中断处理函数时，它使用的就是这个 <code>irq</code> 号。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">IRQ (虚拟中断号)</th>
<th align="left">ID (硬件中断号)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>视角</strong></td>
<td align="left">Linux 内核软件视角</td>
<td align="left">中断控制器硬件视角</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">驱动开发者使用</td>
<td align="left">硬件工程师、底层配置使用</td>
</tr>
<tr>
<td align="left"><strong>稳定性</strong></td>
<td align="left">相对稳定，但可能随配置变化</td>
<td align="left">绝对固定，由芯片决定</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left">通过 <code>irq_domain</code> 映射到 <code>ID</code></td>
<td align="left">通过 <code>irq_domain</code> 被映射到 <code>IRQ</code></td>
</tr>
</tbody></table>
<h3 id="中断控制器处理中断的流程"><a href="#中断控制器处理中断的流程" class="headerlink" title="中断控制器处理中断的流程"></a>中断控制器处理中断的流程</h3><img src="image-20250901105220714.png" alt="image-20250901105220714" style="zoom:33%;">

<center>多核GIC</center>

<p>GRC控制器结构:分为<strong>仲裁器</strong>和<strong>CPU接口</strong>两部分</p>
<p><strong>中断的状态</strong>可以分为Inactive、Pending、Active、Active and Pending四种状态：</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Inactive</strong></td>
<td align="left">中断未发生，或已被处理完成。</td>
</tr>
<tr>
<td align="left"><strong>Pending</strong></td>
<td align="left">中断已发生，但尚未被 CPU 处理。</td>
</tr>
<tr>
<td align="left"><strong>Active</strong></td>
<td align="left">CPU 正在处理该中断。</td>
</tr>
<tr>
<td align="left"><strong>Active and Pending</strong></td>
<td align="left">CPU 正在处理该中断，但同一中断源又发出了新的中断。</td>
</tr>
</tbody></table>
<img src="image-20250901105005072.png" alt="image-20250901105005072" style="zoom: 33%;">

<ol>
<li><p>中断发生（Inactive → Pending）</p>
<ul>
<li>设备发出中断信号。</li>
<li>仲裁器将该中断状态设置为 <strong>Pending</strong>。</li>
</ul>
</li>
<li><p>仲裁器选择中断（Pending → 发送给 CPU Interface）</p>
<ul>
<li>仲裁器在所有 Pending 状态的中断中选择<strong>优先级最高</strong>的一个。</li>
<li>将其发送给目标 CPU 的 CPU Interface。</li>
</ul>
</li>
<li><p>CPU Interface 判断是否转发给 CPU</p>
<ul>
<li>CPU Interface 会检查：<ul>
<li>该中断的优先级是否高于当前 CPU 的屏蔽优先级（如优先级掩码寄存器）。</li>
<li>或者是否是 CPU 正在处理的中断（用于支持中断嵌套或抢占）。</li>
</ul>
</li>
<li>如果条件满足，则向 CPU 发出中断信号（如 IRQ 或 FIQ）。</li>
</ul>
</li>
<li><p>CPU 响应中断（Pending → Active）</p>
<ul>
<li>CPU 检测到中断信号后，跳转到中断处理程序。</li>
<li>CPU 通过读取<strong>中断应答寄存器</strong>（如 <code>GICC_IAR</code>）获取中断号。</li>
<li>读取后，该中断状态由 <strong>Pending</strong> 变为 <strong>Active</strong>。</li>
</ul>
</li>
<li><p>中断处理中（Active）</p>
<ul>
<li>CPU 执行该中断对应的处理函数（ISR, Interrupt Service Routine）。</li>
</ul>
</li>
<li><p>中断完成（Active → Inactive）</p>
<ul>
<li>CPU 处理完成后，写入<strong>中断结束寄存器</strong>（如 <code>GICC_EOIR</code>），通知控制器中断已完成。</li>
<li>控制器将该中断状态改为 <strong>Inactive</strong>。</li>
</ul>
</li>
</ol>
<h2 id="Cortex-A"><a href="#Cortex-A" class="headerlink" title="Cortex-A"></a>Cortex-A</h2><h3 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h3><p><img src="image-20250901214642570.png" alt="image-20250901214642570"></p>
<p>除了User(USR)用户模式以外，其<strong>它8 种运行模式都是特权模式</strong>，这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。</p>
<h3 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h3><p>ARM 架构提供了<strong>16 个32位的通用寄存器(R0<del>R15)**供软件使用，前15 个(R0</del>R14)可以用作通用的数据存储，<code>R15</code> 是**程序计数器PC</strong>，用来<strong>保存将要执行的指令</strong>。</p>
<p>ARM 还提供了一个当<strong>前程序状态寄存器</strong><code>CPSR</code> 和一个<strong>备份程序状态寄存器</strong><code>SPSR</code>，<code>SPSR</code> 寄存器就是<code>CPSR</code> 寄存器的备份。</p>
<p><img src="image-20250901212343818.png" alt="image-20250901212343818"></p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>R0~R15 就是通用寄存器，通用寄存器可以分为以下三类：</p>
<ul>
<li><strong>未备份寄存器</strong>，即R0~R7。</li>
<li><strong>备份寄存器</strong>，即R8~R14。</li>
<li><strong>程序计数器PC</strong>，即R15。</li>
</ul>
<ol>
<li><p><strong>未备份寄存器</strong></p>
<p>所有的处理器模式下这8 个寄存器都是同一个物理寄存器，在不同的模式下，这8 个寄存器中的数据就会被破坏。所以这8 个寄存器并没有被用作特殊用途。</p>
</li>
<li><p><strong>备份寄存器</strong></p>
<ul>
<li><p><code>R8~R12</code> 这5个寄存器有两种物理寄存器</p>
<ul>
<li><strong>快速中断模式下</strong>(FIQ)它们对应着Rx_irq(x&#x3D;8<del>12) 物理寄存器，因为FIQ 模式下的&#96;R8</del>R12&#96;是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</li>
<li><strong>其他模式下</strong>对应着Rx(8~12)物理寄存器。</li>
</ul>
</li>
<li><p><strong>备份寄存器R13</strong></p>
<p>R13也叫做<strong>SP</strong>，用来做为<strong>栈指针</strong>。其中一个是用户模式(User)和系统模式(Sys)共用的，剩下的7 个分别对应7种不同的模式。基本上每种模式都有一个自己的R13物理寄存器，应用程序会初始化R13，使其指向该模式专用的栈地址，这就是常说的初始化SP指针。</p>
</li>
<li><p><strong>备份寄存器R14</strong></p>
<p>R14 也称为<strong>连接寄存器(LR)</strong>，LR 寄存器在ARM 中主要用作如下两种用途：</p>
<ul>
<li><p><strong>每种</strong>处理器<strong>模式</strong>使用R14(LR)来<strong>存放当前子程序的返回地址</strong>如果使用BL或者BLX<br>来调用子函数的话，R14(LR)被设置成该子函数的返回地址，<strong>在子函数中，将R14(LR)中的值赋给R15(PC)即可完成子函数返回</strong>，比如在子程序中可以使用如下代码</p>
<ul>
<li><pre><code>MOV PC, LR @寄存器LR 中的值赋值给PC，实现跳转
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  PUSH &#123;LR&#125; @将LR 寄存器压栈----子函数的入口</span><br><span class="line">  POP &#123;PC&#125; @将上面压栈的LR 寄存器数据出栈给PC 寄存器，严格意义上来讲应该是将@LR-4 赋给PC-----子函数的最后面</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>异常模式</strong>对应的R14 寄存器被设置成该异常模式将要返回的地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序计数器R15</strong></p>
<p>程序计数器R15也叫做<strong>PC</strong></p>
<p>R15保存着<strong>当前执行的指令地址值加8个字节</strong>，原因是：<strong>ARM 处理器3 级流水线：取指-&gt;译码-&gt;执行</strong>，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在R15(PC)中。</p>
<p><strong>R15(PC)总是指向当前正在执行的指令地址再加上2条指令的地址</strong>。对于32 的ARM 处理器，每条指令是4个字节，所以:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R15 (PC)值 = 当前执行的程序位置 + 8 个字节。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h4><p><strong>所有的处理器模式都共用一个CPSR 物理寄存器</strong>，<strong>CPSR 是当前程序状态寄存器</strong>，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。</p>
<p>除了User和Sys这两个模式以外，其他7个模式每个都配备了一个专用的物理状态寄存器，叫做<strong>SPSR(备份程序状态寄存器)</strong>，<strong>当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用SPSR中保存的值来恢复CPSR。</strong></p>
<p><img src="image-20250901214235189.png" alt="image-20250901214235189"></p>
<center>CPSR 寄存器</center>

<h5 id="1-条件码标志位-Condition-Code-Flags"><a href="#1-条件码标志位-Condition-Code-Flags" class="headerlink" title="1. 条件码标志位 (Condition Code Flags)"></a>1. 条件码标志位 (Condition Code Flags)</h5><p>这些位由 ARM 指令（通常带有 <code>S</code> 后缀，如 <code>ADDS</code>）自动设置，用于决定条件指令（如 <code>BGE</code>, <code>CMP</code>）是否执行。</p>
<ul>
<li><strong>N (Negative &#x2F; Less Than) [31]</strong>: 结果为负时置 1。</li>
<li><strong>Z (Zero) [30]</strong>: 结果为零时置 1。</li>
<li><strong>C (Carry &#x2F; Borrow &#x2F; Extend) [29]</strong>: 对于加法，无符号溢出时置 1；对于减法，无符号借位时置 0。</li>
<li><strong>V (oVerflow) [28]</strong>: 有符号溢出时置 1。</li>
</ul>
<h5 id="2-控制位-Control-Bits"><a href="#2-控制位-Control-Bits" class="headerlink" title="2. 控制位 (Control Bits)"></a>2. 控制位 (Control Bits)</h5><p>这些位用于控制 CPU 的核心行为。</p>
<ul>
<li><p><strong>I (IRQ disable) [7]</strong>: <strong>置 1 表示禁用 IRQ 中断</strong>。这是中断处理中的关键位！</p>
</li>
<li><p><strong>F (FIQ disable) [6]</strong>: <strong>置 1 表示禁用 FIQ 中断</strong>。</p>
</li>
<li><p><strong>T (Thumb) [5]</strong>: 置 1 表示 CPU 处于 Thumb 状态，执行 Thumb 指令；置 0 表示处于 ARM 状态。</p>
</li>
<li><p><strong>M[4:0] (Mode bits)</strong>: 这 5 位<strong>决定了 CPU 当前处于哪种工作模式</strong>，这是理解特权级和中断的又一关键！</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">M[4:0]</th>
<th align="left">用途</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>User</strong></td>
<td align="left">10000</td>
<td align="left"><strong>用户模式</strong>，运行普通应用程序</td>
<td align="left">非特权模式，资源受限</td>
</tr>
<tr>
<td align="left"><strong>FIQ</strong></td>
<td align="left">10001</td>
<td align="left"><strong>快速中断模式</strong>，用于处理高速数据传输、DMA 等</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>IRQ</strong></td>
<td align="left">10010</td>
<td align="left"><strong>普通中断模式</strong>，用于处理普通硬件中断</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Supervisor</strong></td>
<td align="left">10011</td>
<td align="left"><strong>监管模式</strong>，上电或软件中断 (<code>swi</code>) 指令进入，Linux <strong>内核态</strong></td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Abort</strong></td>
<td align="left">10111</td>
<td align="left"><strong>中止模式</strong>，在内存访问失败时进入</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>Undef</strong></td>
<td align="left">11011</td>
<td align="left"><strong>未定义模式</strong>，在遇到未知指令时进入</td>
<td align="left">特权模式</td>
</tr>
<tr>
<td align="left"><strong>System</strong></td>
<td align="left">11111</td>
<td align="left"><strong>系统模式</strong>，一种特权级的用户模式，用于运行特权操作系统任务</td>
<td align="left">特权模式</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="CPSR-在中断处理流程中的关键作用"><a href="#CPSR-在中断处理流程中的关键作用" class="headerlink" title="CPSR 在中断处理流程中的关键作用"></a>CPSR 在中断处理流程中的关键作用</h2><ol>
<li><strong>中断发生前 (CPU 在 User 模式)</strong><ul>
<li><code>CPSR.M[4:0] = 10000</code> (User 模式)</li>
<li><code>CPSR.I = 0</code> (IRQ 中断是使能的)</li>
</ul>
</li>
<li><strong>硬件自动响应中断</strong><ul>
<li>当一个 IRQ 中断被 CPU Interface 发送给 CPU 核心后，CPU 硬件会<strong>自动</strong>执行以下操作：<ul>
<li><strong>保存现场</strong>：将当前的 <code>CPSR</code> 保存到 <code>SPSR_irq</code>（IRQ 模式下的备份程序状态寄存器）中。</li>
<li><strong>模式切换</strong>：修改 <code>CPSR.M[4:0] = 10010</code>，让 CPU <strong>立即切换到 IRQ 模式</strong>。</li>
<li><strong>禁用中断</strong>：<strong>自动置 <code>CPSR.I = 1</code></strong>，<strong>禁用新的 IRQ 中断</strong>，防止中断嵌套（除非编写代码手动开启）。</li>
<li><strong>切换执行流</strong>：将返回地址保存到 <code>LR_irq</code>，并跳转到中断异常向量表指定的 IRQ 处理函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>中断处理中 (CPU 在 IRQ 模式)</strong><ul>
<li>此时，CPU 运行在特权模式下，可以访问所有系统资源。</li>
<li><code>CPSR.I = 1</code>，所以在此期间发生的普通 IRQ 中断会被屏蔽，但 FIQ 通常不会被屏蔽，以实现高速处理。</li>
</ul>
</li>
<li><strong>中断处理完成，恢复现场</strong><ul>
<li>中断服务程序执行完毕后，需要返回到被中断的任务。</li>
<li>执行一条特殊的返回指令（如 <code>subs pc, lr, #4</code>），这条指令会：<ul>
<li>将之前保存在 <code>SPSR_irq</code> 中的值<strong>自动写回 <code>CPSR</code></strong>。</li>
<li>这条指令同时将 <code>pc</code> 指向被中断的指令地址，从而恢复执行。</li>
</ul>
</li>
<li><strong>这一操作是原子性的</strong>，CPU 模式、中断屏蔽位（<code>I</code>&#x2F;<code>F</code>）、条件标志位等所有状态都瞬间恢复到了中断前的样子。</li>
</ul>
</li>
</ol>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// ===== 伪代码表示 ARM 中断处理流程 =====</span><br><span class="line"></span><br><span class="line">// 1. 中断发生前 (CPU 在 User 模式)</span><br><span class="line">CPSR = 0x00000010;        // M[4:0] = 10000 (User 模式), I=0 (IRQ 使能)</span><br><span class="line">PC = normal_execution;    // 正常执行用户程序</span><br><span class="line"></span><br><span class="line">// 2. 硬件自动响应中断 (当 IRQ 信号到达时，硬件自动执行以下操作)</span><br><span class="line">//    注意：这些操作是原子性的，由硬件自动完成，不是软件指令</span><br><span class="line">SPSR_irq = CPSR;          // 保存当前 CPSR 到 SPSR_irq</span><br><span class="line">CPSR.M = 0b10010;         // 切换到 IRQ 模式 (M[4:0] = 10010)</span><br><span class="line">CPSR.I = 1;               // 禁用 IRQ 中断 (I=1)</span><br><span class="line">LR_irq = PC + 4;          // 保存返回地址 (由于流水线，实际是下一条指令地址)</span><br><span class="line">PC = 0x00000018;          // 跳转到 IRQ 异常向量地址</span><br><span class="line"></span><br><span class="line">// 3. 软件异常向量处理 (在 0x00000018 处)</span><br><span class="line">//    这是软件预先设置的处理程序</span><br><span class="line">vector_irq:</span><br><span class="line">    // 矫正返回地址 (由于 ARM 流水线架构)</span><br><span class="line">    LR_irq = LR_irq - 4;</span><br><span class="line">    </span><br><span class="line">    // 保存关键寄存器到 IRQ 栈</span><br><span class="line">    SP_irq = SP_irq - 8;          // 调整栈指针</span><br><span class="line">    [SP_irq] = R0;                // 保存 R0</span><br><span class="line">    [SP_irq+4] = LR_irq;          // 保存返回地址</span><br><span class="line">    </span><br><span class="line">    // 保存之前的 CPSR (来自 SPSR_irq)</span><br><span class="line">    temp = SPSR_irq;</span><br><span class="line">    [SP_irq+8] = temp;</span><br><span class="line">    </span><br><span class="line">    // 准备切换到 SVC 模式</span><br><span class="line">    temp = CPSR;</span><br><span class="line">    temp.M = 0b10011;             // SVC 模式</span><br><span class="line">    SPSR_svc = temp;              // 设置 SPSR_svc 为 SVC 模式</span><br><span class="line">    </span><br><span class="line">    // 根据中断前的模式分发处理</span><br><span class="line">    previous_mode = SPSR_irq.M;   // 获取中断前的模式</span><br><span class="line">    if (previous_mode == 0b10000) // User 模式</span><br><span class="line">        PC = __irq_usr;</span><br><span class="line">    else if (previous_mode == 0b10011) // SVC 模式</span><br><span class="line">        PC = __irq_svc;</span><br><span class="line">    else</span><br><span class="line">        PC = __irq_invalid;       // 其他模式不支持</span><br><span class="line"></span><br><span class="line">// 4. 高级中断处理 (例如 __irq_usr)</span><br><span class="line">__irq_usr:</span><br><span class="line">    // 保存所有用户寄存器到栈</span><br><span class="line">    push &#123;r0-r12, lr&#125;</span><br><span class="line">    </span><br><span class="line">    // 调用通用中断处理程序</span><br><span class="line">    irq_number = get_irq_number();    // 从中断控制器获取中断号</span><br><span class="line">    handle_irq(irq_number);           // 通用中断处理</span><br><span class="line">    </span><br><span class="line">    // 恢复寄存器</span><br><span class="line">    pop &#123;r0-r12, lr&#125;</span><br><span class="line">    </span><br><span class="line">    // 返回到用户模式</span><br><span class="line">    movs pc, lr;                    // 特殊返回指令，同时恢复 CPSR</span><br><span class="line"></span><br><span class="line">// 5. 中断处理完成，恢复现场</span><br><span class="line">//    当执行 movs pc, lr 或 subs pc, lr, #4 时：</span><br><span class="line">//    - 将 SPSR_irq 的值写回 CPSR (自动完成)</span><br><span class="line">//    - 将 LR_irq 的值赋给 PC</span><br><span class="line">//    这一条指令原子性地完成了模式切换和程序流程恢复</span><br><span class="line"></span><br><span class="line">// 最终状态：CPU 回到 User 模式，继续执行被中断的指令</span><br><span class="line">CPSR = 0x00000010;        // M[4:0] = 10000 (User 模式), I=0 (IRQ 使能)</span><br><span class="line">PC = normal_execution;    // 继续执行被中断的程序</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/05/10/kernel-intc/">https://leonardo272.github.io/2025/05/10/kernel-intc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux%E5%86%85%E6%A0%B8/">linux内核</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E6%96%AD/">中断</a></div><div class="post-share"><div class="social-share" data-image="/page_images/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/10/kernel-intc-ch4/" title="CH4-中断的上半部与下半部"><img class="cover" src="/page_images/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CH4-中断的上半部与下半部</div></div><div class="info-2"><div class="info-item-1">中断的上半部与下半部Linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 可以参考：  如果要处理的内容不希望被其他中断打断，那么可以放到上半部。 如果要处理的任务对时间敏感，可以放到上半部。 如果要处理的任务与硬件有关，可以放到上半部 除了上述三点以外的其他任务，优先考虑放到下半部  软中断Linux 内核使用结构体softirq_action 表示软中断， softirq_action结构体定义在文include&#x2F;linux&#x2F;interrupt.h中softirq_action 1234struct softirq_action&#123;	void	(*action)(struct soft...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc-ch2/" title="CH2-中断处理流程分析"><img class="cover" src="/page_images/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CH2-中断处理流程分析</div></div><div class="info-2"><div class="info-item-1">linux中断处理的流程linux-5.10.4版本：interrupt.h   linux系统启动的流程irq_domainirq_domain 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。 你可以把它想象成一个翻译官或接线总机：  硬件中断号 (HW IRQ)：是中断控制器自己识别的编号。例如，对于 ARM GIC，SGIs 是 0-15，PPIs 是 16-31，SPIs 从 32 开始。这是硬件固定的，不同控制器完全不同。 虚拟中断号 (VIRQ)：是 Linux 内核内部使用的、统一的软件中断编号。驱动开发者请求和使用的就是这个号。  它的作用：  抽象硬件差异 世界上有无数种中断控制器（GIC, APIC, IO-APIC, GPIO 控制器等），每种都有自己的编号方案和编程模型。内核无法为每种控制器都写一套独立的中断处理流程。irq_domain 提供了一个统一的抽象接口，让内核核心代码只需与 irq_domain...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/10/kernel-intc-ch3/" title="CH3-中断程序的编写"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH3-中断程序的编写</div></div><div class="info-2"><div class="info-item-1">linux中断程序编写中断的API函数request_irq1int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)  **irq：**要申请中断的中断号。 **handler：**中断处理函数，当中断发生以后就会执行此中断处理函数。 **flags：**中断标志，可以在文件include/linux/interrupt.h 里面查看所有的中断标志    标志 描述    IRQF_SHARED 多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话，request_irq 函数的dev参数就是唯一区分他们的标志。   IRQF_ONESHOT 单次中断，中断执行一次就结束。   IRQF_TRIGGER_NONE 无触发。   IRQF_TRIGGER_RISING 上升沿触发。   IRQF_TRIGGER_FALLING 下降沿触发。   IRQF_TRIGGER_HIGH 高电平触发。   IRQF_T...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc-ch2/" title="CH2-中断处理流程分析"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH2-中断处理流程分析</div></div><div class="info-2"><div class="info-item-1">linux中断处理的流程linux-5.10.4版本：interrupt.h   linux系统启动的流程irq_domainirq_domain 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。 你可以把它想象成一个翻译官或接线总机：  硬件中断号 (HW IRQ)：是中断控制器自己识别的编号。例如，对于 ARM GIC，SGIs 是 0-15，PPIs 是 16-31，SPIs 从 32 开始。这是硬件固定的，不同控制器完全不同。 虚拟中断号 (VIRQ)：是 Linux 内核内部使用的、统一的软件中断编号。驱动开发者请求和使用的就是这个号。  它的作用：  抽象硬件差异 世界上有无数种中断控制器（GIC, APIC, IO-APIC, GPIO 控制器等），每种都有自己的编号方案和编程模型。内核无法为每种控制器都写一套独立的中断处理流程。irq_domain 提供了一个统一的抽象接口，让内核核心代码只需与 irq_domain...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc-ch4/" title="CH4-中断的上半部与下半部"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH4-中断的上半部与下半部</div></div><div class="info-2"><div class="info-item-1">中断的上半部与下半部Linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 可以参考：  如果要处理的内容不希望被其他中断打断，那么可以放到上半部。 如果要处理的任务对时间敏感，可以放到上半部。 如果要处理的任务与硬件有关，可以放到上半部 除了上述三点以外的其他任务，优先考虑放到下半部  软中断Linux 内核使用结构体softirq_action 表示软中断， softirq_action结构体定义在文include&#x2F;linux&#x2F;interrupt.h中softirq_action 1234struct softirq_action&#123;	void	(*action)(struct soft...</div></div></div></a><a class="pagination-related" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">kernel-sysfs文件系统介绍</div></div><div class="info-2"><div class="info-item-1">sysfs文件系统 sysfs 文件系统的目录  定义：sysfs是一个基于内存的虚拟文件系统（Virtual Filesystem）。它被挂载在 /sys 目录下，是Linux内核中内核对象（kobject）、属性（attribute）和关系（relationship） 的直观体现。 核心作用：sysfs的主要作用是在用户空间（Userspace） 和内核空间（Kernelspace） 之间搭建一座桥梁，提供一个标准化的接口，使得用户空间的程序能够安全、方便地查看和配置内核的运行参数、硬件设备信息、驱动程序状态、电源管理选项等。 具体作用包括：  展示设备层次结构：以目录树的形式清晰地展示系统中总线（bus）、设备（device）、驱动（driver）、类（class）等内核对象的层次关系。 导出对象属性：将内核对象的属性（通常是变量或状态）以普通文件的形式暴露出来。用户可以通过cat命令读取属性，通过echo命令修改属性（如果该属性可写）。 支持用户空间事件：通过poll或select系统调用，用户空间程序可以监听内核发出的事件通知（例如，设备的插拔）。  特点：  层次化结...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">中断子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">中断子系统框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">中断控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ID-Hardware-Interrupt-ID-%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">ID (Hardware Interrupt ID) - 硬件中断号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IRQ-Linux-Virtual-Interrupt-Number-Linux-%E8%99%9A%E6%8B%9F%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">IRQ (Linux Virtual Interrupt Number) - Linux 虚拟中断号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">中断控制器处理中断的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cortex-A"><span class="toc-number">1.4.</span> <span class="toc-text">Cortex-A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">处理器运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">状态寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9D%A1%E4%BB%B6%E7%A0%81%E6%A0%87%E5%BF%97%E4%BD%8D-Condition-Code-Flags"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">1. 条件码标志位 (Condition Code Flags)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E4%BD%8D-Control-Bits"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">2. 控制位 (Control Bits)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPSR-%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">CPSR 在中断处理流程中的关键作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.6.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高危工作环境中人员安全装备佩戴检测系统"/></a><div class="content"><a class="title" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统">高危工作环境中人员安全装备佩戴检测系统</a><time datetime="2025-07-20T14:33:00.000Z" title="发表于 2025-07-20 22:33:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-SPI"/></a><div class="content"><a class="title" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI">驱动开发-SPI</a><time datetime="2025-06-20T13:12:00.000Z" title="发表于 2025-06-20 21:12:00">2025-06-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>