<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CH2-中断处理流程分析 | Kevin's blogs</title><meta name="author" content="Leonardo272"><meta name="copyright" content="Leonardo272"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="linux中断处理的流程linux-5.10.4版本：interrupt.h   linux系统启动的流程irq_domainirq_domain 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。 你可以把它想象成一个翻译官或接线总机：  硬件中断号">
<meta property="og:type" content="article">
<meta property="og:title" content="CH2-中断处理流程分析">
<meta property="og:url" content="https://leonardo272.github.io/2025/05/10/kernel-intc-ch2/index.html">
<meta property="og:site_name" content="Kevin&#39;s blogs">
<meta property="og:description" content="linux中断处理的流程linux-5.10.4版本：interrupt.h   linux系统启动的流程irq_domainirq_domain 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。 你可以把它想象成一个翻译官或接线总机：  硬件中断号">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leonardo272.github.io/page_images/7.jpg">
<meta property="article:published_time" content="2025-05-10T13:12:00.000Z">
<meta property="article:modified_time" content="2025-09-10T14:43:03.303Z">
<meta property="article:author" content="Leonardo272">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leonardo272.github.io/page_images/7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CH2-中断处理流程分析",
  "url": "https://leonardo272.github.io/2025/05/10/kernel-intc-ch2/",
  "image": "https://leonardo272.github.io/page_images/7.jpg",
  "datePublished": "2025-05-10T13:12:00.000Z",
  "dateModified": "2025-09-10T14:43:03.303Z",
  "author": [
    {
      "@type": "Person",
      "name": "Leonardo272",
      "url": "https://Leonardo272.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/%5Bobject%20Object%5D"><link rel="canonical" href="https://leonardo272.github.io/2025/05/10/kernel-intc-ch2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CH2-中断处理流程分析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="icon" href="/favicon.ico" sizes="any"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/image/ground.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/page_images/7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Kevin's blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">CH2-中断处理流程分析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CH2-中断处理流程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T13:12:00.000Z" title="发表于 2025-05-10 21:12:00">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-10T14:43:03.303Z" title="更新于 2025-09-10 22:43:03">2025-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F/">中断子系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="linux中断处理的流程"><a href="#linux中断处理的流程" class="headerlink" title="linux中断处理的流程"></a>linux中断处理的流程</h1><p><strong>linux-5.10.4版本：</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h">interrupt.h</a></p>
<img src="deepseek_mermaid_20250903_446fba-17568834327623.png" alt="deepseek_mermaid_20250903_446fba" style="zoom:200%;">

<h2 id="linux系统启动的流程"><a href="#linux系统启动的流程" class="headerlink" title="linux系统启动的流程"></a>linux系统启动的流程</h2><h3 id="irq-domain"><a href="#irq-domain" class="headerlink" title="irq_domain"></a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/irqdomain.h#L162">irq_domain</a></h3><p><strong><code>irq_domain</code> 是一个中间翻译层，它负责将硬件的中断号（Hardware Interrupt Number）映射到 Linux 内核的虚拟中断号（Virtual IRQ Number），并管理中断控制器的相关操作。</strong></p>
<p>你可以把它想象成一个<strong>翻译官</strong>或<strong>接线总机</strong>：</p>
<ul>
<li><strong>硬件中断号 (HW IRQ)</strong>：是中断控制器自己识别的编号。例如，对于 ARM GIC，SGIs 是 0-15，PPIs 是 16-31，SPIs 从 32 开始。这是硬件固定的，不同控制器完全不同。</li>
<li><strong>虚拟中断号 (VIRQ)</strong>：是 Linux 内核内部使用的、统一的软件中断编号。驱动开发者请求和使用的就是这个号。</li>
</ul>
<p><strong>它的作用：</strong></p>
<ul>
<li><p>抽象硬件差异</p>
<p>世界上有无数种中断控制器（GIC, APIC, IO-APIC, GPIO 控制器等），每种都有自己的编号方案和编程模型。内核无法为每种控制器都写一套独立的中断处理流程。<code>irq_domain</code> 提供了一个统一的抽象接口，让内核核心代码只需与 <code>irq_domain</code> 交互，而由各中断控制器驱动去实现具体的操作。</p>
</li>
<li><p>管理中断号映射</p>
<p>这是最核心的功能。当设备树（Device Tree）中描述一个设备的中断时，它只写硬件信息，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">0</span> <span class="number">58</span> <span class="number">4</span>&gt;; <span class="comment">// 代表这个设备连接到GIC的SPI，硬件中断号是58</span></span><br></pre></td></tr></table></figure>

<p>内核需要为这个“硬件中断号 58”分配一个“虚拟中断号”（比如 126）。<code>irq_domain</code> 就负责创建并维护这个映射关系。当驱动调用 <code>request_irq(126, ...)</code> 时，内核通过 <code>irq_domain</code> 知道，最终要去配置 GIC 控制器上编号为 58 的中断源。</p>
</li>
<li><p>提供控制器特定的操作函数集</p>
<p>每个 <code>irq_domain</code> 都关联着一个 <code>irq_domain_ops</code> 结构体，里面包含了一系列函数指针，用于执行该控制器特有的操作：</p>
<ul>
<li><code>.map()</code>: <strong>中断映射</strong>。在设备树解析到设备中断时，调用此函数来建立硬件中断号到虚拟中断号的映射，并配置该中断线的处理方式（设置 <code>-&gt;handle_irq</code> 函数）。<strong><code>gic_irq_domain_map</code> 函数，就是这个操作的具体实现！</strong></li>
<li><code>.alloc()</code>: 另一种分配中断号的方式。</li>
<li><code>.translate()</code>: 从设备树信息中翻译出硬件中断号。</li>
<li><code>.xclate()</code>: 转换中断说明符。</li>
</ul>
</li>
<li><p>支持中断控制器的级联</p>
<p>一个系统可能有多个中断控制器（例如，一个主 GIC 和一个作为中断源的 GPIO 控制器级联到 GIC 上）。每个控制器都需要自己的 <code>irq_domain</code>。子控制器的 <code>irq_domain</code> 会将它的虚拟中断号映射到父控制器的硬件中断号上，从而形成一个层次结构，内核可以无缝地处理这种级联关系。</p>
</li>
</ul>
<h3 id="系统启动的流程分析"><a href="#系统启动的流程分析" class="headerlink" title="系统启动的流程分析"></a>系统启动的流程分析</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/init/main.c#L848"><strong>start_kernel函数</strong></a></p>
<p>内核的启动函数，通过调用众多的子函数来完成 Linux 启动之前的一些初始化工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">	-&gt; local_irq_disable()<span class="comment">//关闭当前 CPU 的中断响应。通常通过设置 ARM CPSR 寄存器的 I 							//bit (对于 IRQ) 和 F bit (对于 FIQ) 来实现。   </span></span><br><span class="line">    -&gt; sort_main_extable()<span class="comment">//对内核的异常表（Exception Table）进行排序  </span></span><br><span class="line">    -&gt; trap_init()<span class="comment">//初始化系统陷阱（Trap）或异常向量表           </span></span><br><span class="line">    -&gt; ... </span><br><span class="line">    -&gt; init_IRQ()<span class="comment">//架构相关的中断初始化。                 </span></span><br><span class="line">    -&gt; softirq_init()<span class="comment">//初始化软中断（SoftIRQ）机制。      </span></span><br><span class="line">    -&gt; local_irq_enable()<span class="comment">//开启当前 CPU 的中断响应 </span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">调用阶段</th>
<th align="left">核心作用</th>
<th align="left">详细解释</th>
<th align="left">与中断的关系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>local_irq_disable()</code></strong></td>
<td align="left">最早阶段</td>
<td align="left"><strong>关闭CPU中断响应</strong></td>
<td align="left">在一切初始化之前，创造一个安全的、不被中断打断的原子环境，防止未初始化时中断导致系统崩溃。</td>
<td align="left"><strong>奠基与防护</strong>：为后续初始化提供安全环境，是中断系统启动的<strong>前提</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>sort_main_extable()</code></strong></td>
<td align="left">早期准备</td>
<td align="left"><strong>排序异常表</strong></td>
<td align="left">对内核的异常修复表（<code>__ex_table</code>）进行排序，以便在发生页面错误等异常时能快速查找并使用二分法定位修复地址。</td>
<td align="left"><strong>增强鲁棒性</strong>：不直接处理中断，但为异常处理（中断的一种）提供<strong>错误恢复机制</strong>，提升稳定性。</td>
</tr>
<tr>
<td align="left"><strong><code>trap_init()</code></strong></td>
<td align="left">基础设施搭建</td>
<td align="left"><strong>初始化异常向量表</strong></td>
<td align="left">设置CPU的异常向量基地址寄存器（如ARM的VBAR），填充异常&#x2F;中断的通用处理入口，是CPU响应异常和中断的<strong>硬件跳转表</strong>。</td>
<td align="left"><strong>硬件基石</strong>：建立了中断&#x2F;异常发生后CPU的<strong>第一跳转目的地</strong>，是中断能够被处理的<strong>绝对基础</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>init_IRQ()</code></strong></td>
<td align="left">软件框架搭建</td>
<td align="left"><strong>架构相关中断初始化</strong></td>
<td align="left">初始化架构相关的中断通用代码，通常负责分配和初始化核心数据结构 <code>irq_desc</code> 数组（中断描述符），为每个中断号建立管理单元。</td>
<td align="left"><strong>软件框架</strong>：搭建了内核管理所有中断的<strong>核心框架</strong>（<code>irq_desc</code>），是连接通用中断子系统与具体硬件的架构桥梁。</td>
</tr>
<tr>
<td align="left"><strong><code>softirq_init()</code></strong></td>
<td align="left">下半部机制初始化</td>
<td align="left"><strong>初始化软中断机制</strong></td>
<td align="left">初始化 <code>tasklet</code> 和软中断（SoftIRQ）机制，为中断的<strong>下半部</strong>（Bottom Half）处理提供延迟执行的框架。</td>
<td align="left"><strong>完善处理流程</strong>：完成了中断处理“上半部+下半部”的完整框架，允许中断处理函数将非紧急任务推迟执行。</td>
</tr>
<tr>
<td align="left"><strong><code>local_irq_enable()</code></strong></td>
<td align="left">最终开启</td>
<td align="left"><strong>开启CPU中断响应</strong></td>
<td align="left">在所有中断基础设施（向量表、控制器、框架、下半部）都已初始化完毕后，正式打开CPU的中断响应开关，系统开始正常处理中断。</td>
<td align="left"><strong>正式启用</strong>：标志着中断系统<strong>全面启动完成</strong>，内核从静态初始化阶段进入动态运行阶段。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>中断初始化</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/irq.c#L78">init_IRQ</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; !machine_desc-&gt;init_irq)</span><br><span class="line">		irqchip_init();<span class="comment">//初始化中断控制器</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		machine_desc-&gt;init_irq();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF) &amp;&amp; IS_ENABLED(CONFIG_CACHE_L2X0) &amp;&amp;</span><br><span class="line">	    (machine_desc-&gt;l2c_aux_mask || machine_desc-&gt;l2c_aux_val)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!outer_cache.write_sec)</span><br><span class="line">			outer_cache.write_sec = machine_desc-&gt;l2c_write_sec;</span><br><span class="line">		ret = l2x0_of_init(machine_desc-&gt;l2c_aux_val,</span><br><span class="line">				   machine_desc-&gt;l2c_aux_mask);</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; ret != -ENODEV)</span><br><span class="line">			pr_err(<span class="string">&quot;L2C: failed to init: %d\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uniphier_cache_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数名</th>
<th>调用阶段</th>
<th>核心作用</th>
<th>详细解释</th>
<th>与中断的关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>irqchip_init()</code></strong></td>
<td>硬件控制器初始化</td>
<td><strong>初始化中断控制器</strong></td>
<td>解析设备树，识别系统中的应用中断控制器（如GIC），映射其寄存器，禁用所有中断源，设置默认路由，并向内核注册控制器（创建<code>irq_domain</code>）。</td>
<td><strong>驱动硬件</strong>：是<strong>驱动中断控制器硬件</strong>的关键步骤，使内核能够具体地配置、使能和接收来自硬件设备的中断信号。</td>
</tr>
</tbody></table>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/irqchip_init">irqchip_init</a>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">irqchip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	of_irq_init(__irqchip_of_table);</span><br><span class="line">	acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>of_irq_init(__irqchip_of_table);</code> <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/of/irq.c#L472">of_irq_init</a><strong>遍历设备树，找到所有已注册的中断控制器节点，并调用它们各自的初始化函数。</strong></p>
<ol>
<li><p><strong>入参</strong>：接收一个列表 <code>__irqchip_of_table</code>，这个列表包含了所有在内核编译时注册的、支持的中断控制器信息（兼容字符串和初始化函数指针）。当中断控制器驱动（如 GIC 驱动）使用 <code>IRQCHIP_DECLARE</code> 宏声明时，它的兼容性字符串和初始化函数指针就会被添加到这个段中。</p>
<p>例如：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1510">IRQCHIP_DECLARE</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扫描设备树</strong>：遍历整个设备树（Device Tree），查找所有 <code>interrupt-controller</code> 属性，并获取它们的 <code>compatible</code> 属性。</p>
</li>
<li><p><strong>匹配驱动</strong>：将设备树中每个中断控制器节点的 <code>compatible</code> 属性与 <code>__irqchip_of_table</code> 列表中的项进行匹配。</p>
</li>
<li><p><strong>初始化调用</strong>：一旦匹配成功，就调用该中断控制器在 <code>__irqchip_of_table</code> 中注册的初始化函数（例如，对于 <code>&quot;arm,gic-400&quot;</code>，就会调用 <code>gic_of_init</code>）。</p>
</li>
<li><p><strong>处理级联</strong>：它会正确处理中断控制器的级联关系（例如，一个主 GIC 连接一个 GPIO 中断控制器），确保父控制器在子控制器之前被初始化。</p>
</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1464">gic_of_init</a>函数会</p>
<ul>
<li>映射硬件寄存器。</li>
<li>初始化私有数据 <code>struct gic_chip_data</code>。</li>
<li><strong>调用 <code>gic_init_bases()</code></strong>。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/drivers/irqchip/irq-gic.c#L1135">gic_init_bases</a>函数中注册**<code>irq_domain</code>** </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (handle) &#123;		<span class="comment">/* DT/ACPI */</span><span class="comment">//这是一个指针，通常指向设备树（DT）或ACPI中描述这个GIC控制器的节点。如果它存在，说明内核是通过现代的设备树或ACPI机制来获取硬件信息的。</span></span><br><span class="line">	gic-&gt;domain = irq_domain_create_linear(handle, gic_irqs,</span><br><span class="line">					       &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">					       gic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;		<span class="comment">/* Legacy support */</span><span class="comment">//为了兼容那些没有使用设备树的旧平台。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For primary GICs, skip over SGIs.</span></span><br><span class="line"><span class="comment">	 * No secondary GIC support whatsoever.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> irq_base;</span><br><span class="line"></span><br><span class="line">	gic_irqs -= <span class="number">16</span>; <span class="comment">/* calculate # of irqs to allocate */</span></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">16</span>, <span class="number">16</span>, gic_irqs, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;Cannot allocate irq_descs @ IRQ16, assuming pre-allocated\n&quot;</span>);</span><br><span class="line">		irq_base = <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gic-&gt;domain = irq_domain_add_legacy(<span class="literal">NULL</span>, gic_irqs, irq_base,</span><br><span class="line">						<span class="number">16</span>, &amp;gic_irq_domain_ops, gic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;gic_irq_domain_hierarchy_ops</code>参数 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/C/ident/irq_domain_ops">irq_domain_ops</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> <span class="title">gic_irq_domain_hierarchy_ops</span> =</span> &#123;</span><br><span class="line">	.translate = gic_irq_domain_translate,</span><br><span class="line">	.alloc = gic_irq_domain_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = irq_domain_free_irqs_top,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_alloc</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> nr_irqs, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="type">irq_hw_number_t</span> hwirq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type = IRQ_TYPE_NONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_fwspec</span> *<span class="title">fwspec</span> =</span> arg;</span><br><span class="line"></span><br><span class="line">	ret = gic_irq_domain_translate(domain, fwspec, &amp;hwirq, &amp;type);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_irqs; i++) &#123;</span><br><span class="line">		ret = gic_irq_domain_map(domain, virq + i, hwirq + i);<span class="comment">//映射</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>6中代码的<code>gic_irq_domain_map</code>函数为<strong>中断域的映射</strong>，发生在系统启动时，中断控制器被初始化之后，任何驱动申请中断之前。作用为<strong>负责为每个硬件中断号配置对应的Linux虚拟中断号的处理方式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gic_irq_domain_map</span><span class="params">(<span class="keyword">struct</span> irq_domain *d, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hw)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> =</span> d-&gt;host_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">irqd</span> =</span> irq_desc_get_irq_data(irq_to_desc(irq));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (hw) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> ... <span class="number">15</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_fasteoi_ipi,</span><br><span class="line">				    <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">16</span> ... <span class="number">31</span>:</span><br><span class="line">		irq_set_percpu_devid(irq);</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		irq_set_probe(irq);</span><br><span class="line">		irqd_set_single_target(irqd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevents SW retriggers which mess up the ACK/EOI ordering */</span></span><br><span class="line">	irqd_set_handle_enforce_irqctx(irqd);<span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>irq_domain</code>：是内核用于管理中断控制器和硬件中断号的一个抽象层。每个中断控制器都有一个自己的 <code>irq_domain</code>。</li>
<li><code>irq</code>：Linux 内核的<strong>虚拟中断号</strong>。这是一个软件概念，驱动开发者请求和使用的就是这个号。</li>
<li><code>hw</code>：<strong>硬件中断号</strong>。这是 GIC 控制器自己识别的中断编号（如 SPI 从 32 开始，PPI 从 16 开始）</li>
</ul>
<p><code>switch (hw) &#123;...&#125;</code> 根据硬件中断号进行配置</p>
<p>这是整个函数的核心，根据硬件中断号的不同范围，将中断分为三类进行处理：</p>
<ul>
<li><p><strong>1. Case 0 … 15: Software Generated Interrupt (SGIs)</strong> <strong>核间中断</strong>，一个CPU核心可以用它来中断另一个CPU核心。</p>
</li>
<li><p><strong>2. Case 16 … 31: Private Peripheral Interrupt (PPIs)</strong> 每个CPU核心私有的外设中断</p>
</li>
<li><p><strong>3. Default (通常为 32+): Shared Peripheral Interrupt (SPIs)</strong> 共享外设中断，所有CPU核心都可以看到的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">irq_domain_set_info(d, irq, hw, &amp;gic-&gt;chip, d-&gt;host_data,handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************    1    *****************/</span></span><br><span class="line"><span class="comment">//kernel/irq/irqdomain.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_domain_set_info</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> virq,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_hw_number_t</span> hwirq, <span class="keyword">struct</span> irq_chip *chip,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> *chip_data, <span class="type">irq_flow_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> *handler_data, <span class="type">const</span> <span class="type">char</span> *handler_name)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_set_chip_and_handler_name(virq, chip, handler, handler_name);</span><br><span class="line">	irq_set_chip_data(virq, chip_data);</span><br><span class="line">	irq_set_handler_data(virq, handler_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************    2    *****************/</span></span><br><span class="line"><span class="comment">///kernel/irq/chip.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">irq_set_chip_and_handler_name</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_chip *chip,</span></span><br><span class="line"><span class="params">			      <span class="type">irq_flow_handler_t</span> handle, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_set_chip(irq, chip);</span><br><span class="line">	__irq_set_handler(irq, handle, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************    3    *****************/</span></span><br><span class="line"><span class="comment">//kernel/irq/chip.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__irq_set_handler(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_flow_handler_t</span> handle, <span class="type">int</span> is_chained,</span><br><span class="line">		  <span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_get_desc_buslock(irq, &amp;flags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__irq_do_set_handler(desc, handle, is_chained, name);<span class="comment">//最终函数</span></span><br><span class="line">	irq_put_desc_busunlock(desc, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>d</code>: 所属的 <code>irq_domain</code></p>
</li>
<li><p><code>irq</code>: Linux 虚拟中断号</p>
</li>
<li><p><code>hw</code>: 硬件中断号</p>
</li>
<li><p><code>&amp;gic-&gt;chip</code>: 指向中断控制器芯片的底层操作集（<code>struct irq_chip *</code>），包含像 <code>.irq_mask</code>, <code>.irq_unmask</code>, <code>.irq_eoi</code> 这样的硬件操作函数。</p>
</li>
<li><p><code>handle_percpu_devid_fasteoi_ipi</code> 等：这是<strong>最关键</strong>的参数，它设置了 <code>irq_desc-&gt;handle_irq</code> 字段，即<strong>中断的流处理函数</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>__irq_do_set_handler</code> - 设置流处理函数<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/chip.c#L1000">__irq_do_set_handler</a></p>
<p>这个函数是第一部分中 <code>irq_domain_set_info</code> 等函数在底层<strong>最终会调用的函数</strong>。它的工作非常简单直接：</p>
<ol>
<li><strong>安全地将流处理函数安装到中断描述符中</strong><ul>
<li><code>desc-&gt;handle_irq = handle;</code></li>
<li>它将中断描述符（<code>struct irq_desc *desc</code>）的 <code>handle_irq</code> 成员设置为指定的流处理函数（如 <code>handle_fasteoi_irq</code>，这个函数在内核<strong>编译时</strong>就已确定并存放在内核镜像中）。</li>
</ul>
</li>
<li>处理各种边界情况，特别是层级中断域和链式中断</li>
<li>确保中断状态的正确性</li>
<li>处理中断的卸载情况</li>
</ol>
<p><strong>这个函数完成了从“配置”到“执行”的最后一步挂钩操作。</strong></p>
</li>
</ol>
<h2 id="CPU部分流程"><a href="#CPU部分流程" class="headerlink" title="CPU部分流程"></a>CPU部分流程</h2><p><strong>特点：</strong></p>
<ol>
<li><strong>硬件自动发起</strong>：最初的跳转和状态保存由CPU硬件逻辑完成，无法干预。</li>
<li><strong>汇编语言处理</strong>：后续的现场保存、模式切换、分发都由高度优化的汇编代码完成。</li>
<li><strong>关键目标</strong>：<ul>
<li><strong>保护现场</strong>：完整保存被中断任务的执行状态（寄存器）。</li>
<li><strong>模式切换</strong>：从IRQ模式切换到更通用的SVC模式。</li>
<li><strong>获取中断源</strong>：获取硬件中断号（hwirq）。</li>
<li><strong>传递上下文</strong>：将硬件中断号和保存的寄存器结构（<code>pt_regs</code>）传递给C处理函数。</li>
</ul>
</li>
<li><strong>关中断</strong>：在整个CPU处理阶段，IRQ中断始终是关闭的（<code>CPSR.I=1</code>），直到C代码中的某些阶段才可能被打开。</li>
</ol>
<p>当外设触发中断，中断控制器（如GIC）仲裁后会将中断信号发送给CPU核心。CPU核心会<strong>自动</strong>执行以下操作：</p>
<p><img src="deepseek_mermaid_20250903_b988d0.png" alt="deepseek_mermaid_20250903_b988d0"></p>
<h3 id="硬件部分自动完成"><a href="#硬件部分自动完成" class="headerlink" title="硬件部分自动完成"></a>硬件部分自动完成</h3><p>如同我们在之前CPSR小节学习到的知识，当外设触发中断，中断控制器（如GIC）仲裁后会将中断信号发送给CPU核心。CPU核心会<strong>自动</strong>执行以下操作：</p>
<ul>
<li><strong>保存状态</strong>：将当前程序的状态寄存器 <code>CPSR</code> 保存到 <code>SPSR_irq</code>（IRQ模式下的备份程序状态寄存器）。</li>
<li><strong>模式切换</strong>：修改 <code>CPSR</code> 的低5位，让CPU<strong>立即切换到IRQ模式</strong>。</li>
<li><strong>关闭中断</strong>：<strong>自动将 <code>CPSR</code> 中的 <code>I</code> bit 置1</strong>，<strong>禁用新的IRQ中断</strong>，防止中断嵌套。这是关键一步。</li>
<li><strong>保存返回地址</strong>：将<strong>下一条即将要执行的指令地址</strong>（即返回地址）保存到 <code>LR_irq</code> 寄存器。<strong>注意</strong>：对于ARM架构，这个地址需要矫正（<code>LR - 4</code>）才能正确返回，流程图中 <code>vector_stub irq, IRQ_MODE, 4</code> 的 <code>4</code> 就是这个矫正值。</li>
<li><strong>跳转到异常向量表</strong>：CPU自动跳转到<strong>异常向量表</strong>的固定地址 <code>0x00000018</code>（对于IRQ）执行。</li>
</ul>
<blockquote>
<p><strong>小结</strong>：至此，CPU在完全由硬件控制的情况下，保存了现场，并跳转到了软件指定的入口。这是任何中断处理的起点。</p>
</blockquote>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; === CPU 硬件自动完成的操作（非实际指令，而是硬件行为） ===</span><br><span class="line"></span><br><span class="line">; 1. 保存状态：将当前 CPSR 保存到 SPSR_irq</span><br><span class="line">SPSR_irq = CPSR</span><br><span class="line"></span><br><span class="line">; 2. 模式切换：修改 CPSR 的低5位，切换到 IRQ 模式</span><br><span class="line">CPSR[4:0] = 0b10010   ; 设置模式为 IRQ</span><br><span class="line"></span><br><span class="line">; 3. 关闭中断：禁用 IRQ</span><br><span class="line">CPSR[7] = 1           ; 设置 I-bit，禁用 IRQ 中断</span><br><span class="line"></span><br><span class="line">; 4. 保存返回地址：将下一条指令的地址保存到 LR_irq</span><br><span class="line">;    注意：由于 ARM 流水线架构，PC 值通常比当前指令超前 2 条指令（8 字节）</span><br><span class="line">;    因此需要矫正，返回地址实际应为 PC - 4（即下一条指令）</span><br><span class="line">LR_irq = PC - 4       ; 对于 ARM 状态，返回地址是当前指令 + 4</span><br><span class="line"></span><br><span class="line">; 5. 跳转到异常向量表：强制将 PC 设置为 IRQ 异常向量的地址</span><br><span class="line">PC = 0x00000018       ; 跳转到 IRQ 异常向量入口</span><br></pre></td></tr></table></figure>

<h3 id="CPU部分其余流程"><a href="#CPU部分其余流程" class="headerlink" title="CPU部分其余流程"></a>CPU部分其余流程</h3><ol>
<li><p><strong>异常向量表 (软件定义的第一跳)</strong></p>
<p>异常向量表是软件预先设置好的一块内存区域，通常由汇编代码定义（如 <code>arch/arm/kernel/entry-armv.S</code>）。CPU只是机械地跳转到这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L__vectors_start:</span><br><span class="line"> W(b) vector_rst    @ 0x00 Reset</span><br><span class="line"> W(b) vector_und    @ 0x04 Undefined Instruction</span><br><span class="line">...</span><br><span class="line"> W(b) vector_irq    @ 0x18 IRQ Interrupt  &lt;-- CPU跳到这里</span><br><span class="line"> W(b) vector_fiq    @ 0x1C FIQ Interrupt</span><br></pre></td></tr></table></figure>

<p><code>vector_irq</code> 是一条跳转指令，跳转到 <code>vector_stub</code> 宏展开的代码。这是软件处理中断的开始。</p>
</li>
<li><p><strong>汇编入口处理 (<code>vector_stub</code> 宏)</strong></p>
<p><code>vector_stub</code> 是一个宏，它负责进行<strong>更精细的现场保存和模式准备</strong>。它的主要工作是：</p>
<ul>
<li><p><strong>地址矫正</strong>：修正 <code>LR</code> 寄存器中的返回地址。</p>
</li>
<li><p><strong>保存寄存器</strong>：将 <code>r0</code> 和 <code>lr</code>（返回地址）暂时压入IRQ模式的栈。</p>
</li>
<li><p><strong>保存原始状态</strong>：将 <code>SPSR_irq</code>（即中断发生时的 <code>CPSR</code>）也保存到栈上。</p>
</li>
<li><p><strong>准备切换到SVC模式</strong>：修改 <code>SPSR</code> 的值，为接下来切换到<strong>SVC模式</strong>做准备。<strong>之所以要切换到SVC模式，是因为SVC模式有更丰富的资源（如栈），方便执行更复杂的C代码。</strong></p>
</li>
<li><p><strong>根据中断发生前的模式进行分发</strong>：根据保存的原始 <code>CPSR</code>，判断中断发生前CPU是处于用户模式（USR）还是内核模式（SVC），从而跳转到不同的处理路径（<code>__irq_usr</code> 或 <code>__irq_svc</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; === arch/arm/kernel/entry-armv.S 中的 vector_stub 宏 ===</span><br><span class="line"></span><br><span class="line">.macro vector_stub, name, mode, correction=0</span><br><span class="line">.align 5</span><br><span class="line">vector_\name:</span><br><span class="line">    .if \correction</span><br><span class="line">        sub lr, lr, #\correction   @ 矫正返回地址！这里 correction=4</span><br><span class="line">    .endif</span><br><span class="line"></span><br><span class="line">    @ 保存 r0 和 lr (用户模式的 PC) 到 IRQ 栈</span><br><span class="line">    stmia sp, &#123;r0, lr&#125;</span><br><span class="line">    mrs lr, spsr                   @ 获取保存的 CPSR (SPSR_irq)</span><br><span class="line">    str lr, [sp, #8]               @ 将 SPSR 也保存到栈上</span><br><span class="line"></span><br><span class="line">    @ 准备切换到 SVC 模式，但 IRQ 仍然保持禁用</span><br><span class="line">    mrs r0, cpsr</span><br><span class="line">    eor r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">    msr spsr_cxsf, r0              @ 设置 SPSR 为 SVC 模式</span><br><span class="line"></span><br><span class="line">    @ 根据中断发生前的模式（保存在 SPSR 中），跳转到不同的处理程序</span><br><span class="line">    and lr, lr, #0x0f              @ 获取之前的模式</span><br><span class="line">    mov r0, sp</span><br><span class="line">    ldr lr, [pc, lr, lsl #2]       @ 根据模式加载跳转地址</span><br><span class="line">    movs pc, lr                    @ 跳转到处理程序，并恢复 CPSR</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">; 使用宏创建 IRQ 向量 stub，并指定矫正值为 4</span><br><span class="line">vector_stub irq, IRQ_MODE, 4</span><br><span class="line"></span><br><span class="line">    .long __irq_usr            @ 0 (USR_26 / USR_32) - 从用户模式中断</span><br><span class="line">    .long __irq_invalid        @ 1 (FIQ_26 / FIQ_32)</span><br><span class="line">    .long __irq_invalid        @ 2 (IRQ_26 / IRQ_32)</span><br><span class="line">    .long __irq_svc            @ 3 (SVC_26 / SVC_32) - 从内核模式中断</span><br><span class="line">    @ ... 其他模式</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中断处理分发 (<code>__irq_usr</code> &#x2F; <code>__irq_svc</code>)</strong></p>
<p>以 <code>__irq_usr</code>（在用户空间被中断）为例：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/entry-armv.S#L426">IRQ_USR</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__irq_usr:</span><br><span class="line">	usr_entry</span><br><span class="line">	kuser_cmpxchg_check</span><br><span class="line">	irq_handler</span><br><span class="line">	get_thread_info tsk</span><br><span class="line">	mov	why, #0</span><br><span class="line">	b	ret_to_user_from_irq</span><br><span class="line"> UNWIND(.fnend		)</span><br><span class="line">ENDPROC(__irq_usr)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>usr_entry</code>：继续保存被中断的用户进程的上下文（所有通用寄存器），形成一个完整的 <code>pt_regs</code> 结构体，保存在栈上。这是后续能够恢复现场的关键。</p>
</li>
<li><p><code>irq_handler</code>：这是<strong>最关键的一步</strong>，它负责获取中断号并跳转到高级别的C语言中断处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.macro	irq_handler</span><br><span class="line">#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER</span><br><span class="line">	ldr	r1, =handle_arch_irq</span><br><span class="line">	mov	r0, sp</span><br><span class="line">	badr	lr, 9997f</span><br><span class="line">	ldr	pc, [r1]</span><br><span class="line">#else</span><br><span class="line">	arch_irq_handler_default</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ul>
<li>它最终会调用一个架构相关的函数（如 <code>arch_irq_handler_default</code>）来获取<strong>硬件中断号（hwirq）</strong>。</li>
<li>然后调用 <code>asm_do_IRQ(hwirq, pt_regs)</code> 或 <code>__handle_domain_irq(...)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/include/asm/entry-macro-multi.S#L7">arch_irq_handler_default</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.macro	arch_irq_handler_default</span><br><span class="line">	get_irqnr_preamble r6, lr</span><br><span class="line">1:	get_irqnr_and_base r0, r2, r6, lr@r0= 中断编号（如果待处理）。r2= 中断状态寄存器。</span><br><span class="line">	movne	r1, sp</span><br><span class="line">	@</span><br><span class="line">	@ routine called with r0 = irq number, r1 = struct pt_regs *</span><br><span class="line">	@</span><br><span class="line">	badrne	lr, 1b</span><br><span class="line">	bne	asm_do_IRQ@如果中断挂起，则分支到 （C 处理程序）。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通用中断处理入口!!!!!</strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/arch/arm/kernel/irq.c#L73">asm_do_IRQ</a>在arch&#x2F;arm&#x2F;kernel&#x2F;irq.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************    1    *********************************/</span></span><br><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line">asmlinkage <span class="type">void</span> __exception_irq_entry</span><br><span class="line"><span class="title function_">asm_do_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	handle_IRQ(irq, regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    2    *********************************/</span></span><br><span class="line"><span class="comment">//arch/arm/kernel/irq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	__handle_domain_irq(<span class="literal">NULL</span>, irq, <span class="literal">false</span>, regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    3    *********************************/</span></span><br><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> __handle_domain_irq(<span class="keyword">struct</span> irq_domain *domain, <span class="type">unsigned</span> <span class="type">int</span> hwirq,</span><br><span class="line">			<span class="type">bool</span> lookup, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = hwirq;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	irq_enter();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_DOMAIN</span></span><br><span class="line">	<span class="keyword">if</span> (lookup)</span><br><span class="line">		irq = irq_find_mapping(domain, hwirq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some hardware gives randomly wrong interrupts.  Rather</span></span><br><span class="line"><span class="comment">	 * than crashing, do something sensible.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!irq || irq &gt;= nr_irqs)) &#123;</span><br><span class="line">		ack_bad_irq(irq);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		generic_handle_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_exit();</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************    4    *********************************/</span></span><br><span class="line"><span class="comment">//kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_handle_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(irq);<span class="comment">//irq变成结构体desc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	data = irq_desc_get_irq_data(desc);</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!in_irq() &amp;&amp; handle_enforce_irqctx(data)))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	generic_handle_irq_desc(desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************    5    *********************************/</span></span><br><span class="line"><span class="comment">//include/linux/irqdesc.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">generic_handle_irq_desc</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>同过上述的流程我们可以发现，CPU部分最终linux调用的<code>desc-&gt;handle_irq(desc);</code>，它的作用是<strong>执行与该中断类型相匹配的、预设的通用流处理（flow handling）逻辑。<strong>它调用的不是一个具体设备驱动注册的函数，而是一个</strong>架构或中断控制器相关的通用处理函数</strong>。这个函数负责处理特定类型中断的通用流程，例如：</p>
<ul>
<li><strong>处理中断控制器交互</strong>：如确认（ACK）、屏蔽（mask）、结束中断（EOI）等操作。</li>
<li><strong>管理中断状态</strong>：处理边缘触发（edge-triggered）或电平触发（level-triggered）中断的特定逻辑。</li>
<li><strong>调用设备驱动</strong>：在适当的时机，调用由设备驱动通过 <code>request_irq()</code> 注册的具体的中断服务程序。</li>
</ul>
<p>常见的 <code>handle_irq</code> 函数指针指向的处理函数有：</p>
<ul>
<li><strong><code>handle_fasteoi_irq</code>: 用于支持“End Of Interrupt”的中断控制器（如 ARM GIC），先处理中断，最后再发送 EOI。</strong></li>
<li><code>handle_level_irq</code>: 用于电平触发中断的处理。在处理前先屏蔽中断，处理完后再打开，防止中断嵌套导致的电平持续触发问题。</li>
<li><code>handle_edge_irq</code>: 用于边缘触发中断的处理。</li>
<li><code>handle_percpu_irq</code>: 用于每个 CPU 独有的中断。</li>
<li><code>handle_simple_irq</code>: 最简单的处理，没有硬件交互，假设所有硬件操作都由驱动自己完成。</li>
</ul>
<p>这个函数指针是在<strong>linux系统启动过程中的中断映射阶段</strong>（例如，在 <code>gic_irq_domain_map</code> 函数中通过 <code>irq_domain_set_info</code> 设置）被初始化的，它根据中断的硬件特性（是电平触发还是边缘触发，是共享的还是 per-CPU 的等）来选择最合适的处理函数。</p>
<blockquote>
<p><strong>小结</strong>：至此，CPU已经完成了从硬件自动响应到汇编保存现场，再到获取中断号并准备调用C处理函数的所有准备工作。中断处理的重心从汇编代码彻底移交给了C代码。</p>
</blockquote>
<h2 id="具体的设备驱动注册过程"><a href="#具体的设备驱动注册过程" class="headerlink" title="具体的设备驱动注册过程"></a>具体的设备驱动注册过程</h2><h3 id="irq-desc结构体"><a href="#irq-desc结构体" class="headerlink" title="irq_desc结构体"></a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/irqdesc.h#L55">irq_desc结构体</a></h3><ul>
<li>在系统启动早期，内核会调用 <code>early_irq_init()</code> 函数（位于 <code>kernel/irq/irqdesc.c</code>）。这个函数的主要职责就是<strong>预分配（或静态初始化）整个 <code>irq_desc</code> 数组</strong>。</li>
</ul>
<p>Linux 内核为每一个<strong>虚拟中断号（VIRQ）</strong> 都维护了一个核心数据结构 <code>struct irq_desc</code>。你可以把它想象成一个中断的“档案袋”或“管理员”，里面记录了这个中断的所有信息。最关键的两个成员是：</p>
<ol>
<li><code>-&gt;handle_irq</code>：指向一个<strong>流处理函数</strong>（例如 <code>handle_fasteoi_irq</code>, <code>handle_level_irq</code>）。这个函数是中断处理框架的“舞台经理”，负责处理中断的通用流程（如确认、屏蔽、EOI等）。</li>
<li><code>-&gt;action</code>：指向一个 <code>struct irqaction</code> 的链表。<strong>你通过 <code>request_irq</code> 注册的信息就封装在这里面</strong>，包括你的中断服务函数 <code>name1irqreturn</code>。</li>
</ol>
<h3 id="驱动注册流程分析"><a href="#驱动注册流程分析" class="headerlink" title="驱动注册流程分析"></a>驱动注册流程分析</h3><ol>
<li><p>当我们使用**<code>request_irq(unsigned int irq, ...)</code>**注册调用函数。传入虚拟中断号 <code>irq</code> 和中断处理函数（例如 <code>name1_irq_return_handle</code>）。<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/include/linux/interrupt.h#L157">request_irq</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>request_threaded_irq()</code></strong>: <code>request_irq</code> 会调用这个函数。它创建一个 <code>struct irqaction</code> 结构体，并将 <code>name1_irq_return_handle</code> 函数指针赋值给 <code>action-&gt;handler</code>。<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/manage.c#L2002">request_threaded_irq()</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">    </span><br><span class="line">    desc = irq_to_desc(irq)<span class="comment">//获取中断描述符 (struct irq_desc)</span></span><br><span class="line">    action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);<span class="comment">//中断动作结构体初始化</span></span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line">    </span><br><span class="line">    retval = __setup_irq(irq, desc, action);<span class="comment">//核心中断设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>__setup_irq()</code></strong><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.4/source/kernel/irq/manage.c#L1359">setup_irq</a>: 这是中断设置的最终函数。它会将上一步创建好的 <code>irqaction</code> 结构体，<strong>添加到 <code>irq_desc[irq]-&gt;action</code> 链表的末尾</strong>。</p>
<p>如果这个中断号被<strong>多个设备驱动共享</strong>（即多个驱动都对同一个 <code>virq</code> 调用了 <code>request_irq(irq, handler, IRQF_SHARED, ...)</code>），那么这个 <code>-&gt;action</code> 链表上就会有<strong>多个 <code>struct irqaction</code> 节点</strong>。每个节点都保存着一个设备驱动的中断服务函数。</p>
<p><strong>中断触发时</strong>：当一个<strong>特定的硬件中断</strong>发生，经过 <code>irq_domain</code> 翻译后，得到对应的<strong>一个虚拟中断号 <code>virqX</code></strong>。</p>
<ul>
<li>内核会找到 <code>irq_desc[virqX]</code>。</li>
<li>然后遍历 <strong><code>irq_desc[virqX]-&gt;action</code></strong> 这个链表。</li>
<li>调用这个链表上<strong>每一个</strong> <code>action-&gt;handler</code>。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Leonardo272.github.io">Leonardo272</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://leonardo272.github.io/2025/05/10/kernel-intc-ch2/">https://leonardo272.github.io/2025/05/10/kernel-intc-ch2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Leonardo272.github.io" target="_blank">Kevin's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux%E5%86%85%E6%A0%B8/">linux内核</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E6%96%AD/">中断</a></div><div class="post-share"><div class="social-share" data-image="/page_images/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/10/kernel-intc-ch3/" title="CH3-中断程序的编写"><img class="cover" src="/page_images/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CH3-中断程序的编写</div></div><div class="info-2"><div class="info-item-1">linux中断程序编写中断的API函数request_irq1int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)  **irq：**要申请中断的中断号。 **handler：**中断处理函数，当中断发生以后就会执行此中断处理函数。 **flags：**中断标志，可以在文件include/linux/interrupt.h 里面查看所有的中断标志    标志 描述    IRQF_SHARED 多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话，request_irq 函数的dev参数就是唯一区分他们的标志。   IRQF_ONESHOT 单次中断，中断执行一次就结束。   IRQF_TRIGGER_NONE 无触发。   IRQF_TRIGGER_RISING 上升沿触发。   IRQF_TRIGGER_FALLING 下降沿触发。   IRQF_TRIGGER_HIGH 高电平触发。   IRQF_T...</div></div></div></a><a class="pagination-related" href="/2025/04/20/MMS-CH4/" title="CH4-内核虚拟空间学习与I.MX6ULL嵌入式驱动开发实践"><img class="cover" src="/page_images/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CH4-内核虚拟空间学习与I.MX6ULL嵌入式驱动开发实践</div></div><div class="info-2"><div class="info-item-1">虚拟内存内核空间    &#x3D;&#x3D;内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。&#x3D;&#x3D; 线性映射区 lowmem在总共大小1G的内核虚拟内存空间中，位于最前边有一块896M大小的区域，我们称之为直接映射区或者线性映射区，地址范围为3G—–3G+896m。 之所以这块896M大小的区域称为直接映射区或者线性映射区，是因为这块连续的虚拟内存地址会映射到0-896M这块连续的物理内存上。 也就是说3G-3G+896m这块896M大小的虚拟内存会直接映射到0-896M这块896M大小的物理内存上，这块区域中的虚拟内存地址直接减去0xC0000000(3G)就得到了物理内存地址。所以我们称这块区域为直接映射区。直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变。   原理线性映射区（Direct Mapping Area）是内核虚拟地址空间中一段固定偏移映射的区域，其核心原理是通过简单的数学关系建立虚拟地址与物理地址的直接对应：  经典通常是： 1虚拟地址 = 物理地址 + PAGE_OFFSET   P...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/10/kernel-intc-ch3/" title="CH3-中断程序的编写"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH3-中断程序的编写</div></div><div class="info-2"><div class="info-item-1">linux中断程序编写中断的API函数request_irq1int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev)  **irq：**要申请中断的中断号。 **handler：**中断处理函数，当中断发生以后就会执行此中断处理函数。 **flags：**中断标志，可以在文件include/linux/interrupt.h 里面查看所有的中断标志    标志 描述    IRQF_SHARED 多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话，request_irq 函数的dev参数就是唯一区分他们的标志。   IRQF_ONESHOT 单次中断，中断执行一次就结束。   IRQF_TRIGGER_NONE 无触发。   IRQF_TRIGGER_RISING 上升沿触发。   IRQF_TRIGGER_FALLING 下降沿触发。   IRQF_TRIGGER_HIGH 高电平触发。   IRQF_T...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc-ch4/" title="CH4-中断的上半部与下半部"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH4-中断的上半部与下半部</div></div><div class="info-2"><div class="info-item-1">中断的上半部与下半部Linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 可以参考：  如果要处理的内容不希望被其他中断打断，那么可以放到上半部。 如果要处理的任务对时间敏感，可以放到上半部。 如果要处理的任务与硬件有关，可以放到上半部 除了上述三点以外的其他任务，优先考虑放到下半部  软中断Linux 内核使用结构体softirq_action 表示软中断， softirq_action结构体定义在文include&#x2F;linux&#x2F;interrupt.h中softirq_action 1234struct softirq_action&#123;	void	(*action)(struct soft...</div></div></div></a><a class="pagination-related" href="/2025/05/10/kernel-intc/" title="CH1-中断子系统介绍"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">CH1-中断子系统介绍</div></div><div class="info-2"><div class="info-item-1">中断子系统中断Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。 中断子系统框架  CPU  中断控制器  外设  中断向量表  中断号  Linux内核中断子系统  中断编程接口（request_irq接口函数）  具体的外设驱动   中断控制器  GIC 是ARM 公司给Cortex-A&#x2F;R 内核提供的一个中断控制器，类似Cortex-M 内核中的NVIC。GIC 接收众多的外部中断，然后对其进行处理，最终就只通过四个信号报给ARM 内核，这四个信号的含义如下：  VFIQ:虚拟快速FIQ。 VIRQ:虚拟外部IRQ。 FIQ:快速中断IRQ。 IRQ:外部中断IRQ。    单核      上图中我们可以看到所有的中断都发送给了GIC控制器，它负责处理各种中断，判断优先级、屏蔽、使能等工作。在GIC控制器中有Distributor、Interface **Distributor(分发器端)：**块负责处理各...</div></div></div></a><a class="pagination-related" href="/2025/06/15/KERNEL-SYSFS-CH1/" title="kernel-sysfs文件系统介绍"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">kernel-sysfs文件系统介绍</div></div><div class="info-2"><div class="info-item-1">sysfs文件系统 sysfs 文件系统的目录  定义：sysfs是一个基于内存的虚拟文件系统（Virtual Filesystem）。它被挂载在 /sys 目录下，是Linux内核中内核对象（kobject）、属性（attribute）和关系（relationship） 的直观体现。 核心作用：sysfs的主要作用是在用户空间（Userspace） 和内核空间（Kernelspace） 之间搭建一座桥梁，提供一个标准化的接口，使得用户空间的程序能够安全、方便地查看和配置内核的运行参数、硬件设备信息、驱动程序状态、电源管理选项等。 具体作用包括：  展示设备层次结构：以目录树的形式清晰地展示系统中总线（bus）、设备（device）、驱动（driver）、类（class）等内核对象的层次关系。 导出对象属性：将内核对象的属性（通常是变量或状态）以普通文件的形式暴露出来。用户可以通过cat命令读取属性，通过echo命令修改属性（如果该属性可写）。 支持用户空间事件：通过poll或select系统调用，用户空间程序可以监听内核发出的事件通知（例如，设备的插拔）。  特点：  层次化结...</div></div></div></a><a class="pagination-related" href="/2025/06/15/kernel-start/" title="linux内核启动"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">linux内核启动</div></div><div class="info-2"><div class="info-item-1">linux内核启动流程start_kernelstart_kernel是所有 Linux 平台进入系统内核初始化后的入口函数，它主要完成剩余的与 硬件平台相关的初始化工作，在进行一系列与内核相关的初始化后，调用第一个用户进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164...</div></div></div></a><a class="pagination-related" href="/2025/06/15/kernel-uboot/" title="uboot"><img class="cover" src="/page_images/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">uboot</div></div><div class="info-2"><div class="info-item-1">U-BootLinux系统要启动就必须需要一个bootloader程序，也就说芯片上电以后先运行一段bootloader 程序。这段bootloader程序会先初始化DDR 等外设，然后将Linux内核从flash(NAND，NOR FLASH，SD，MMC 等)拷贝到DDR中，最后启动Linux内核。它最主要的工作就是启动Linux内核 U-Boot的主要作用U-Boot在嵌入式系统中的核心作用主要体现在以下几个方面：  硬件初始化与管理：U-Boot负责进行Soc级（内部外设）和板级（外部外设）的硬件管理，初始化系统运行所必需的硬件，如CPU、时钟、内存（SDRAM）、串口、网卡、存储设备（如NAND Flash）等。这是内核正确运行的基础。 镜像烧录（刷机）：U-Boot是系统更新的关键工具。它可以通过特定的命令配合PC端工具，完成包括U-Boot自身、内核、根文件系统等镜像的烧写。 加载并启动操作系统内核：这是U-Boot的终极使命。它会从存储设备（如Flash、SD卡）上读取操作系统内核镜像（如Linux的zImage或uImage）和可选的设备树 dtb（DTB），将...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Leonardo272</div><div class="author-info-description">keep on going!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leonardo272"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Leonardo272" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2079232659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">enjoy your life</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">linux中断处理的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">linux系统启动的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#irq-domain"><span class="toc-number">1.1.1.</span> <span class="toc-text">irq_domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">系统启动的流程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">CPU部分流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%83%A8%E5%88%86%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">硬件部分自动完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E9%83%A8%E5%88%86%E5%85%B6%E4%BD%99%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">CPU部分其余流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">具体的设备驱动注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#irq-desc%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.1.</span> <span class="toc-text">irq_desc结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">驱动注册流程分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高危工作环境中人员安全装备佩戴检测系统"/></a><div class="content"><a class="title" href="/2025/07/20/conptition/" title="高危工作环境中人员安全装备佩戴检测系统">高危工作环境中人员安全装备佩戴检测系统</a><time datetime="2025-07-20T14:33:00.000Z" title="发表于 2025-07-20 22:33:00">2025-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="镜像烧录+ssh远程登录"/></a><div class="content"><a class="title" href="/2025/07/17/1/" title="镜像烧录+ssh远程登录">镜像烧录+ssh远程登录</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/2/" title="常见问题"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见问题"/></a><div class="content"><a class="title" href="/2025/07/17/2/" title="常见问题">常见问题</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/3/" title="开发环境配置"><img src="/page_images/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="开发环境配置"/></a><div class="content"><a class="title" href="/2025/07/17/3/" title="开发环境配置">开发环境配置</a><time datetime="2025-07-17T14:33:00.000Z" title="发表于 2025-07-17 22:33:00">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI"><img src="/page_images/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="驱动开发-SPI"/></a><div class="content"><a class="title" href="/2025/06/20/DRIVER-CH4-SPI/" title="驱动开发-SPI">驱动开发-SPI</a><time datetime="2025-06-20T13:12:00.000Z" title="发表于 2025-06-20 21:12:00">2025-06-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/foot.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Leonardo272</span></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="keep,on,going" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>